"use strict";
(self["webpackChunkfloristby"] = self["webpackChunkfloristby"] || []).push([["vendors-node_modules_react-virtuoso_dist_index_mjs"],{

/***/ "./node_modules/react-virtuoso/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/react-virtuoso/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GroupedVirtuoso: () => (/* binding */ GroupedVirtuoso),
/* harmony export */   LogLevel: () => (/* binding */ LogLevel),
/* harmony export */   TableVirtuoso: () => (/* binding */ TableVirtuoso),
/* harmony export */   Virtuoso: () => (/* binding */ Virtuoso),
/* harmony export */   VirtuosoGrid: () => (/* binding */ VirtuosoGrid),
/* harmony export */   VirtuosoGridMockContext: () => (/* binding */ VirtuosoGridMockContext),
/* harmony export */   VirtuosoMockContext: () => (/* binding */ VirtuosoMockContext)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");


const PUBLISH = 0;
const SUBSCRIBE = 1;
const RESET = 2;
const VALUE = 4;
function compose(a, b) {
  return (arg) => a(b(arg));
}
function thrush(arg, proc) {
  return proc(arg);
}
function curry2to1(proc, arg1) {
  return (arg2) => proc(arg1, arg2);
}
function curry1to0(proc, arg) {
  return () => proc(arg);
}
function tap(arg, proc) {
  proc(arg);
  return arg;
}
function tup(...args) {
  return args;
}
function call(proc) {
  proc();
}
function always(value) {
  return () => value;
}
function joinProc(...procs) {
  return () => {
    procs.map(call);
  };
}
function isDefined(arg) {
  return arg !== void 0;
}
function noop() {
}
function subscribe(emitter, subscription) {
  return emitter(SUBSCRIBE, subscription);
}
function publish(publisher, value) {
  publisher(PUBLISH, value);
}
function reset(emitter) {
  emitter(RESET);
}
function getValue(depot) {
  return depot(VALUE);
}
function connect(emitter, publisher) {
  return subscribe(emitter, curry2to1(publisher, PUBLISH));
}
function handleNext(emitter, subscription) {
  const unsub = emitter(SUBSCRIBE, (value) => {
    unsub();
    subscription(value);
  });
  return unsub;
}
function stream() {
  const subscriptions = [];
  return (action, arg) => {
    switch (action) {
      case RESET:
        subscriptions.splice(0, subscriptions.length);
        return;
      case SUBSCRIBE:
        subscriptions.push(arg);
        return () => {
          const indexOf = subscriptions.indexOf(arg);
          if (indexOf > -1) {
            subscriptions.splice(indexOf, 1);
          }
        };
      case PUBLISH:
        subscriptions.slice().forEach((subscription) => {
          subscription(arg);
        });
        return;
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
function statefulStream(initial) {
  let value = initial;
  const innerSubject = stream();
  return (action, arg) => {
    switch (action) {
      case SUBSCRIBE:
        const subscription = arg;
        subscription(value);
        break;
      case PUBLISH:
        value = arg;
        break;
      case VALUE:
        return value;
    }
    return innerSubject(action, arg);
  };
}
function eventHandler(emitter) {
  let unsub;
  let currentSubscription;
  const cleanup = () => unsub && unsub();
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        if (subscription) {
          if (currentSubscription === subscription) {
            return;
          }
          cleanup();
          currentSubscription = subscription;
          unsub = subscribe(emitter, subscription);
          return unsub;
        } else {
          cleanup();
          return noop;
        }
      case RESET:
        cleanup();
        currentSubscription = null;
        return;
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
function streamFromEmitter(emitter) {
  return tap(stream(), (stream2) => connect(emitter, stream2));
}
function statefulStreamFromEmitter(emitter, initial) {
  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));
}
function combineOperators(...operators) {
  return (subscriber) => {
    return operators.reduceRight(thrush, subscriber);
  };
}
function pipe(source, ...operators) {
  const project = combineOperators(...operators);
  return (action, subscription) => {
    switch (action) {
      case SUBSCRIBE:
        return subscribe(source, project(subscription));
      case RESET:
        reset(source);
        return;
    }
  };
}
function defaultComparator(previous, next) {
  return previous === next;
}
function distinctUntilChanged(comparator = defaultComparator) {
  let current;
  return (done) => (next) => {
    if (!comparator(current, next)) {
      current = next;
      done(next);
    }
  };
}
function filter(predicate) {
  return (done) => (value) => {
    predicate(value) && done(value);
  };
}
function map(project) {
  return (done) => compose(done, project);
}
function mapTo(value) {
  return (done) => () => done(value);
}
function scan(scanner, initial) {
  return (done) => (value) => done(initial = scanner(initial, value));
}
function skip(times) {
  return (done) => (value) => {
    times > 0 ? times-- : done(value);
  };
}
function throttleTime(interval) {
  let currentValue = null;
  let timeout;
  return (done) => (value) => {
    currentValue = value;
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      timeout = void 0;
      done(currentValue);
    }, interval);
  };
}
function debounceTime(interval) {
  let currentValue;
  let timeout;
  return (done) => (value) => {
    currentValue = value;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      done(currentValue);
    }, interval);
  };
}
function withLatestFrom(...sources) {
  const values = new Array(sources.length);
  let called = 0;
  let pendingCall = null;
  const allCalled = Math.pow(2, sources.length) - 1;
  sources.forEach((source, index) => {
    const bit = Math.pow(2, index);
    subscribe(source, (value) => {
      const prevCalled = called;
      called = called | bit;
      values[index] = value;
      if (prevCalled !== allCalled && called === allCalled && pendingCall) {
        pendingCall();
        pendingCall = null;
      }
    });
  });
  return (done) => (value) => {
    const call2 = () => done([value].concat(values));
    if (called === allCalled) {
      call2();
    } else {
      pendingCall = call2;
    }
  };
}
function merge(...sources) {
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        return joinProc(...sources.map((source) => subscribe(source, subscription)));
      case RESET:
        return;
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
function duc(source, comparator = defaultComparator) {
  return pipe(source, distinctUntilChanged(comparator));
}
function combineLatest(...emitters) {
  const innerSubject = stream();
  const values = new Array(emitters.length);
  let called = 0;
  const allCalled = Math.pow(2, emitters.length) - 1;
  emitters.forEach((source, index) => {
    const bit = Math.pow(2, index);
    subscribe(source, (value) => {
      values[index] = value;
      called = called | bit;
      if (called === allCalled) {
        publish(innerSubject, values);
      }
    });
  });
  return function(action, subscription) {
    switch (action) {
      case SUBSCRIBE:
        if (called === allCalled) {
          subscription(values);
        }
        return subscribe(innerSubject, subscription);
      case RESET:
        return reset(innerSubject);
      default:
        throw new Error(`unrecognized action ${action}`);
    }
  };
}
function system(constructor, dependencies = [], { singleton } = { singleton: true }) {
  return {
    id: id(),
    constructor,
    dependencies,
    singleton
  };
}
const id = () => Symbol();
function init(systemSpec) {
  const singletons = /* @__PURE__ */ new Map();
  const _init = ({ id: id2, constructor, dependencies, singleton }) => {
    if (singleton && singletons.has(id2)) {
      return singletons.get(id2);
    }
    const system2 = constructor(dependencies.map((e) => _init(e)));
    if (singleton) {
      singletons.set(id2, system2);
    }
    return system2;
  };
  return _init(systemSpec);
}
function omit(keys, obj) {
  const result = {};
  const index = {};
  let idx = 0;
  const len = keys.length;
  while (idx < len) {
    index[keys[idx]] = 1;
    idx += 1;
  }
  for (const prop in obj) {
    if (!index.hasOwnProperty(prop)) {
      result[prop] = obj[prop];
    }
  }
  return result;
}
const useIsomorphicLayoutEffect$2 = typeof document !== "undefined" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;
function systemToComponent(systemSpec, map2, Root) {
  const requiredPropNames = Object.keys(map2.required || {});
  const optionalPropNames = Object.keys(map2.optional || {});
  const methodNames = Object.keys(map2.methods || {});
  const eventNames = Object.keys(map2.events || {});
  const Context = react__WEBPACK_IMPORTED_MODULE_0__.createContext({});
  function applyPropsToSystem(system2, props) {
    if (system2["propsReady"]) {
      publish(system2["propsReady"], false);
    }
    for (const requiredPropName of requiredPropNames) {
      const stream2 = system2[map2.required[requiredPropName]];
      publish(stream2, props[requiredPropName]);
    }
    for (const optionalPropName of optionalPropNames) {
      if (optionalPropName in props) {
        const stream2 = system2[map2.optional[optionalPropName]];
        publish(stream2, props[optionalPropName]);
      }
    }
    if (system2["propsReady"]) {
      publish(system2["propsReady"], true);
    }
  }
  function buildMethods(system2) {
    return methodNames.reduce((acc, methodName) => {
      acc[methodName] = (value) => {
        const stream2 = system2[map2.methods[methodName]];
        publish(stream2, value);
      };
      return acc;
    }, {});
  }
  function buildEventHandlers(system2) {
    return eventNames.reduce((handlers, eventName) => {
      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);
      return handlers;
    }, {});
  }
  const Component = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((propsWithChildren, ref) => {
    const { children, ...props } = propsWithChildren;
    const [system2] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));
    });
    const [handlers] = react__WEBPACK_IMPORTED_MODULE_0__.useState(curry1to0(buildEventHandlers, system2));
    useIsomorphicLayoutEffect$2(() => {
      for (const eventName of eventNames) {
        if (eventName in props) {
          subscribe(handlers[eventName], props[eventName]);
        }
      }
      return () => {
        Object.values(handlers).map(reset);
      };
    }, [props, handlers, system2]);
    useIsomorphicLayoutEffect$2(() => {
      applyPropsToSystem(system2, props);
    });
    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, always(buildMethods(system2)));
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      Context.Provider,
      { value: system2 },
      Root ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        Root,
        omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),
        children
      ) : children
    );
  });
  const usePublisher2 = (key) => {
    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(curry2to1(publish, react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context)[key]), [key]);
  };
  const useEmitterValue2 = (key) => {
    const system2 = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);
    const source = system2[key];
    const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(curry1to0(getValue, source));
    useIsomorphicLayoutEffect$2(
      () => subscribe(source, (next) => {
        if (next !== value) {
          setValue(always(next));
        }
      }),
      [source, value]
    );
    return value;
  };
  const useEmitter2 = (key, callback) => {
    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);
    const source = context[key];
    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);
  };
  return {
    Component,
    usePublisher: usePublisher2,
    useEmitterValue: useEmitterValue2,
    useEmitter: useEmitter2
  };
}
const useIsomorphicLayoutEffect = typeof document !== "undefined" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;
const useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
const CONSOLE_METHOD_MAP = {
  [
    0
    /* DEBUG */
  ]: "debug",
  [
    1
    /* INFO */
  ]: "log",
  [
    2
    /* WARN */
  ]: "warn",
  [
    3
    /* ERROR */
  ]: "error"
};
const getGlobalThis = () => typeof globalThis === "undefined" ? window : globalThis;
const loggerSystem = system(
  () => {
    const logLevel = statefulStream(
      3
      /* ERROR */
    );
    const log = statefulStream((label, message, level = 1) => {
      var _a;
      const currentLevel = (_a = getGlobalThis()["VIRTUOSO_LOG_LEVEL"]) != null ? _a : getValue(logLevel);
      if (level >= currentLevel) {
        console[CONSOLE_METHOD_MAP[level]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          label,
          message
        );
      }
    });
    return {
      log,
      logLevel
    };
  },
  [],
  { singleton: true }
);
function useSizeWithElRef(callback, enabled = true) {
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  let callbackRef = (_el) => {
  };
  if (typeof ResizeObserver !== "undefined") {
    const observer = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
      return new ResizeObserver((entries) => {
        const element = entries[0].target;
        if (element.offsetParent !== null) {
          callback(element);
        }
      });
    }, [callback]);
    callbackRef = (elRef) => {
      if (elRef && enabled) {
        observer.observe(elRef);
        ref.current = elRef;
      } else {
        if (ref.current) {
          observer.unobserve(ref.current);
        }
        ref.current = null;
      }
    };
  }
  return { ref, callbackRef };
}
function useSize(callback, enabled = true) {
  return useSizeWithElRef(callback, enabled).callbackRef;
}
function useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {
  const memoedCallback = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (el) => {
      const ranges = getChangedChildSizes(el.children, itemSize, "offsetHeight", log);
      let scrollableElement = el.parentElement;
      while (!scrollableElement.dataset["virtuosoScroller"]) {
        scrollableElement = scrollableElement.parentElement;
      }
      const windowScrolling = scrollableElement.lastElementChild.dataset["viewportType"] === "window";
      const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;
      const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;
      const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;
      scrollContainerStateCallback({
        scrollTop: Math.max(scrollTop, 0),
        scrollHeight,
        viewportHeight
      });
      gap == null ? void 0 : gap(resolveGapValue$1("row-gap", getComputedStyle(el).rowGap, log));
      if (ranges !== null) {
        callback(ranges);
      }
    },
    [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]
  );
  return useSizeWithElRef(memoedCallback, enabled);
}
function getChangedChildSizes(children, itemSize, field, log) {
  const length = children.length;
  if (length === 0) {
    return null;
  }
  const results = [];
  for (let i = 0; i < length; i++) {
    const child = children.item(i);
    if (!child || child.dataset.index === void 0) {
      continue;
    }
    const index = parseInt(child.dataset.index);
    const knownSize = parseFloat(child.dataset.knownSize);
    const size = itemSize(child, field);
    if (size === 0) {
      log("Zero-sized element, this should not happen", { child }, LogLevel.ERROR);
    }
    if (size === knownSize) {
      continue;
    }
    const lastResult = results[results.length - 1];
    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {
      results.push({ startIndex: index, endIndex: index, size });
    } else {
      results[results.length - 1].endIndex++;
    }
  }
  return results;
}
function resolveGapValue$1(property, value, log) {
  if (value !== "normal" && !(value == null ? void 0 : value.endsWith("px"))) {
    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);
  }
  if (value === "normal") {
    return 0;
  }
  return parseInt(value != null ? value : "0", 10);
}
function correctItemSize(el, dimension) {
  return Math.round(el.getBoundingClientRect()[dimension]);
}
function approximatelyEqual(num1, num2) {
  return Math.abs(num1 - num2) < 1.01;
}
function useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent) {
  const scrollerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const scrollTopTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const handler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (ev) => {
      const el = ev.target;
      const windowScroll = el === window || el === document;
      const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;
      const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;
      const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;
      const call2 = () => {
        scrollContainerStateCallback({
          scrollTop: Math.max(scrollTop, 0),
          scrollHeight,
          viewportHeight
        });
      };
      if (ev.suppressFlushSync) {
        call2();
      } else {
        react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(call2);
      }
      if (scrollTopTarget.current !== null) {
        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {
          scrollTopTarget.current = null;
          smoothScrollTargetReached(true);
          if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
        }
      }
    },
    [scrollContainerStateCallback, smoothScrollTargetReached]
  );
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;
    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);
    handler({ target: localRef, suppressFlushSync: true });
    localRef.addEventListener("scroll", handler, { passive: true });
    return () => {
      scrollerRefCallback(null);
      localRef.removeEventListener("scroll", handler);
    };
  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);
  function scrollToCallback(location) {
    const scrollerElement2 = scrollerRef.current;
    if (!scrollerElement2 || "offsetHeight" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {
      return;
    }
    const isSmooth = location.behavior === "smooth";
    let offsetHeight;
    let scrollHeight;
    let scrollTop;
    if (scrollerElement2 === window) {
      scrollHeight = Math.max(correctItemSize(document.documentElement, "height"), document.documentElement.scrollHeight);
      offsetHeight = window.innerHeight;
      scrollTop = document.documentElement.scrollTop;
    } else {
      scrollHeight = scrollerElement2.scrollHeight;
      offsetHeight = correctItemSize(scrollerElement2, "height");
      scrollTop = scrollerElement2.scrollTop;
    }
    const maxScrollTop = scrollHeight - offsetHeight;
    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));
    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {
      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });
      if (isSmooth) {
        smoothScrollTargetReached(true);
      }
      return;
    }
    if (isSmooth) {
      scrollTopTarget.current = location.top;
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        timeoutRef.current = null;
        scrollTopTarget.current = null;
        smoothScrollTargetReached(true);
      }, 1e3);
    } else {
      scrollTopTarget.current = null;
    }
    scrollerElement2.scrollTo(location);
  }
  function scrollByCallback(location) {
    scrollerRef.current.scrollBy(location);
  }
  return { scrollerRef, scrollByCallback, scrollToCallback };
}
const domIOSystem = system(
  () => {
    const scrollContainerState = stream();
    const scrollTop = stream();
    const deviation = statefulStream(0);
    const smoothScrollTargetReached = stream();
    const statefulScrollTop = statefulStream(0);
    const viewportHeight = stream();
    const scrollHeight = stream();
    const headerHeight = statefulStream(0);
    const fixedHeaderHeight = statefulStream(0);
    const fixedFooterHeight = statefulStream(0);
    const footerHeight = statefulStream(0);
    const scrollTo = stream();
    const scrollBy = stream();
    const scrollingInProgress = statefulStream(false);
    connect(
      pipe(
        scrollContainerState,
        map(({ scrollTop: scrollTop2 }) => scrollTop2)
      ),
      scrollTop
    );
    connect(
      pipe(
        scrollContainerState,
        map(({ scrollHeight: scrollHeight2 }) => scrollHeight2)
      ),
      scrollHeight
    );
    connect(scrollTop, statefulScrollTop);
    return {
      // input
      scrollContainerState,
      scrollTop,
      viewportHeight,
      headerHeight,
      fixedHeaderHeight,
      fixedFooterHeight,
      footerHeight,
      scrollHeight,
      smoothScrollTargetReached,
      // signals
      scrollTo,
      scrollBy,
      // state
      statefulScrollTop,
      deviation,
      scrollingInProgress
    };
  },
  [],
  { singleton: true }
);
const NIL_NODE = { lvl: 0 };
function newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {
  return { k, v, lvl, l, r };
}
function empty(node) {
  return node === NIL_NODE;
}
function newTree() {
  return NIL_NODE;
}
function remove(node, key) {
  if (empty(node))
    return NIL_NODE;
  const { k, l, r } = node;
  if (key === k) {
    if (empty(l)) {
      return r;
    } else if (empty(r)) {
      return l;
    } else {
      const [lastKey, lastValue] = last(l);
      return adjust(clone(node, { k: lastKey, v: lastValue, l: deleteLast(l) }));
    }
  } else if (key < k) {
    return adjust(clone(node, { l: remove(l, key) }));
  } else {
    return adjust(clone(node, { r: remove(r, key) }));
  }
}
function find(node, key) {
  if (empty(node)) {
    return;
  }
  if (key === node.k) {
    return node.v;
  } else if (key < node.k) {
    return find(node.l, key);
  } else {
    return find(node.r, key);
  }
}
function findMaxKeyValue(node, value, field = "k") {
  if (empty(node)) {
    return [-Infinity, void 0];
  }
  if (Number(node[field]) === value) {
    return [node.k, node.v];
  }
  if (Number(node[field]) < value) {
    const r = findMaxKeyValue(node.r, value, field);
    if (r[0] === -Infinity) {
      return [node.k, node.v];
    } else {
      return r;
    }
  }
  return findMaxKeyValue(node.l, value, field);
}
function insert(node, k, v) {
  if (empty(node)) {
    return newAANode(k, v, 1);
  }
  if (k === node.k) {
    return clone(node, { k, v });
  } else if (k < node.k) {
    return rebalance(clone(node, { l: insert(node.l, k, v) }));
  } else {
    return rebalance(clone(node, { r: insert(node.r, k, v) }));
  }
}
function walkWithin(node, start, end) {
  if (empty(node)) {
    return [];
  }
  const { k, v, l, r } = node;
  let result = [];
  if (k > start) {
    result = result.concat(walkWithin(l, start, end));
  }
  if (k >= start && k <= end) {
    result.push({ k, v });
  }
  if (k <= end) {
    result = result.concat(walkWithin(r, start, end));
  }
  return result;
}
function walk(node) {
  if (empty(node)) {
    return [];
  }
  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)];
}
function last(node) {
  return empty(node.r) ? [node.k, node.v] : last(node.r);
}
function deleteLast(node) {
  return empty(node.r) ? node.l : adjust(clone(node, { r: deleteLast(node.r) }));
}
function clone(node, args) {
  return newAANode(
    args.k !== void 0 ? args.k : node.k,
    args.v !== void 0 ? args.v : node.v,
    args.lvl !== void 0 ? args.lvl : node.lvl,
    args.l !== void 0 ? args.l : node.l,
    args.r !== void 0 ? args.r : node.r
  );
}
function isSingle(node) {
  return empty(node) || node.lvl > node.r.lvl;
}
function rebalance(node) {
  return split(skew(node));
}
function adjust(node) {
  const { l, r, lvl } = node;
  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {
    return node;
  } else if (lvl > r.lvl + 1) {
    if (isSingle(l)) {
      return skew(clone(node, { lvl: lvl - 1 }));
    } else {
      if (!empty(l) && !empty(l.r)) {
        return clone(l.r, {
          l: clone(l, { r: l.r.l }),
          r: clone(node, {
            l: l.r.r,
            lvl: lvl - 1
          }),
          lvl
        });
      } else {
        throw new Error("Unexpected empty nodes");
      }
    }
  } else {
    if (isSingle(node)) {
      return split(clone(node, { lvl: lvl - 1 }));
    } else {
      if (!empty(r) && !empty(r.l)) {
        const rl = r.l;
        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;
        return clone(rl, {
          l: clone(node, {
            r: rl.l,
            lvl: lvl - 1
          }),
          r: split(clone(r, { l: rl.r, lvl: rlvl })),
          lvl: rl.lvl + 1
        });
      } else {
        throw new Error("Unexpected empty nodes");
      }
    }
  }
}
function rangesWithin(node, startIndex, endIndex) {
  if (empty(node)) {
    return [];
  }
  const adjustedStart = findMaxKeyValue(node, startIndex)[0];
  return toRanges(walkWithin(node, adjustedStart, endIndex));
}
function arrayToRanges(items, parser) {
  const length = items.length;
  if (length === 0) {
    return [];
  }
  let { index: start, value } = parser(items[0]);
  const result = [];
  for (let i = 1; i < length; i++) {
    const { index: nextIndex, value: nextValue } = parser(items[i]);
    result.push({ start, end: nextIndex - 1, value });
    start = nextIndex;
    value = nextValue;
  }
  result.push({ start, end: Infinity, value });
  return result;
}
function toRanges(nodes) {
  return arrayToRanges(nodes, ({ k: index, v: value }) => ({ index, value }));
}
function split(node) {
  const { r, lvl } = node;
  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, { l: clone(node, { r: r.l }), lvl: lvl + 1 }) : node;
}
function skew(node) {
  const { l } = node;
  return !empty(l) && l.lvl === node.lvl ? clone(l, { r: clone(node, { l: l.r }) }) : node;
}
function findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {
  let end = items.length - 1;
  while (start <= end) {
    const index = Math.floor((start + end) / 2);
    const item = items[index];
    const match = comparator(item, value);
    if (match === 0) {
      return index;
    }
    if (match === -1) {
      if (end - start < 2) {
        return index - 1;
      }
      end = index - 1;
    } else {
      if (end === start) {
        return index;
      }
      start = index + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${items.join(",")}, searched for ${value}`);
}
function findClosestSmallerOrEqual(items, value, comparator) {
  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];
}
function findRange(items, startValue, endValue, comparator) {
  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);
  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);
  return items.slice(startIndex, endIndex + 1);
}
const recalcSystem = system(
  () => {
    const recalcInProgress = statefulStream(false);
    return { recalcInProgress };
  },
  [],
  { singleton: true }
);
function rangeIncludes(refRange) {
  const { size, startIndex, endIndex } = refRange;
  return (range) => {
    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;
  };
}
function affectedGroupCount(offset, groupIndices) {
  let recognizedOffsetItems = 0;
  let groupIndex = 0;
  while (recognizedOffsetItems < offset) {
    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
    groupIndex++;
  }
  const offsetIsExact = recognizedOffsetItems === offset;
  return groupIndex - (offsetIsExact ? 0 : 1);
}
function insertRanges(sizeTree, ranges) {
  let syncStart = empty(sizeTree) ? 0 : Infinity;
  for (const range of ranges) {
    const { size, startIndex, endIndex } = range;
    syncStart = Math.min(syncStart, startIndex);
    if (empty(sizeTree)) {
      sizeTree = insert(sizeTree, 0, size);
      continue;
    }
    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);
    if (overlappingRanges.some(rangeIncludes(range))) {
      continue;
    }
    let firstPassDone = false;
    let shouldInsert = false;
    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {
      if (!firstPassDone) {
        shouldInsert = rangeValue !== size;
        firstPassDone = true;
      } else {
        if (endIndex >= rangeStart || size === rangeValue) {
          sizeTree = remove(sizeTree, rangeStart);
        }
      }
      if (rangeEnd > endIndex && endIndex >= rangeStart) {
        if (rangeValue !== size) {
          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);
        }
      }
    }
    if (shouldInsert) {
      sizeTree = insert(sizeTree, startIndex, size);
    }
  }
  return [sizeTree, syncStart];
}
function initialSizeState() {
  return {
    offsetTree: [],
    sizeTree: newTree(),
    groupOffsetTree: newTree(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    groupIndices: []
  };
}
function indexComparator({ index: itemIndex }, index) {
  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;
}
function offsetComparator({ offset: itemOffset }, offset) {
  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;
}
function offsetPointParser(point) {
  return { index: point.index, value: point };
}
function rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {
  if (minStartIndex > 0) {
    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);
  }
  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);
}
function createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {
  let offsetTree = prevOffsetTree;
  let prevIndex = 0;
  let prevSize = 0;
  let prevOffset = 0;
  let startIndex = 0;
  if (syncStart !== 0) {
    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);
    const offsetInfo = offsetTree[startIndex];
    prevOffset = offsetInfo.offset;
    const kv = findMaxKeyValue(sizeTree, syncStart - 1);
    prevIndex = kv[0];
    prevSize = kv[1];
    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {
      startIndex -= 1;
    }
    offsetTree = offsetTree.slice(0, startIndex + 1);
  } else {
    offsetTree = [];
  }
  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {
    const indexOffset = startIndex2 - prevIndex;
    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;
    offsetTree.push({
      offset: aOffset,
      size: value,
      index: startIndex2
    });
    prevIndex = startIndex2;
    prevOffset = aOffset;
    prevSize = value;
  }
  return {
    offsetTree,
    lastIndex: prevIndex,
    lastOffset: prevOffset,
    lastSize: prevSize
  };
}
function sizeStateReducer(state, [ranges, groupIndices, log, gap]) {
  if (ranges.length > 0) {
    log("received item sizes", ranges, LogLevel.DEBUG);
  }
  const sizeTree = state.sizeTree;
  let newSizeTree = sizeTree;
  let syncStart = 0;
  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {
    const groupSize = ranges[0].size;
    const itemSize = ranges[1].size;
    newSizeTree = groupIndices.reduce((tree, groupIndex) => {
      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);
    }, newSizeTree);
  } else {
    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);
  }
  if (newSizeTree === sizeTree) {
    return state;
  }
  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);
  return {
    sizeTree: newSizeTree,
    offsetTree: newOffsetTree,
    lastIndex,
    lastOffset,
    lastSize,
    groupOffsetTree: groupIndices.reduce((tree, index) => {
      return insert(tree, index, offsetOf(index, newOffsetTree, gap));
    }, newTree()),
    groupIndices
  };
}
function offsetOf(index, tree, gap) {
  if (tree.length === 0) {
    return 0;
  }
  const { offset, index: startIndex, size } = findClosestSmallerOrEqual(tree, index, indexComparator);
  const itemCount = index - startIndex;
  const top = size * itemCount + (itemCount - 1) * gap + offset;
  return top > 0 ? top + gap : top;
}
function isGroupLocation(location) {
  return typeof location.groupIndex !== "undefined";
}
function originalIndexFromLocation(location, sizes, lastIndex) {
  if (isGroupLocation(location)) {
    return sizes.groupIndices[location.groupIndex] + 1;
  } else {
    const numericIndex = location.index === "LAST" ? lastIndex : location.index;
    let result = originalIndexFromItemIndex(numericIndex, sizes);
    result = Math.max(0, result, Math.min(lastIndex, result));
    return result;
  }
}
function originalIndexFromItemIndex(itemIndex, sizes) {
  if (!hasGroups(sizes)) {
    return itemIndex;
  }
  let groupOffset = 0;
  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {
    groupOffset++;
  }
  return itemIndex + groupOffset;
}
function hasGroups(sizes) {
  return !empty(sizes.groupOffsetTree);
}
function sizeTreeToRanges(sizeTree) {
  return walk(sizeTree).map(({ k: startIndex, v: size }, index, sizeArray) => {
    const nextSize = sizeArray[index + 1];
    const endIndex = nextSize ? nextSize.k - 1 : Infinity;
    return { startIndex, endIndex, size };
  });
}
const SIZE_MAP = {
  offsetHeight: "height",
  offsetWidth: "width"
};
const sizeSystem = system(
  ([{ log }, { recalcInProgress }]) => {
    const sizeRanges = stream();
    const totalCount = stream();
    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);
    const unshiftWith = stream();
    const shiftWith = stream();
    const firstItemIndex = statefulStream(0);
    const groupIndices = statefulStream([]);
    const fixedItemSize = statefulStream(void 0);
    const defaultItemSize = statefulStream(void 0);
    const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));
    const data = statefulStream(void 0);
    const gap = statefulStream(0);
    const initial = initialSizeState();
    const sizes = statefulStreamFromEmitter(
      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()),
      initial
    );
    const prevGroupIndices = statefulStreamFromEmitter(
      pipe(
        groupIndices,
        distinctUntilChanged(),
        scan((prev, curr) => ({ prev: prev.current, current: curr }), {
          prev: [],
          current: []
        }),
        map(({ prev }) => prev)
      ),
      []
    );
    connect(
      pipe(
        groupIndices,
        filter((indexes) => indexes.length > 0),
        withLatestFrom(sizes, gap),
        map(([groupIndices2, sizes2, gap2]) => {
          const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {
            return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);
          }, newTree());
          return {
            ...sizes2,
            groupIndices: groupIndices2,
            groupOffsetTree
          };
        })
      ),
      sizes
    );
    connect(
      pipe(
        totalCount,
        withLatestFrom(sizes),
        filter(([totalCount2, { lastIndex }]) => {
          return totalCount2 < lastIndex;
        }),
        map(([totalCount2, { lastIndex, lastSize }]) => {
          return [
            {
              startIndex: totalCount2,
              endIndex: lastIndex,
              size: lastSize
            }
          ];
        })
      ),
      sizeRanges
    );
    connect(fixedItemSize, defaultItemSize);
    const trackItemSizes = statefulStreamFromEmitter(
      pipe(
        fixedItemSize,
        map((size) => size === void 0)
      ),
      true
    );
    connect(
      pipe(
        defaultItemSize,
        filter((value) => {
          return value !== void 0 && empty(getValue(sizes).sizeTree);
        }),
        map((size) => [{ startIndex: 0, endIndex: 0, size }])
      ),
      sizeRanges
    );
    const listRefresh = streamFromEmitter(
      pipe(
        sizeRanges,
        withLatestFrom(sizes),
        scan(
          ({ sizes: oldSizes }, [_, newSizes]) => {
            return {
              changed: newSizes !== oldSizes,
              sizes: newSizes
            };
          },
          { changed: false, sizes: initial }
        ),
        map((value) => value.changed)
      )
    );
    subscribe(
      pipe(
        firstItemIndex,
        scan(
          (prev, next) => {
            return { diff: prev.prev - next, prev: next };
          },
          { diff: 0, prev: 0 }
        ),
        map((val) => val.diff)
      ),
      (offset) => {
        const { groupIndices: groupIndices2 } = getValue(sizes);
        if (offset > 0) {
          publish(recalcInProgress, true);
          publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));
        } else if (offset < 0) {
          const prevGroupIndicesValue = getValue(prevGroupIndices);
          if (prevGroupIndicesValue.length > 0) {
            offset -= affectedGroupCount(-offset, prevGroupIndicesValue);
          }
          publish(shiftWith, offset);
        }
      }
    );
    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {
      if (index < 0) {
        log2(
          "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
          { firstItemIndex },
          LogLevel.ERROR
        );
      }
    });
    const beforeUnshiftWith = streamFromEmitter(unshiftWith);
    connect(
      pipe(
        unshiftWith,
        withLatestFrom(sizes),
        map(([unshiftWith2, sizes2]) => {
          const groupedMode = sizes2.groupIndices.length > 0;
          const initialRanges = [];
          const defaultSize = sizes2.lastSize;
          if (groupedMode) {
            const firstGroupSize = find(sizes2.sizeTree, 0);
            let prependedGroupItemsCount = 0;
            let groupIndex = 0;
            while (prependedGroupItemsCount < unshiftWith2) {
              const theGroupIndex = sizes2.groupIndices[groupIndex];
              const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;
              initialRanges.push({
                startIndex: theGroupIndex,
                endIndex: theGroupIndex,
                size: firstGroupSize
              });
              initialRanges.push({
                startIndex: theGroupIndex + 1,
                endIndex: theGroupIndex + 1 + groupItemCount - 1,
                size: defaultSize
              });
              groupIndex++;
              prependedGroupItemsCount += groupItemCount + 1;
            }
            const sizeTreeKV = walk(sizes2.sizeTree);
            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;
            if (firstGroupIsExpanded) {
              sizeTreeKV.shift();
            }
            return sizeTreeKV.reduce(
              (acc, { k: index, v: size }) => {
                let ranges = acc.ranges;
                if (acc.prevSize !== 0) {
                  ranges = [
                    ...acc.ranges,
                    {
                      startIndex: acc.prevIndex,
                      endIndex: index + unshiftWith2 - 1,
                      size: acc.prevSize
                    }
                  ];
                }
                return {
                  ranges,
                  prevIndex: index + unshiftWith2,
                  prevSize: size
                };
              },
              {
                ranges: initialRanges,
                prevIndex: unshiftWith2,
                prevSize: 0
              }
            ).ranges;
          }
          return walk(sizes2.sizeTree).reduce(
            (acc, { k: index, v: size }) => {
              return {
                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index + unshiftWith2 - 1, size: acc.prevSize }],
                prevIndex: index + unshiftWith2,
                prevSize: size
              };
            },
            {
              ranges: [],
              prevIndex: 0,
              prevSize: defaultSize
            }
          ).ranges;
        })
      ),
      sizeRanges
    );
    const shiftWithOffset = streamFromEmitter(
      pipe(
        shiftWith,
        withLatestFrom(sizes, gap),
        map(([shiftWith2, { offsetTree }, gap2]) => {
          const newFirstItemIndex = -shiftWith2;
          return offsetOf(newFirstItemIndex, offsetTree, gap2);
        })
      )
    );
    connect(
      pipe(
        shiftWith,
        withLatestFrom(sizes, gap),
        map(([shiftWith2, sizes2, gap2]) => {
          const groupedMode = sizes2.groupIndices.length > 0;
          if (groupedMode) {
            if (empty(sizes2.sizeTree)) {
              return sizes2;
            }
            let newSizeTree = newTree();
            const prevGroupIndicesValue = getValue(prevGroupIndices);
            let removedItemsCount = 0;
            let groupIndex = 0;
            let groupOffset = 0;
            while (removedItemsCount < -shiftWith2) {
              groupOffset = prevGroupIndicesValue[groupIndex];
              const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;
              groupIndex++;
              removedItemsCount += groupItemCount + 1;
            }
            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {
              return insert(acc, Math.max(0, k + shiftWith2), v);
            }, newSizeTree);
            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;
            if (aGroupIsShrunk) {
              const firstGroupSize = find(sizes2.sizeTree, groupOffset);
              newSizeTree = insert(newSizeTree, 0, firstGroupSize);
              const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];
              newSizeTree = insert(newSizeTree, 1, nextItemSize);
            }
            return {
              ...sizes2,
              sizeTree: newSizeTree,
              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)
            };
          } else {
            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {
              return insert(acc, Math.max(0, k + shiftWith2), v);
            }, newTree());
            return {
              ...sizes2,
              sizeTree: newSizeTree,
              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)
            };
          }
        })
      ),
      sizes
    );
    return {
      // input
      data,
      totalCount,
      sizeRanges,
      groupIndices,
      defaultItemSize,
      fixedItemSize,
      unshiftWith,
      shiftWith,
      shiftWithOffset,
      beforeUnshiftWith,
      firstItemIndex,
      gap,
      // output
      sizes,
      listRefresh,
      statefulTotalCount,
      trackItemSizes,
      itemSize
    };
  },
  tup(loggerSystem, recalcSystem),
  { singleton: true }
);
const SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== "undefined" && "scrollBehavior" in document.documentElement.style;
function normalizeIndexLocation(location) {
  const result = typeof location === "number" ? { index: location } : location;
  if (!result.align) {
    result.align = "start";
  }
  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {
    result.behavior = "auto";
  }
  if (!result.offset) {
    result.offset = 0;
  }
  return result;
}
const scrollToIndexSystem = system(
  ([
    { sizes, totalCount, listRefresh, gap },
    {
      scrollingInProgress,
      viewportHeight,
      scrollTo,
      smoothScrollTargetReached,
      headerHeight,
      footerHeight,
      fixedHeaderHeight,
      fixedFooterHeight
    },
    { log }
  ]) => {
    const scrollToIndex = stream();
    const topListHeight = statefulStream(0);
    let unsubscribeNextListRefresh = null;
    let cleartTimeoutRef = null;
    let unsubscribeListRefresh = null;
    function cleanup() {
      if (unsubscribeNextListRefresh) {
        unsubscribeNextListRefresh();
        unsubscribeNextListRefresh = null;
      }
      if (unsubscribeListRefresh) {
        unsubscribeListRefresh();
        unsubscribeListRefresh = null;
      }
      if (cleartTimeoutRef) {
        clearTimeout(cleartTimeoutRef);
        cleartTimeoutRef = null;
      }
      publish(scrollingInProgress, false);
    }
    connect(
      pipe(
        scrollToIndex,
        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),
        withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight),
        map(
          ([
            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],
            gap2,
            fixedHeaderHeight2,
            fixedFooterHeight2
          ]) => {
            const normalLocation = normalizeIndexLocation(location);
            const { align, behavior, offset } = normalLocation;
            const lastIndex = totalCount2 - 1;
            const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);
            let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;
            if (align === "end") {
              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;
              if (index === lastIndex) {
                top += footerHeight2;
              }
            } else if (align === "center") {
              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;
            } else {
              top -= topListHeight2;
            }
            if (offset) {
              top += offset;
            }
            const retry = (listChanged) => {
              cleanup();
              if (listChanged) {
                log2("retrying to scroll to", { location }, LogLevel.DEBUG);
                publish(scrollToIndex, location);
              } else {
                log2("list did not change, scroll successful", {}, LogLevel.DEBUG);
              }
            };
            cleanup();
            if (behavior === "smooth") {
              let listChanged = false;
              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {
                listChanged = listChanged || changed;
              });
              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {
                retry(listChanged);
              });
            } else {
              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);
            }
            cleartTimeoutRef = setTimeout(() => {
              cleanup();
            }, 1200);
            publish(scrollingInProgress, true);
            log2("scrolling from index to", { index, top, behavior }, LogLevel.DEBUG);
            return { top, behavior };
          }
        )
      ),
      scrollTo
    );
    return {
      scrollToIndex,
      topListHeight
    };
  },
  tup(sizeSystem, domIOSystem, loggerSystem),
  { singleton: true }
);
function watchChangesFor(limit) {
  return (done) => {
    const timeoutRef = setTimeout(() => {
      done(false);
    }, limit);
    return (value) => {
      if (value) {
        done(true);
        clearTimeout(timeoutRef);
      }
    };
  };
}
const UP = "up";
const DOWN = "down";
const NONE$1 = "none";
const INITIAL_BOTTOM_STATE = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollTop: 0,
    viewportHeight: 0,
    scrollHeight: 0
  }
};
const DEFAULT_AT_TOP_THRESHOLD = 0;
const stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {
  const isAtBottom = statefulStream(false);
  const isAtTop = statefulStream(true);
  const atBottomStateChange = stream();
  const atTopStateChange = stream();
  const atBottomThreshold = statefulStream(4);
  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);
  const isScrolling = statefulStreamFromEmitter(
    pipe(
      merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),
      distinctUntilChanged()
    ),
    false
  );
  const isScrollingBy = statefulStreamFromEmitter(
    pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),
    false
  );
  connect(
    pipe(
      combineLatest(duc(scrollTop), duc(atTopThreshold)),
      map(([top, atTopThreshold2]) => top <= atTopThreshold2),
      distinctUntilChanged()
    ),
    isAtTop
  );
  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);
  const atBottomState = streamFromEmitter(
    pipe(
      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),
      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {
        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;
        const state = {
          viewportHeight: viewportHeight2,
          scrollTop: scrollTop2,
          scrollHeight
        };
        if (isAtBottom2) {
          let atBottomBecause;
          let scrollTopDelta;
          if (scrollTop2 > current.state.scrollTop) {
            atBottomBecause = "SCROLLED_DOWN";
            scrollTopDelta = current.state.scrollTop - scrollTop2;
          } else {
            atBottomBecause = "SIZE_DECREASED";
            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;
          }
          return {
            atBottom: true,
            state,
            atBottomBecause,
            scrollTopDelta
          };
        }
        let notAtBottomBecause;
        if (state.scrollHeight > current.state.scrollHeight) {
          notAtBottomBecause = "SIZE_INCREASED";
        } else if (viewportHeight2 < current.state.viewportHeight) {
          notAtBottomBecause = "VIEWPORT_HEIGHT_DECREASING";
        } else if (scrollTop2 < current.state.scrollTop) {
          notAtBottomBecause = "SCROLLING_UPWARDS";
        } else {
          notAtBottomBecause = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM";
        }
        return {
          atBottom: false,
          notAtBottomBecause,
          state
        };
      }, INITIAL_BOTTOM_STATE),
      distinctUntilChanged((prev, next) => {
        return prev && prev.atBottom === next.atBottom;
      })
    )
  );
  const lastJumpDueToItemResize = statefulStreamFromEmitter(
    pipe(
      scrollContainerState,
      scan(
        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {
          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {
            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;
            if (current.scrollTop !== scrollTop2 && atBottom) {
              return {
                scrollHeight,
                scrollTop: scrollTop2,
                jump: current.scrollTop - scrollTop2,
                changed: true
              };
            } else {
              return {
                scrollHeight,
                scrollTop: scrollTop2,
                jump: 0,
                changed: true
              };
            }
          } else {
            return {
              scrollTop: scrollTop2,
              scrollHeight,
              jump: 0,
              changed: false
            };
          }
        },
        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }
      ),
      filter((value) => value.changed),
      map((value) => value.jump)
    ),
    0
  );
  connect(
    pipe(
      atBottomState,
      map((state) => state.atBottom)
    ),
    isAtBottom
  );
  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);
  const scrollDirection = statefulStream(DOWN);
  connect(
    pipe(
      scrollContainerState,
      map(({ scrollTop: scrollTop2 }) => scrollTop2),
      distinctUntilChanged(),
      scan(
        (acc, scrollTop2) => {
          if (getValue(isScrollingBy)) {
            return { direction: acc.direction, prevScrollTop: scrollTop2 };
          }
          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };
        },
        { direction: DOWN, prevScrollTop: 0 }
      ),
      map((value) => value.direction)
    ),
    scrollDirection
  );
  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);
  const scrollVelocity = statefulStream(0);
  connect(
    pipe(
      isScrolling,
      filter((value) => !value),
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      mapTo(0)
    ),
    scrollVelocity
  );
  connect(
    pipe(
      scrollTop,
      throttleTime(100),
      withLatestFrom(isScrolling),
      filter(([_, isScrolling2]) => !!isScrolling2),
      scan(([_, prev], [next]) => [prev, next], [0, 0]),
      map(([prev, next]) => next - prev)
    ),
    scrollVelocity
  );
  return {
    isScrolling,
    isAtTop,
    isAtBottom,
    atBottomState,
    atTopStateChange,
    atBottomStateChange,
    scrollDirection,
    atBottomThreshold,
    atTopThreshold,
    scrollVelocity,
    lastJumpDueToItemResize
  };
}, tup(domIOSystem));
const propsReadySystem = system(
  ([{ log }]) => {
    const propsReady = statefulStream(false);
    const didMount = streamFromEmitter(
      pipe(
        propsReady,
        filter((ready) => ready),
        distinctUntilChanged()
      )
    );
    subscribe(propsReady, (value) => {
      value && getValue(log)("props updated", {}, LogLevel.DEBUG);
    });
    return { propsReady, didMount };
  },
  tup(loggerSystem),
  { singleton: true }
);
function skipFrames(frameCount, callback) {
  if (frameCount == 0) {
    callback();
  } else {
    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));
  }
}
function getInitialTopMostItemIndexNumber(location, totalCount) {
  const lastIndex = totalCount - 1;
  const index = typeof location === "number" ? location : location.index === "LAST" ? lastIndex : location.index;
  return index;
}
const initialTopMostItemIndexSystem = system(
  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex }, { didMount }]) => {
    const scrolledToInitialItem = statefulStream(true);
    const initialTopMostItemIndex = statefulStream(0);
    const scrollScheduled = statefulStream(false);
    connect(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter(([_, location]) => !!location),
        mapTo(false)
      ),
      scrolledToInitialItem
    );
    subscribe(
      pipe(
        combineLatest(listRefresh, didMount),
        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, scrollScheduled),
        filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled2]) => {
          return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled2;
        }),
        withLatestFrom(initialTopMostItemIndex)
      ),
      ([, initialTopMostItemIndex2]) => {
        publish(scrollScheduled, true);
        skipFrames(3, () => {
          handleNext(scrollTop, () => publish(scrolledToInitialItem, true));
          publish(scrollToIndex, initialTopMostItemIndex2);
        });
      }
    );
    return {
      scrolledToInitialItem,
      initialTopMostItemIndex
    };
  },
  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),
  { singleton: true }
);
function normalizeFollowOutput(follow) {
  if (!follow) {
    return false;
  }
  return follow === "smooth" ? "smooth" : "auto";
}
const behaviorFromFollowOutput = (follow, isAtBottom) => {
  if (typeof follow === "function") {
    return normalizeFollowOutput(follow(isAtBottom));
  }
  return isAtBottom && normalizeFollowOutput(follow);
};
const followOutputSystem = system(
  ([
    { totalCount, listRefresh },
    { isAtBottom, atBottomState },
    { scrollToIndex },
    { scrolledToInitialItem },
    { propsReady, didMount },
    { log },
    { scrollingInProgress }
  ]) => {
    const followOutput = statefulStream(false);
    const autoscrollToBottom = stream();
    let pendingScrollHandle = null;
    function scrollToBottom(followOutputBehavior) {
      publish(scrollToIndex, {
        index: "LAST",
        align: "end",
        behavior: followOutputBehavior
      });
    }
    subscribe(
      pipe(
        combineLatest(pipe(duc(totalCount), skip(1)), didMount),
        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),
        map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {
          let shouldFollow = didMount2 && scrolledToInitialItem2;
          let followOutputBehavior = "auto";
          if (shouldFollow) {
            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);
            shouldFollow = shouldFollow && !!followOutputBehavior;
          }
          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };
        }),
        filter(({ shouldFollow }) => shouldFollow)
      ),
      ({ totalCount: totalCount2, followOutputBehavior }) => {
        if (pendingScrollHandle) {
          pendingScrollHandle();
          pendingScrollHandle = null;
        }
        pendingScrollHandle = handleNext(listRefresh, () => {
          getValue(log)("following output to ", { totalCount: totalCount2 }, LogLevel.DEBUG);
          scrollToBottom(followOutputBehavior);
          pendingScrollHandle = null;
        });
      }
    );
    function trapNextSizeIncrease(followOutput2) {
      const cancel = handleNext(atBottomState, (state) => {
        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "SIZE_INCREASED" && !pendingScrollHandle) {
          getValue(log)("scrolling to bottom due to increased size", {}, LogLevel.DEBUG);
          scrollToBottom("auto");
        }
      });
      setTimeout(cancel, 100);
    }
    subscribe(
      pipe(
        combineLatest(duc(followOutput), totalCount, propsReady),
        filter(([follow, , ready]) => follow && ready),
        scan(
          ({ value }, [, next]) => {
            return { refreshed: value === next, value: next };
          },
          { refreshed: false, value: 0 }
        ),
        filter(({ refreshed }) => refreshed),
        withLatestFrom(followOutput, totalCount)
      ),
      ([, followOutput2]) => {
        trapNextSizeIncrease(followOutput2 !== false);
      }
    );
    subscribe(autoscrollToBottom, () => {
      trapNextSizeIncrease(getValue(followOutput) !== false);
    });
    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {
      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING") {
        scrollToBottom("auto");
      }
    });
    return { followOutput, autoscrollToBottom };
  },
  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)
);
function groupCountsToIndicesAndCount(counts) {
  return counts.reduce(
    (acc, groupCount) => {
      acc.groupIndices.push(acc.totalCount);
      acc.totalCount += groupCount + 1;
      return acc;
    },
    {
      totalCount: 0,
      groupIndices: []
    }
  );
}
const groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {
  const groupCounts = stream();
  const topItemsIndexes = stream();
  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));
  connect(
    pipe(
      groupIndicesAndCount,
      map((value) => value.totalCount)
    ),
    totalCount
  );
  connect(
    pipe(
      groupIndicesAndCount,
      map((value) => value.groupIndices)
    ),
    groupIndices
  );
  connect(
    pipe(
      combineLatest(scrollTop, sizes, headerHeight),
      filter(([_, sizes2]) => hasGroups(sizes2)),
      map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), "v")[0]),
      distinctUntilChanged(),
      map((index) => [index])
    ),
    topItemsIndexes
  );
  return { groupCounts, topItemsIndexes };
}, tup(sizeSystem, domIOSystem));
function tupleComparator(prev, current) {
  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);
}
function rangeComparator(prev, next) {
  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);
}
const TOP = "top";
const BOTTOM = "bottom";
const NONE = "none";
function getOverscan(overscan, end, direction) {
  if (typeof overscan === "number") {
    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;
  } else {
    if (direction === UP) {
      return end === TOP ? overscan.main : overscan.reverse;
    } else {
      return end === BOTTOM ? overscan.main : overscan.reverse;
    }
  }
}
function getViewportIncrease(value, end) {
  return typeof value === "number" ? value : value[end] || 0;
}
const sizeRangeSystem = system(
  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {
    const listBoundary = stream();
    const topListHeight = statefulStream(0);
    const increaseViewportBy = statefulStream(0);
    const overscan = statefulStream(0);
    const visibleRange = statefulStreamFromEmitter(
      pipe(
        combineLatest(
          duc(scrollTop),
          duc(viewportHeight),
          duc(headerHeight),
          duc(listBoundary, tupleComparator),
          duc(overscan),
          duc(topListHeight),
          duc(fixedHeaderHeight),
          duc(deviation),
          duc(increaseViewportBy)
        ),
        map(
          ([
            scrollTop2,
            viewportHeight2,
            headerHeight2,
            [listTop, listBottom],
            overscan2,
            topListHeight2,
            fixedHeaderHeight2,
            deviation2,
            increaseViewportBy2
          ]) => {
            const top = scrollTop2 - deviation2;
            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;
            const headerVisible = Math.max(headerHeight2 - top, 0);
            let direction = NONE;
            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);
            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);
            listTop -= deviation2;
            listTop += headerHeight2 + fixedHeaderHeight2;
            listBottom += headerHeight2 + fixedHeaderHeight2;
            listBottom -= deviation2;
            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {
              direction = UP;
            }
            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {
              direction = DOWN;
            }
            if (direction !== NONE) {
              return [
                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),
                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition
              ];
            }
            return null;
          }
        ),
        filter((value) => value != null),
        distinctUntilChanged(tupleComparator)
      ),
      [0, 0]
    );
    return {
      // input
      listBoundary,
      overscan,
      topListHeight,
      increaseViewportBy,
      // output
      visibleRange
    };
  },
  tup(domIOSystem),
  { singleton: true }
);
function probeItemSet(index, sizes, data) {
  if (hasGroups(sizes)) {
    const itemIndex = originalIndexFromItemIndex(index, sizes);
    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];
    return [
      { index: groupIndex, size: 0, offset: 0 },
      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }
    ];
  }
  return [{ index, size: 0, offset: 0, data: data && data[0] }];
}
const EMPTY_LIST_STATE = {
  items: [],
  topItems: [],
  offsetTop: 0,
  offsetBottom: 0,
  top: 0,
  bottom: 0,
  topListHeight: 0,
  totalCount: 0,
  firstItemIndex: 0
};
function transposeItems(items, sizes, firstItemIndex) {
  if (items.length === 0) {
    return [];
  }
  if (!hasGroups(sizes)) {
    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));
  }
  const startIndex = items[0].index;
  const endIndex = items[items.length - 1].index;
  const transposedItems = [];
  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);
  let currentRange = void 0;
  let currentGroupIndex = 0;
  for (const item of items) {
    if (!currentRange || currentRange.end < item.index) {
      currentRange = groupRanges.shift();
      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);
    }
    let transposedItem;
    if (item.index === currentRange.start) {
      transposedItem = {
        type: "group",
        index: currentGroupIndex
      };
    } else {
      transposedItem = {
        index: item.index - (currentGroupIndex + 1) + firstItemIndex,
        groupIndex: currentGroupIndex
      };
    }
    transposedItems.push({
      ...transposedItem,
      size: item.size,
      offset: item.offset,
      originalIndex: item.index,
      data: item.data
    });
  }
  return transposedItems;
}
function buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {
  const { lastSize, lastOffset, lastIndex } = sizes;
  let offsetTop = 0;
  let bottom = 0;
  if (items.length > 0) {
    offsetTop = items[0].offset;
    const lastItem = items[items.length - 1];
    bottom = lastItem.offset + lastItem.size;
  }
  const itemCount = totalCount - lastIndex;
  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;
  const top = offsetTop;
  const offsetBottom = total - bottom;
  return {
    items: transposeItems(items, sizes, firstItemIndex),
    topItems: transposeItems(topItems, sizes, firstItemIndex),
    topListHeight: topItems.reduce((height, item) => item.size + height, 0),
    offsetTop,
    offsetBottom,
    top,
    bottom,
    totalCount,
    firstItemIndex
  };
}
function buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap, data) {
  let includedGroupsCount = 0;
  if (sizes.groupIndices.length > 0) {
    for (const index of sizes.groupIndices) {
      if (index - includedGroupsCount >= itemCount) {
        break;
      }
      includedGroupsCount++;
    }
  }
  const adjustedCount = itemCount + includedGroupsCount;
  const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);
  const items = Array.from({ length: adjustedCount }).map((_, index) => ({
    index: index + initialTopMostItemIndexNumber,
    size: 0,
    offset: 0,
    data: data[index + initialTopMostItemIndexNumber]
  }));
  return buildListState(items, [], adjustedCount, gap, sizes, firstItemIndex);
}
const listStateSystem = system(
  ([
    { sizes, totalCount, data, firstItemIndex, gap },
    groupedListSystem2,
    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },
    { scrolledToInitialItem, initialTopMostItemIndex },
    { topListHeight },
    stateFlags,
    { didMount },
    { recalcInProgress }
  ]) => {
    const topItemsIndexes = statefulStream([]);
    const initialItemCount = statefulStream(0);
    const itemsRendered = stream();
    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);
    const listState = statefulStreamFromEmitter(
      pipe(
        combineLatest(
          didMount,
          recalcInProgress,
          duc(visibleRange, tupleComparator),
          duc(totalCount),
          duc(sizes),
          duc(initialTopMostItemIndex),
          scrolledToInitialItem,
          duc(topItemsIndexes),
          duc(firstItemIndex),
          duc(gap),
          data
        ),
        filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {
          const dataChangeInProgress = data2 && data2.length !== totalCount2;
          return mount && !recalcInProgress2 && !dataChangeInProgress;
        }),
        map(
          ([
            ,
            ,
            [startOffset, endOffset],
            totalCount2,
            sizes2,
            initialTopMostItemIndex2,
            scrolledToInitialItem2,
            topItemsIndexes2,
            firstItemIndex2,
            gap2,
            data2
          ]) => {
            const sizesValue = sizes2;
            const { sizeTree, offsetTree } = sizesValue;
            const initialItemCountValue = getValue(initialItemCount);
            if (totalCount2 === 0) {
              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };
            }
            if (startOffset === 0 && endOffset === 0) {
              if (initialItemCountValue === 0) {
                return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };
              } else {
                return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap2, data2 || []);
              }
            }
            if (empty(sizeTree)) {
              if (initialItemCountValue > 0) {
                return null;
              }
              const state = buildListState(
                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),
                [],
                totalCount2,
                gap2,
                sizesValue,
                firstItemIndex2
              );
              return state;
            }
            const topItems = [];
            if (topItemsIndexes2.length > 0) {
              const startIndex = topItemsIndexes2[0];
              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];
              let offset = 0;
              for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {
                const size = range.value;
                const rangeStartIndex = Math.max(range.start, startIndex);
                const rangeEndIndex = Math.min(range.end, endIndex);
                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {
                  topItems.push({ index: i, size, offset, data: data2 && data2[i] });
                  offset += size;
                }
              }
            }
            if (!scrolledToInitialItem2) {
              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);
            }
            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;
            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);
            if (offsetPointRanges.length === 0) {
              return null;
            }
            const maxIndex = totalCount2 - 1;
            const items = tap([], (result) => {
              for (const range of offsetPointRanges) {
                const point = range.value;
                let offset = point.offset;
                let rangeStartIndex = range.start;
                const size = point.size;
                if (point.offset < startOffset) {
                  rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));
                  const itemCount = rangeStartIndex - range.start;
                  offset += itemCount * size + itemCount * gap2;
                }
                if (rangeStartIndex < minStartIndex) {
                  offset += (minStartIndex - rangeStartIndex) * size;
                  rangeStartIndex = minStartIndex;
                }
                const endIndex = Math.min(range.end, maxIndex);
                for (let i = rangeStartIndex; i <= endIndex; i++) {
                  if (offset >= endOffset) {
                    break;
                  }
                  result.push({ index: i, size, offset, data: data2 && data2[i] });
                  offset += size + gap2;
                }
              }
            });
            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        filter((value) => value !== null),
        distinctUntilChanged()
      ),
      EMPTY_LIST_STATE
    );
    connect(
      pipe(
        data,
        filter(isDefined),
        map((data2) => data2 == null ? void 0 : data2.length)
      ),
      totalCount
    );
    connect(
      pipe(
        listState,
        map((value) => value.topListHeight)
      ),
      topListHeight
    );
    connect(topListHeight, rangeTopListHeight);
    connect(
      pipe(
        listState,
        map((state) => [state.top, state.bottom])
      ),
      listBoundary
    );
    connect(
      pipe(
        listState,
        map((state) => state.items)
      ),
      itemsRendered
    );
    const endReached = streamFromEmitter(
      pipe(
        listState,
        filter(({ items }) => items.length > 0),
        withLatestFrom(totalCount, data),
        filter(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),
        map(([, totalCount2, data2]) => [totalCount2 - 1, data2]),
        distinctUntilChanged(tupleComparator),
        map(([count]) => count)
      )
    );
    const startReached = streamFromEmitter(
      pipe(
        listState,
        throttleTime(200),
        filter(({ items, topItems }) => {
          return items.length > 0 && items[0].originalIndex === topItems.length;
        }),
        map(({ items }) => items[0].index),
        distinctUntilChanged()
      )
    );
    const rangeChanged = streamFromEmitter(
      pipe(
        listState,
        filter(({ items }) => items.length > 0),
        map(({ items }) => {
          let startIndex = 0;
          let endIndex = items.length - 1;
          while (items[startIndex].type === "group" && startIndex < endIndex) {
            startIndex++;
          }
          while (items[endIndex].type === "group" && endIndex > startIndex) {
            endIndex--;
          }
          return {
            startIndex: items[startIndex].index,
            endIndex: items[endIndex].index
          };
        }),
        distinctUntilChanged(rangeComparator)
      )
    );
    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, initialItemCount, ...stateFlags };
  },
  tup(
    sizeSystem,
    groupedListSystem,
    sizeRangeSystem,
    initialTopMostItemIndexSystem,
    scrollToIndexSystem,
    stateFlagsSystem,
    propsReadySystem,
    recalcSystem
  ),
  { singleton: true }
);
const initialItemCountSystem = system(
  ([{ sizes, firstItemIndex, data, gap }, { initialTopMostItemIndex }, { initialItemCount, listState }, { didMount }]) => {
    connect(
      pipe(
        didMount,
        withLatestFrom(initialItemCount),
        filter(([, count]) => count !== 0),
        withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap, data),
        map(([[, count], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2 = []]) => {
          return buildListStateFromItemCount(count, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2);
        })
      ),
      listState
    );
    return {};
  },
  tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem),
  { singleton: true }
);
const scrollSeekSystem = system(
  ([{ scrollVelocity }]) => {
    const isSeeking = statefulStream(false);
    const rangeChanged = stream();
    const scrollSeekConfiguration = statefulStream(false);
    connect(
      pipe(
        scrollVelocity,
        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),
        filter(([_, config]) => !!config),
        map(([speed, config, isSeeking2, range]) => {
          const { exit, enter } = config;
          if (isSeeking2) {
            if (exit(speed, range)) {
              return false;
            }
          } else {
            if (enter(speed, range)) {
              return true;
            }
          }
          return isSeeking2;
        }),
        distinctUntilChanged()
      ),
      isSeeking
    );
    subscribe(
      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),
      ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range)
    );
    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };
  },
  tup(stateFlagsSystem),
  { singleton: true }
);
const topItemCountSystem = system(([{ topItemsIndexes }]) => {
  const topItemCount = statefulStream(0);
  connect(
    pipe(
      topItemCount,
      filter((length) => length > 0),
      map((length) => Array.from({ length }).map((_, index) => index))
    ),
    topItemsIndexes
  );
  return { topItemCount };
}, tup(listStateSystem));
const totalListHeightSystem = system(
  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {
    const totalListHeightChanged = stream();
    const totalListHeight = statefulStreamFromEmitter(
      pipe(
        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),
        map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {
          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;
        })
      ),
      0
    );
    connect(duc(totalListHeight), totalListHeightChanged);
    return { totalListHeight, totalListHeightChanged };
  },
  tup(domIOSystem, listStateSystem),
  { singleton: true }
);
function simpleMemoize(func) {
  let called = false;
  let result;
  return () => {
    if (!called) {
      called = true;
      result = func();
    }
    return result;
  };
}
const isMobileSafari = simpleMemoize(() => {
  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);
});
const upwardScrollFixSystem = system(
  ([
    { scrollBy, scrollTop, deviation, scrollingInProgress },
    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },
    { listState },
    { beforeUnshiftWith, shiftWithOffset, sizes, gap },
    { log },
    { recalcInProgress }
  ]) => {
    const deviationOffset = streamFromEmitter(
      pipe(
        listState,
        withLatestFrom(lastJumpDueToItemResize),
        scan(
          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2]) => {
            const totalHeight = bottom + offsetBottom;
            let newDev = 0;
            if (prevTotalCount === totalCount) {
              if (prevItems.length > 0 && items.length > 0) {
                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;
                if (!atStart) {
                  newDev = totalHeight - prevTotalHeight;
                  if (newDev !== 0) {
                    newDev += lastJumpDueToItemResize2;
                  }
                }
              }
            }
            return [newDev, items, totalCount, totalHeight];
          },
          [0, [], 0, 0]
        ),
        filter(([amount]) => amount !== 0),
        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress),
        filter(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2]) => {
          return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;
        }),
        map(([[amount], , , , , log2]) => {
          log2("Upward scrolling compensation", { amount }, LogLevel.DEBUG);
          return amount;
        })
      )
    );
    function scrollByWith(offset) {
      if (offset > 0) {
        publish(scrollBy, { top: -offset, behavior: "auto" });
        publish(deviation, 0);
      } else {
        publish(deviation, 0);
        publish(scrollBy, { top: -offset, behavior: "auto" });
      }
    }
    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {
      if (isScrolling2 && isMobileSafari()) {
        publish(deviation, deviationAmount - offset);
      } else {
        scrollByWith(-offset);
      }
    });
    subscribe(
      pipe(
        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),
        filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0),
        map(([_, deviation2]) => deviation2),
        throttleTime(1)
      ),
      scrollByWith
    );
    connect(
      pipe(
        shiftWithOffset,
        map((offset) => {
          return { top: -offset };
        })
      ),
      scrollBy
    );
    subscribe(
      pipe(
        beforeUnshiftWith,
        withLatestFrom(sizes, gap),
        map(([offset, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap2]) => {
          function getItemOffset(itemCount) {
            return itemCount * (defaultItemSize + gap2);
          }
          if (groupIndices.length === 0) {
            return getItemOffset(offset);
          } else {
            let amount = 0;
            const defaultGroupSize = find(sizeTree, 0);
            let recognizedOffsetItems = 0;
            let groupIndex = 0;
            while (recognizedOffsetItems < offset) {
              recognizedOffsetItems++;
              amount += defaultGroupSize;
              let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;
              if (recognizedOffsetItems + groupItemCount > offset) {
                amount -= defaultGroupSize;
                groupItemCount = offset - recognizedOffsetItems + 1;
              }
              recognizedOffsetItems += groupItemCount;
              amount += getItemOffset(groupItemCount);
              groupIndex++;
            }
            return amount;
          }
        })
      ),
      (offset) => {
        publish(deviation, offset);
        requestAnimationFrame(() => {
          publish(scrollBy, { top: offset });
          requestAnimationFrame(() => {
            publish(deviation, 0);
            publish(recalcInProgress, false);
          });
        });
      }
    );
    return { deviation };
  },
  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)
);
const initialScrollTopSystem = system(
  ([{ didMount }, { scrollTo }, { listState }]) => {
    const initialScrollTop = statefulStream(0);
    subscribe(
      pipe(
        didMount,
        withLatestFrom(initialScrollTop),
        filter(([, offset]) => offset !== 0),
        map(([, offset]) => ({ top: offset }))
      ),
      (location) => {
        handleNext(
          pipe(
            listState,
            skip(1),
            filter((state) => state.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              publish(scrollTo, location);
            });
          }
        );
      }
    );
    return {
      initialScrollTop
    };
  },
  tup(propsReadySystem, domIOSystem, listStateSystem),
  { singleton: true }
);
const alignToBottomSystem = system(
  ([{ viewportHeight }, { totalListHeight }]) => {
    const alignToBottom = statefulStream(false);
    const paddingTopAddition = statefulStreamFromEmitter(
      pipe(
        combineLatest(alignToBottom, viewportHeight, totalListHeight),
        filter(([enabled]) => enabled),
        map(([, viewportHeight2, totalListHeight2]) => {
          return Math.max(0, viewportHeight2 - totalListHeight2);
        }),
        throttleTime(0),
        distinctUntilChanged()
      ),
      0
    );
    return { alignToBottom, paddingTopAddition };
  },
  tup(domIOSystem, totalListHeightSystem),
  { singleton: true }
);
const windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {
  const windowScrollContainerState = stream();
  const windowViewportRect = stream();
  const windowScrollTo = stream();
  const useWindowScroll = statefulStream(false);
  const customScrollParent = statefulStream(void 0);
  connect(
    pipe(
      combineLatest(windowScrollContainerState, windowViewportRect),
      map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {
        return {
          scrollTop: Math.max(0, windowScrollTop - offsetTop),
          scrollHeight,
          viewportHeight
        };
      })
    ),
    scrollContainerState
  );
  connect(
    pipe(
      scrollTo,
      withLatestFrom(windowViewportRect),
      map(([scrollTo2, { offsetTop }]) => {
        return {
          ...scrollTo2,
          top: scrollTo2.top + offsetTop
        };
      })
    ),
    windowScrollTo
  );
  return {
    // config
    useWindowScroll,
    customScrollParent,
    // input
    windowScrollContainerState,
    windowViewportRect,
    // signals
    windowScrollTo
  };
}, tup(domIOSystem));
const defaultCalculateViewLocation = ({
  itemTop: itemTop2,
  itemBottom,
  viewportTop,
  viewportBottom,
  locationParams: { behavior, align, ...rest }
}) => {
  if (itemTop2 < viewportTop) {
    return { ...rest, behavior, align: align != null ? align : "start" };
  }
  if (itemBottom > viewportBottom) {
    return { ...rest, behavior, align: align != null ? align : "end" };
  }
  return null;
};
const scrollIntoViewSystem = system(
  ([
    { sizes, totalCount, gap },
    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },
    { scrollToIndex }
  ]) => {
    const scrollIntoView = stream();
    connect(
      pipe(
        scrollIntoView,
        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),
        withLatestFrom(gap),
        map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {
          const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest } = viewLocation;
          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);
          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;
          const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];
          const viewportTop = scrollTop2 + fixedHeaderHeight2;
          const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;
          const location = calculateViewLocation({
            itemTop: itemTop2,
            itemBottom,
            viewportTop,
            viewportBottom,
            locationParams: { behavior, align, ...rest }
          });
          if (location) {
            done && handleNext(
              pipe(
                scrollingInProgress,
                filter((value) => value === false),
                // skips the initial publish of false, and the cleanup call.
                // but if scrollingInProgress is true, we skip the initial publish.
                skip(getValue(scrollingInProgress) ? 1 : 2)
              ),
              done
            );
          } else {
            done && done();
          }
          return location;
        }),
        filter((value) => value !== null)
      ),
      scrollToIndex
    );
    return {
      scrollIntoView
    };
  },
  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),
  { singleton: true }
);
const stateLoadSystem = system(
  ([
    { sizes, sizeRanges },
    { scrollTop },
    { initialTopMostItemIndex },
    { didMount },
    { useWindowScroll, windowScrollContainerState, windowViewportRect }
  ]) => {
    const getState = stream();
    const restoreStateFrom = statefulStream(void 0);
    const statefulWindowScrollContainerState = statefulStream(null);
    const statefulWindowViewportRect = statefulStream(null);
    connect(windowScrollContainerState, statefulWindowScrollContainerState);
    connect(windowViewportRect, statefulWindowViewportRect);
    subscribe(
      pipe(getState, withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect)),
      ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2]) => {
        const ranges = sizeTreeToRanges(sizes2.sizeTree);
        if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {
          scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;
        }
        callback({ ranges, scrollTop: scrollTop2 });
      }
    );
    connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);
    connect(
      pipe(
        didMount,
        withLatestFrom(restoreStateFrom),
        filter(([, state]) => state !== void 0),
        distinctUntilChanged(),
        map(([, snapshot]) => {
          return snapshot.ranges;
        })
      ),
      sizeRanges
    );
    return {
      getState,
      restoreStateFrom
    };
  },
  tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem)
);
function locationFromSnapshot(snapshot) {
  return { offset: snapshot.scrollTop, index: 0, align: "start" };
}
const featureGroup1System = system(
  ([
    sizeRange,
    initialItemCount,
    propsReady,
    scrollSeek,
    totalListHeight,
    initialScrollTopSystem2,
    alignToBottom,
    windowScroller,
    scrollIntoView,
    logger
  ]) => {
    return {
      ...sizeRange,
      ...initialItemCount,
      ...propsReady,
      ...scrollSeek,
      ...totalListHeight,
      ...initialScrollTopSystem2,
      ...alignToBottom,
      ...windowScroller,
      ...scrollIntoView,
      ...logger
    };
  },
  tup(
    sizeRangeSystem,
    initialItemCountSystem,
    propsReadySystem,
    scrollSeekSystem,
    totalListHeightSystem,
    initialScrollTopSystem,
    alignToBottomSystem,
    windowScrollerSystem,
    scrollIntoViewSystem,
    loggerSystem
  )
);
const listSystem = system(
  ([
    {
      totalCount,
      sizeRanges,
      fixedItemSize,
      defaultItemSize,
      trackItemSizes,
      itemSize,
      data,
      firstItemIndex,
      groupIndices,
      statefulTotalCount,
      gap,
      sizes
    },
    { initialTopMostItemIndex, scrolledToInitialItem },
    domIO,
    stateLoad,
    followOutput,
    { listState, topItemsIndexes, ...flags },
    { scrollToIndex },
    _,
    { topItemCount },
    { groupCounts },
    featureGroup1
  ]) => {
    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);
    connect(
      pipe(
        featureGroup1.windowViewportRect,
        map((value) => value.visibleHeight)
      ),
      domIO.viewportHeight
    );
    return {
      // input
      totalCount,
      data,
      firstItemIndex,
      sizeRanges,
      initialTopMostItemIndex,
      scrolledToInitialItem,
      topItemsIndexes,
      topItemCount,
      groupCounts,
      fixedItemHeight: fixedItemSize,
      defaultItemHeight: defaultItemSize,
      gap,
      ...followOutput,
      // output
      statefulTotalCount,
      listState,
      scrollToIndex,
      trackItemSizes,
      itemSize,
      groupIndices,
      // exported from stateFlagsSystem
      ...flags,
      // the bag of IO from featureGroup1System
      ...featureGroup1,
      ...domIO,
      sizes,
      ...stateLoad
    };
  },
  tup(
    sizeSystem,
    initialTopMostItemIndexSystem,
    domIOSystem,
    stateLoadSystem,
    followOutputSystem,
    listStateSystem,
    scrollToIndexSystem,
    upwardScrollFixSystem,
    topItemCountSystem,
    groupedListSystem,
    featureGroup1System
  )
);
const WEBKIT_STICKY = "-webkit-sticky";
const STICKY = "sticky";
const positionStickyCssValue = simpleMemoize(() => {
  if (typeof document === "undefined") {
    return STICKY;
  }
  const node = document.createElement("div");
  node.style.position = WEBKIT_STICKY;
  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;
});
function useWindowViewportRectRef(callback, customScrollParent) {
  const viewportInfo = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const calculateInfo = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(
    (element) => {
      if (element === null || !element.offsetParent) {
        return;
      }
      const rect = element.getBoundingClientRect();
      const visibleWidth = rect.width;
      let visibleHeight, offsetTop;
      if (customScrollParent) {
        const customScrollParentRect = customScrollParent.getBoundingClientRect();
        const deltaTop = rect.top - customScrollParentRect.top;
        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);
        offsetTop = deltaTop + customScrollParent.scrollTop;
      } else {
        visibleHeight = window.innerHeight - Math.max(0, rect.top);
        offsetTop = rect.top + window.pageYOffset;
      }
      viewportInfo.current = {
        offsetTop,
        visibleHeight,
        visibleWidth
      };
      callback(viewportInfo.current);
    },
    [callback, customScrollParent]
  );
  const { callbackRef, ref } = useSizeWithElRef(calculateInfo);
  const scrollAndResizeEventHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    calculateInfo(ref.current);
  }, [calculateInfo, ref]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (customScrollParent) {
      customScrollParent.addEventListener("scroll", scrollAndResizeEventHandler);
      const observer = new ResizeObserver(scrollAndResizeEventHandler);
      observer.observe(customScrollParent);
      return () => {
        customScrollParent.removeEventListener("scroll", scrollAndResizeEventHandler);
        observer.unobserve(customScrollParent);
      };
    } else {
      window.addEventListener("scroll", scrollAndResizeEventHandler);
      window.addEventListener("resize", scrollAndResizeEventHandler);
      return () => {
        window.removeEventListener("scroll", scrollAndResizeEventHandler);
        window.removeEventListener("resize", scrollAndResizeEventHandler);
      };
    }
  }, [scrollAndResizeEventHandler, customScrollParent]);
  return callbackRef;
}
const VirtuosoMockContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);
const VirtuosoGridMockContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);
function identity(value) {
  return value;
}
const listComponentPropsSystem = /* @__PURE__ */ system(() => {
  const itemContent = statefulStream((index) => `Item ${index}`);
  const context = statefulStream(null);
  const groupContent = statefulStream((index) => `Group ${index}`);
  const components = statefulStream({});
  const computeItemKey = statefulStream(identity);
  const headerFooterTag = statefulStream("div");
  const scrollerRef = statefulStream(noop);
  const distinctProp = (propName, defaultValue = null) => {
    return statefulStreamFromEmitter(
      pipe(
        components,
        map((components2) => components2[propName]),
        distinctUntilChanged()
      ),
      defaultValue
    );
  };
  return {
    context,
    itemContent,
    groupContent,
    components,
    computeItemKey,
    headerFooterTag,
    scrollerRef,
    FooterComponent: distinctProp("Footer"),
    HeaderComponent: distinctProp("Header"),
    TopItemListComponent: distinctProp("TopItemList"),
    ListComponent: distinctProp("List", "div"),
    ItemComponent: distinctProp("Item", "div"),
    GroupComponent: distinctProp("Group", "div"),
    ScrollerComponent: distinctProp("Scroller", "div"),
    EmptyPlaceholder: distinctProp("EmptyPlaceholder"),
    ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder")
  };
});
const combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {
  return { ...listSystem2, ...propsSystem };
}, tup(listSystem, listComponentPropsSystem));
const DefaultScrollSeekPlaceholder$1 = ({ height }) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { style: { height } });
const GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1, overflowAnchor: "none" };
const ITEM_STYLE$1 = { overflowAnchor: "none" };
const Items$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoItems({ showTopList = false }) {
  const listState = useEmitterValue$2("listState");
  const sizeRanges = usePublisher$2("sizeRanges");
  const useWindowScroll = useEmitterValue$2("useWindowScroll");
  const customScrollParent = useEmitterValue$2("customScrollParent");
  const windowScrollContainerStateCallback = usePublisher$2("windowScrollContainerState");
  const _scrollContainerStateCallback = usePublisher$2("scrollContainerState");
  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;
  const itemContent = useEmitterValue$2("itemContent");
  const context = useEmitterValue$2("context");
  const groupContent = useEmitterValue$2("groupContent");
  const trackItemSizes = useEmitterValue$2("trackItemSizes");
  const itemSize = useEmitterValue$2("itemSize");
  const log = useEmitterValue$2("log");
  const listGap = usePublisher$2("gap");
  const { callbackRef } = useChangedListContentsSizes(
    sizeRanges,
    itemSize,
    trackItemSizes,
    showTopList ? noop : scrollContainerStateCallback,
    log,
    listGap,
    customScrollParent
  );
  const [deviation, setDeviation] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  useEmitter$2("deviation", (value) => {
    if (deviation !== value) {
      setDeviation(value);
    }
  });
  const EmptyPlaceholder = useEmitterValue$2("EmptyPlaceholder");
  const ScrollSeekPlaceholder = useEmitterValue$2("ScrollSeekPlaceholder") || DefaultScrollSeekPlaceholder$1;
  const ListComponent = useEmitterValue$2("ListComponent");
  const ItemComponent = useEmitterValue$2("ItemComponent");
  const GroupComponent = useEmitterValue$2("GroupComponent");
  const computeItemKey = useEmitterValue$2("computeItemKey");
  const isSeeking = useEmitterValue$2("isSeeking");
  const hasGroups2 = useEmitterValue$2("groupIndices").length > 0;
  const paddingTopAddition = useEmitterValue$2("paddingTopAddition");
  const scrolledToInitialItem = useEmitterValue$2("scrolledToInitialItem");
  const containerStyle = showTopList ? {} : {
    boxSizing: "border-box",
    paddingTop: listState.offsetTop + paddingTopAddition,
    paddingBottom: listState.offsetBottom,
    marginTop: deviation,
    ...scrolledToInitialItem ? {} : { visibility: "hidden" }
  };
  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));
  }
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    ListComponent,
    {
      ...contextPropIfNotDomElement(ListComponent, context),
      ref: callbackRef,
      style: containerStyle,
      "data-test-id": showTopList ? "virtuoso-top-item-list" : "virtuoso-item-list"
    },
    (showTopList ? listState.topItems : listState.items).map((item) => {
      const index = item.originalIndex;
      const key = computeItemKey(index + listState.firstItemIndex, item.data, context);
      if (isSeeking) {
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollSeekPlaceholder, {
          ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),
          key,
          index: item.index,
          height: item.size,
          type: item.type || "item",
          ...item.type === "group" ? {} : { groupIndex: item.groupIndex }
        });
      }
      if (item.type === "group") {
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
          GroupComponent,
          {
            ...contextPropIfNotDomElement(GroupComponent, context),
            key,
            "data-index": index,
            "data-known-size": item.size,
            "data-item-index": item.index,
            style: GROUP_STYLE
          },
          groupContent(item.index, context)
        );
      } else {
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
          ItemComponent,
          {
            ...contextPropIfNotDomElement(ItemComponent, context),
            ...itemPropIfNotDomElement(ItemComponent, item.data),
            key,
            "data-index": index,
            "data-known-size": item.size,
            "data-item-index": item.index,
            "data-item-group-index": item.groupIndex,
            style: ITEM_STYLE$1
          },
          hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context)
        );
      }
    })
  );
});
const scrollerStyle = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
};
const viewportStyle = {
  width: "100%",
  height: "100%",
  position: "absolute",
  top: 0
};
const topItemListStyle = {
  width: "100%",
  position: positionStickyCssValue(),
  top: 0,
  zIndex: 1
};
function contextPropIfNotDomElement(element, context) {
  if (typeof element === "string") {
    return void 0;
  }
  return { context };
}
function itemPropIfNotDomElement(element, item) {
  return { item: typeof element === "string" ? void 0 : item };
}
const Header$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoHeader() {
  const Header2 = useEmitterValue$2("HeaderComponent");
  const headerHeight = usePublisher$2("headerHeight");
  const headerFooterTag = useEmitterValue$2("headerFooterTag");
  const ref = useSize((el) => headerHeight(correctItemSize(el, "height")));
  const context = useEmitterValue$2("context");
  return Header2 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, { ref }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;
});
const Footer$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoFooter() {
  const Footer2 = useEmitterValue$2("FooterComponent");
  const footerHeight = usePublisher$2("footerHeight");
  const headerFooterTag = useEmitterValue$2("headerFooterTag");
  const ref = useSize((el) => footerHeight(correctItemSize(el, "height")));
  const context = useEmitterValue$2("context");
  return Footer2 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, { ref }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;
});
function buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {
  const Scroller2 = react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoScroller({ style, children, ...props }) {
    const scrollContainerStateCallback = usePublisher2("scrollContainerState");
    const ScrollerComponent = useEmitterValue2("ScrollerComponent");
    const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
    const scrollerRefCallback = useEmitterValue2("scrollerRef");
    const context = useEmitterValue2("context");
    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(
      scrollContainerStateCallback,
      smoothScrollTargetReached,
      ScrollerComponent,
      scrollerRefCallback
    );
    useEmitter2("scrollTo", scrollToCallback);
    useEmitter2("scrollBy", scrollByCallback);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      ScrollerComponent,
      {
        ref: scrollerRef,
        style: { ...scrollerStyle, ...style },
        "data-test-id": "virtuoso-scroller",
        "data-virtuoso-scroller": true,
        tabIndex: 0,
        ...props,
        ...contextPropIfNotDomElement(ScrollerComponent, context)
      },
      children
    );
  });
  return Scroller2;
}
function buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {
  const Scroller2 = react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoWindowScroller({ style, children, ...props }) {
    const scrollContainerStateCallback = usePublisher2("windowScrollContainerState");
    const ScrollerComponent = useEmitterValue2("ScrollerComponent");
    const smoothScrollTargetReached = usePublisher2("smoothScrollTargetReached");
    const totalListHeight = useEmitterValue2("totalListHeight");
    const deviation = useEmitterValue2("deviation");
    const customScrollParent = useEmitterValue2("customScrollParent");
    const context = useEmitterValue2("context");
    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(
      scrollContainerStateCallback,
      smoothScrollTargetReached,
      ScrollerComponent,
      noop,
      customScrollParent
    );
    useIsomorphicLayoutEffect$1(() => {
      scrollerRef.current = customScrollParent ? customScrollParent : window;
      return () => {
        scrollerRef.current = null;
      };
    }, [scrollerRef, customScrollParent]);
    useEmitter2("windowScrollTo", scrollToCallback);
    useEmitter2("scrollBy", scrollByCallback);
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      ScrollerComponent,
      {
        style: { position: "relative", ...style, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },
        "data-virtuoso-scroller": true,
        ...props,
        ...contextPropIfNotDomElement(ScrollerComponent, context)
      },
      children
    );
  });
  return Scroller2;
}
const Viewport$2 = ({ children }) => {
  const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);
  const viewportHeight = usePublisher$2("viewportHeight");
  const fixedItemHeight = usePublisher$2("fixedItemHeight");
  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, "height")));
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (ctx) {
      viewportHeight(ctx.viewportHeight);
      fixedItemHeight(ctx.itemHeight);
    }
  }, [ctx, viewportHeight, fixedItemHeight]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { style: viewportStyle, ref: viewportRef, "data-viewport-type": "element" }, children);
};
const WindowViewport$2 = ({ children }) => {
  const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);
  const windowViewportRect = usePublisher$2("windowViewportRect");
  const fixedItemHeight = usePublisher$2("fixedItemHeight");
  const customScrollParent = useEmitterValue$2("customScrollParent");
  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (ctx) {
      fixedItemHeight(ctx.itemHeight);
      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });
    }
  }, [ctx, windowViewportRect, fixedItemHeight]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: viewportRef, style: viewportStyle, "data-viewport-type": "window" }, children);
};
const TopItemListContainer = ({ children }) => {
  const TopItemList = useEmitterValue$2("TopItemListComponent");
  const headerHeight = useEmitterValue$2("headerHeight");
  const style = { ...topItemListStyle, marginTop: `${headerHeight}px` };
  const context = useEmitterValue$2("context");
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(TopItemList || "div", { style, context }, children);
};
const ListRoot = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoRoot(props) {
  const useWindowScroll = useEmitterValue$2("useWindowScroll");
  const showTopList = useEmitterValue$2("topItemsIndexes").length > 0;
  const customScrollParent = useEmitterValue$2("customScrollParent");
  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;
  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheScroller, { ...props }, showTopList && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TopItemListContainer, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Items$1, { showTopList: true })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheViewport, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header$1, null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Items$1, null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer$1, null)));
});
const {
  Component: List,
  usePublisher: usePublisher$2,
  useEmitterValue: useEmitterValue$2,
  useEmitter: useEmitter$2
} = /* @__PURE__ */ systemToComponent(
  combinedSystem$2,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      itemContent: "itemContent",
      groupContent: "groupContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      groupCounts: "groupCounts",
      topItemCount: "topItemCount",
      firstItemIndex: "firstItemIndex",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  ListRoot
);
const Scroller$2 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });
const WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });
const Virtuoso = List;
const GroupedVirtuoso = List;
const INITIAL_GRID_STATE = {
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  bottom: 0,
  itemHeight: 0,
  itemWidth: 0
};
const PROBE_GRID_STATE = {
  items: [{ index: 0 }],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  bottom: 0,
  itemHeight: 0,
  itemWidth: 0
};
const { round, ceil, floor, min, max } = Math;
function buildProbeGridState(items) {
  return {
    ...PROBE_GRID_STATE,
    items
  };
}
function buildItems(startIndex, endIndex, data) {
  return Array.from({ length: endIndex - startIndex + 1 }).map((_, i) => {
    const dataItem = data === null ? null : data[i + startIndex];
    return { index: i + startIndex, data: dataItem };
  });
}
function gapComparator(prev, next) {
  return prev && prev.column === next.column && prev.row === next.row;
}
function dimensionComparator(prev, next) {
  return prev && prev.width === next.width && prev.height === next.height;
}
const gridSystem = /* @__PURE__ */ system(
  ([
    { overscan, visibleRange, listBoundary },
    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },
    stateFlags,
    scrollSeek,
    { propsReady, didMount },
    { windowViewportRect, useWindowScroll, customScrollParent, windowScrollContainerState, windowScrollTo },
    log
  ]) => {
    const totalCount = statefulStream(0);
    const initialItemCount = statefulStream(0);
    const gridState = statefulStream(INITIAL_GRID_STATE);
    const viewportDimensions = statefulStream({ height: 0, width: 0 });
    const itemDimensions = statefulStream({ height: 0, width: 0 });
    const scrollToIndex = stream();
    const scrollHeight = stream();
    const deviation = statefulStream(0);
    const data = statefulStream(null);
    const gap = statefulStream({ row: 0, column: 0 });
    const stateChanged = stream();
    const restoreStateFrom = stream();
    const stateRestoreInProgress = statefulStream(false);
    const initialTopMostItemIndex = statefulStream(0);
    const scrolledToInitialItem = statefulStream(true);
    const scrollScheduled = statefulStream(false);
    subscribe(
      pipe(
        didMount,
        withLatestFrom(initialTopMostItemIndex),
        filter(([_, location]) => !!location)
      ),
      () => {
        publish(scrolledToInitialItem, false);
        publish(initialItemCount, 0);
      }
    );
    subscribe(
      pipe(
        combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled),
        filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2, , scrollScheduled2]) => {
          return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;
        })
      ),
      ([, , , , initialTopMostItemIndex2]) => {
        publish(scrollScheduled, true);
        skipFrames(1, () => {
          publish(scrollToIndex, initialTopMostItemIndex2);
        });
        handleNext(pipe(scrollTop), () => {
          publish(listBoundary, [0, 0]);
          publish(scrolledToInitialItem, true);
        });
      }
    );
    connect(
      pipe(
        restoreStateFrom,
        filter((value) => value !== void 0 && value !== null && value.scrollTop > 0),
        mapTo(0)
      ),
      initialItemCount
    );
    subscribe(
      pipe(
        didMount,
        withLatestFrom(restoreStateFrom),
        filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)
      ),
      ([, snapshot]) => {
        if (!snapshot) {
          return;
        }
        publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);
        publish(gap, snapshot.gap);
        if (snapshot.scrollTop > 0) {
          publish(stateRestoreInProgress, true);
          handleNext(pipe(scrollTop, skip(1)), (_value) => {
            publish(stateRestoreInProgress, false);
          });
          publish(scrollTo, { top: snapshot.scrollTop });
        }
      }
    );
    connect(
      pipe(
        viewportDimensions,
        map(({ height }) => height)
      ),
      viewportHeight
    );
    connect(
      pipe(
        combineLatest(
          duc(viewportDimensions, dimensionComparator),
          duc(itemDimensions, dimensionComparator),
          duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row),
          duc(scrollTop)
        ),
        map(([viewport, item, gap2, scrollTop2]) => ({
          viewport,
          item,
          gap: gap2,
          scrollTop: scrollTop2
        }))
      ),
      stateChanged
    );
    connect(
      pipe(
        combineLatest(
          duc(totalCount),
          visibleRange,
          duc(gap, gapComparator),
          duc(itemDimensions, dimensionComparator),
          duc(viewportDimensions, dimensionComparator),
          duc(data),
          duc(initialItemCount),
          duc(stateRestoreInProgress),
          duc(scrolledToInitialItem),
          duc(initialTopMostItemIndex)
        ),
        filter(([, , , , , , , stateRestoreInProgress2]) => {
          return !stateRestoreInProgress2;
        }),
        map(
          ([
            totalCount2,
            [startOffset, endOffset],
            gap2,
            item,
            viewport,
            data2,
            initialItemCount2,
            ,
            scrolledToInitialItem2,
            initialTopMostItemIndex2
          ]) => {
            const { row: rowGap, column: columnGap } = gap2;
            const { height: itemHeight, width: itemWidth } = item;
            const { width: viewportWidth } = viewport;
            if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {
              return INITIAL_GRID_STATE;
            }
            if (itemWidth === 0) {
              const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);
              const endIndex2 = startIndex2 === 0 ? Math.max(initialItemCount2 - 1, 0) : startIndex2;
              return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));
            }
            const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);
            let startIndex;
            let endIndex;
            if (!scrolledToInitialItem2) {
              startIndex = 0;
              endIndex = -1;
            } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {
              startIndex = 0;
              endIndex = initialItemCount2 - 1;
            } else {
              startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));
              endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;
              endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));
              startIndex = min(endIndex, max(0, startIndex));
            }
            const items = buildItems(startIndex, endIndex, data2);
            const { top, bottom } = gridLayout(viewport, gap2, item, items);
            const rowCount = ceil(totalCount2 / perRow);
            const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;
            const offsetBottom = totalHeight - bottom;
            return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth };
          }
        )
      ),
      gridState
    );
    connect(
      pipe(
        data,
        filter((data2) => data2 !== null),
        map((data2) => data2.length)
      ),
      totalCount
    );
    connect(
      pipe(
        combineLatest(viewportDimensions, itemDimensions, gridState, gap),
        filter(([viewportDimensions2, itemDimensions2, { items }]) => {
          return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;
        }),
        map(([viewportDimensions2, itemDimensions2, { items }, gap2]) => {
          const { top, bottom } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);
          return [top, bottom];
        }),
        distinctUntilChanged(tupleComparator)
      ),
      listBoundary
    );
    const hasScrolled = statefulStream(false);
    connect(
      pipe(
        scrollTop,
        withLatestFrom(hasScrolled),
        map(([scrollTop2, hasScrolled2]) => {
          return hasScrolled2 || scrollTop2 !== 0;
        })
      ),
      hasScrolled
    );
    const endReached = streamFromEmitter(
      pipe(
        duc(gridState),
        filter(({ items }) => items.length > 0),
        withLatestFrom(totalCount, hasScrolled),
        filter(([{ items }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1),
        map(([, totalCount2]) => totalCount2 - 1),
        distinctUntilChanged()
      )
    );
    const startReached = streamFromEmitter(
      pipe(
        duc(gridState),
        filter(({ items }) => {
          return items.length > 0 && items[0].index === 0;
        }),
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        mapTo(0),
        distinctUntilChanged()
      )
    );
    const rangeChanged = streamFromEmitter(
      pipe(
        duc(gridState),
        withLatestFrom(stateRestoreInProgress),
        filter(([{ items }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2),
        map(([{ items }]) => {
          return {
            startIndex: items[0].index,
            endIndex: items[items.length - 1].index
          };
        }),
        distinctUntilChanged(rangeComparator),
        throttleTime(0)
      )
    );
    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);
    connect(
      pipe(
        scrollToIndex,
        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap),
        map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {
          const normalLocation = normalizeIndexLocation(location);
          const { align, behavior, offset } = normalLocation;
          let index = normalLocation.index;
          if (index === "LAST") {
            index = totalCount2 - 1;
          }
          index = max(0, index, min(totalCount2 - 1, index));
          let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);
          if (align === "end") {
            top = round(top - viewportDimensions2.height + itemDimensions2.height);
          } else if (align === "center") {
            top = round(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);
          }
          if (offset) {
            top += offset;
          }
          return { top, behavior };
        })
      ),
      scrollTo
    );
    const totalListHeight = statefulStreamFromEmitter(
      pipe(
        gridState,
        map((gridState2) => {
          return gridState2.offsetBottom + gridState2.bottom;
        })
      ),
      0
    );
    connect(
      pipe(
        windowViewportRect,
        map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))
      ),
      viewportDimensions
    );
    return {
      // input
      data,
      totalCount,
      viewportDimensions,
      itemDimensions,
      scrollTop,
      scrollHeight,
      overscan,
      scrollBy,
      scrollTo,
      scrollToIndex,
      smoothScrollTargetReached,
      windowViewportRect,
      windowScrollTo,
      useWindowScroll,
      customScrollParent,
      windowScrollContainerState,
      deviation,
      scrollContainerState,
      footerHeight,
      headerHeight,
      initialItemCount,
      gap,
      restoreStateFrom,
      ...scrollSeek,
      initialTopMostItemIndex,
      // output
      gridState,
      totalListHeight,
      ...stateFlags,
      startReached,
      endReached,
      rangeChanged,
      stateChanged,
      propsReady,
      stateRestoreInProgress,
      ...log
    };
  },
  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)
);
function gridLayout(viewport, gap, item, items) {
  const { height: itemHeight } = item;
  if (itemHeight === void 0 || items.length === 0) {
    return { top: 0, bottom: 0 };
  }
  const top = itemTop(viewport, gap, item, items[0].index);
  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;
  return { top, bottom };
}
function itemTop(viewport, gap, item, index) {
  const perRow = itemsPerRow(viewport.width, item.width, gap.column);
  const rowCount = floor(index / perRow);
  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;
  return top > 0 ? top + gap.row : top;
}
function itemsPerRow(viewportWidth, itemWidth, gap) {
  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));
}
const gridComponentPropsSystem = /* @__PURE__ */ system(() => {
  const itemContent = statefulStream((index) => `Item ${index}`);
  const components = statefulStream({});
  const context = statefulStream(null);
  const itemClassName = statefulStream("virtuoso-grid-item");
  const listClassName = statefulStream("virtuoso-grid-list");
  const computeItemKey = statefulStream(identity);
  const headerFooterTag = statefulStream("div");
  const scrollerRef = statefulStream(noop);
  const distinctProp = (propName, defaultValue = null) => {
    return statefulStreamFromEmitter(
      pipe(
        components,
        map((components2) => components2[propName]),
        distinctUntilChanged()
      ),
      defaultValue
    );
  };
  return {
    context,
    itemContent,
    components,
    computeItemKey,
    itemClassName,
    listClassName,
    headerFooterTag,
    scrollerRef,
    FooterComponent: distinctProp("Footer"),
    HeaderComponent: distinctProp("Header"),
    ListComponent: distinctProp("List", "div"),
    ItemComponent: distinctProp("Item", "div"),
    ScrollerComponent: distinctProp("Scroller", "div"),
    ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder", "div")
  };
});
const combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {
  return { ...gridSystem2, ...gridComponentPropsSystem2 };
}, tup(gridSystem, gridComponentPropsSystem));
const GridItems = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function GridItems2() {
  const gridState = useEmitterValue$1("gridState");
  const listClassName = useEmitterValue$1("listClassName");
  const itemClassName = useEmitterValue$1("itemClassName");
  const itemContent = useEmitterValue$1("itemContent");
  const computeItemKey = useEmitterValue$1("computeItemKey");
  const isSeeking = useEmitterValue$1("isSeeking");
  const scrollHeightCallback = usePublisher$1("scrollHeight");
  const ItemComponent = useEmitterValue$1("ItemComponent");
  const ListComponent = useEmitterValue$1("ListComponent");
  const ScrollSeekPlaceholder = useEmitterValue$1("ScrollSeekPlaceholder");
  const context = useEmitterValue$1("context");
  const itemDimensions = usePublisher$1("itemDimensions");
  const gridGap = usePublisher$1("gap");
  const log = useEmitterValue$1("log");
  const stateRestoreInProgress = useEmitterValue$1("stateRestoreInProgress");
  const listRef = useSize((el) => {
    const scrollHeight = el.parentElement.parentElement.scrollHeight;
    scrollHeightCallback(scrollHeight);
    const firstItem = el.firstChild;
    if (firstItem) {
      const { width, height } = firstItem.getBoundingClientRect();
      itemDimensions({ width, height });
    }
    gridGap({
      row: resolveGapValue("row-gap", getComputedStyle(el).rowGap, log),
      column: resolveGapValue("column-gap", getComputedStyle(el).columnGap, log)
    });
  });
  if (stateRestoreInProgress) {
    return null;
  }
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    ListComponent,
    {
      ref: listRef,
      className: listClassName,
      ...contextPropIfNotDomElement(ListComponent, context),
      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },
      "data-test-id": "virtuoso-item-list"
    },
    gridState.items.map((item) => {
      const key = computeItemKey(item.index, item.data, context);
      return isSeeking ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollSeekPlaceholder, {
        key,
        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),
        index: item.index,
        height: gridState.itemHeight,
        width: gridState.itemWidth
      }) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(
        ItemComponent,
        { ...contextPropIfNotDomElement(ItemComponent, context), className: itemClassName, "data-index": item.index, key },
        itemContent(item.index, item.data, context)
      );
    })
  );
});
const Header = react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoHeader2() {
  const Header2 = useEmitterValue$1("HeaderComponent");
  const headerHeight = usePublisher$1("headerHeight");
  const headerFooterTag = useEmitterValue$1("headerFooterTag");
  const ref = useSize((el) => headerHeight(correctItemSize(el, "height")));
  const context = useEmitterValue$1("context");
  return Header2 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, { ref }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;
});
const Footer = react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoGridFooter() {
  const Footer2 = useEmitterValue$1("FooterComponent");
  const footerHeight = usePublisher$1("footerHeight");
  const headerFooterTag = useEmitterValue$1("headerFooterTag");
  const ref = useSize((el) => footerHeight(correctItemSize(el, "height")));
  const context = useEmitterValue$1("context");
  return Footer2 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(headerFooterTag, { ref }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;
});
const Viewport$1 = ({ children }) => {
  const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoGridMockContext);
  const itemDimensions = usePublisher$1("itemDimensions");
  const viewportDimensions = usePublisher$1("viewportDimensions");
  const viewportRef = useSize((el) => {
    viewportDimensions(el.getBoundingClientRect());
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (ctx) {
      viewportDimensions({ height: ctx.viewportHeight, width: ctx.viewportWidth });
      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });
    }
  }, [ctx, viewportDimensions, itemDimensions]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { style: viewportStyle, ref: viewportRef }, children);
};
const WindowViewport$1 = ({ children }) => {
  const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoGridMockContext);
  const windowViewportRect = usePublisher$1("windowViewportRect");
  const itemDimensions = usePublisher$1("itemDimensions");
  const customScrollParent = useEmitterValue$1("customScrollParent");
  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (ctx) {
      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });
      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: ctx.viewportWidth });
    }
  }, [ctx, windowViewportRect, itemDimensions]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: viewportRef, style: viewportStyle }, children);
};
const GridRoot = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function GridRoot2({ ...props }) {
  const useWindowScroll = useEmitterValue$1("useWindowScroll");
  const customScrollParent = useEmitterValue$1("customScrollParent");
  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;
  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheScroller, { ...props }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheViewport, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Header, null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GridItems, null), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Footer, null)));
});
const {
  Component: Grid,
  usePublisher: usePublisher$1,
  useEmitterValue: useEmitterValue$1,
  useEmitter: useEmitter$1
} = /* @__PURE__ */ systemToComponent(
  combinedSystem$1,
  {
    optional: {
      context: "context",
      totalCount: "totalCount",
      overscan: "overscan",
      itemContent: "itemContent",
      components: "components",
      computeItemKey: "computeItemKey",
      data: "data",
      initialItemCount: "initialItemCount",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      headerFooterTag: "headerFooterTag",
      listClassName: "listClassName",
      itemClassName: "itemClassName",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel",
      restoreStateFrom: "restoreStateFrom",
      initialTopMostItemIndex: "initialTopMostItemIndex"
    },
    methods: {
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      scrollToIndex: "scrollToIndex"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      stateChanged: "stateChanged"
    }
  },
  GridRoot
);
const Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });
const WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });
function resolveGapValue(property, value, log) {
  if (value !== "normal" && !(value == null ? void 0 : value.endsWith("px"))) {
    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);
  }
  if (value === "normal") {
    return 0;
  }
  return parseInt(value != null ? value : "0", 10);
}
const VirtuosoGrid = Grid;
const tableComponentPropsSystem = /* @__PURE__ */ system(() => {
  const itemContent = statefulStream((index) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", null, "Item $", index));
  const context = statefulStream(null);
  const fixedHeaderContent = statefulStream(null);
  const fixedFooterContent = statefulStream(null);
  const components = statefulStream({});
  const computeItemKey = statefulStream(identity);
  const scrollerRef = statefulStream(noop);
  const distinctProp = (propName, defaultValue = null) => {
    return statefulStreamFromEmitter(
      pipe(
        components,
        map((components2) => components2[propName]),
        distinctUntilChanged()
      ),
      defaultValue
    );
  };
  return {
    context,
    itemContent,
    fixedHeaderContent,
    fixedFooterContent,
    components,
    computeItemKey,
    scrollerRef,
    TableComponent: distinctProp("Table", "table"),
    TableHeadComponent: distinctProp("TableHead", "thead"),
    TableFooterComponent: distinctProp("TableFoot", "tfoot"),
    TableBodyComponent: distinctProp("TableBody", "tbody"),
    TableRowComponent: distinctProp("TableRow", "tr"),
    ScrollerComponent: distinctProp("Scroller", "div"),
    EmptyPlaceholder: distinctProp("EmptyPlaceholder"),
    ScrollSeekPlaceholder: distinctProp("ScrollSeekPlaceholder"),
    FillerRow: distinctProp("FillerRow")
  };
});
const combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {
  return { ...listSystem2, ...propsSystem };
}, tup(listSystem, tableComponentPropsSystem));
const DefaultScrollSeekPlaceholder = ({ height }) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", { style: { height } }));
const DefaultFillerRow = ({ height }) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", { style: { height, padding: 0, border: 0 } }));
const ITEM_STYLE = { overflowAnchor: "none" };
const Items = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function VirtuosoItems2() {
  const listState = useEmitterValue("listState");
  const sizeRanges = usePublisher("sizeRanges");
  const useWindowScroll = useEmitterValue("useWindowScroll");
  const customScrollParent = useEmitterValue("customScrollParent");
  const windowScrollContainerStateCallback = usePublisher("windowScrollContainerState");
  const _scrollContainerStateCallback = usePublisher("scrollContainerState");
  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;
  const itemContent = useEmitterValue("itemContent");
  const trackItemSizes = useEmitterValue("trackItemSizes");
  const itemSize = useEmitterValue("itemSize");
  const log = useEmitterValue("log");
  const { callbackRef, ref } = useChangedListContentsSizes(
    sizeRanges,
    itemSize,
    trackItemSizes,
    scrollContainerStateCallback,
    log,
    void 0,
    customScrollParent
  );
  const [deviation, setDeviation] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  useEmitter("deviation", (value) => {
    if (deviation !== value) {
      ref.current.style.marginTop = `${value}px`;
      setDeviation(value);
    }
  });
  const EmptyPlaceholder = useEmitterValue("EmptyPlaceholder");
  const ScrollSeekPlaceholder = useEmitterValue("ScrollSeekPlaceholder") || DefaultScrollSeekPlaceholder;
  const FillerRow = useEmitterValue("FillerRow") || DefaultFillerRow;
  const TableBodyComponent = useEmitterValue("TableBodyComponent");
  const TableRowComponent = useEmitterValue("TableRowComponent");
  const computeItemKey = useEmitterValue("computeItemKey");
  const isSeeking = useEmitterValue("isSeeking");
  const paddingTopAddition = useEmitterValue("paddingTopAddition");
  const firstItemIndex = useEmitterValue("firstItemIndex");
  const statefulTotalCount = useEmitterValue("statefulTotalCount");
  const context = useEmitterValue("context");
  if (statefulTotalCount === 0 && EmptyPlaceholder) {
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));
  }
  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;
  const paddingBottom = listState.offsetBottom;
  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FillerRow, { height: paddingTop, key: "padding-top", context }) : null;
  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FillerRow, { height: paddingBottom, key: "padding-bottom", context }) : null;
  const items = listState.items.map((item) => {
    const index = item.originalIndex;
    const key = computeItemKey(index + firstItemIndex, item.data, context);
    if (isSeeking) {
      return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollSeekPlaceholder, {
        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),
        key,
        index: item.index,
        height: item.size,
        type: item.type || "item"
      });
    }
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
      TableRowComponent,
      {
        ...contextPropIfNotDomElement(TableRowComponent, context),
        ...itemPropIfNotDomElement(TableRowComponent, item.data),
        key,
        "data-index": index,
        "data-known-size": item.size,
        "data-item-index": item.index,
        style: ITEM_STYLE
      },
      itemContent(item.index, item.data, context)
    );
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    TableBodyComponent,
    { ref: callbackRef, "data-test-id": "virtuoso-item-list", ...contextPropIfNotDomElement(TableBodyComponent, context) },
    [paddingTopEl, ...items, paddingBottomEl]
  );
});
const Viewport = ({ children }) => {
  const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);
  const viewportHeight = usePublisher("viewportHeight");
  const fixedItemHeight = usePublisher("fixedItemHeight");
  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, "height")));
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (ctx) {
      viewportHeight(ctx.viewportHeight);
      fixedItemHeight(ctx.itemHeight);
    }
  }, [ctx, viewportHeight, fixedItemHeight]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { style: viewportStyle, ref: viewportRef, "data-viewport-type": "element" }, children);
};
const WindowViewport = ({ children }) => {
  const ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(VirtuosoMockContext);
  const windowViewportRect = usePublisher("windowViewportRect");
  const fixedItemHeight = usePublisher("fixedItemHeight");
  const customScrollParent = useEmitterValue("customScrollParent");
  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (ctx) {
      fixedItemHeight(ctx.itemHeight);
      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });
    }
  }, [ctx, windowViewportRect, fixedItemHeight]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ref: viewportRef, style: viewportStyle, "data-viewport-type": "window" }, children);
};
const TableRoot = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.memo(function TableVirtuosoRoot(props) {
  const useWindowScroll = useEmitterValue("useWindowScroll");
  const customScrollParent = useEmitterValue("customScrollParent");
  const fixedHeaderHeight = usePublisher("fixedHeaderHeight");
  const fixedFooterHeight = usePublisher("fixedFooterHeight");
  const fixedHeaderContent = useEmitterValue("fixedHeaderContent");
  const fixedFooterContent = useEmitterValue("fixedFooterContent");
  const context = useEmitterValue("context");
  const theadRef = useSize(compose(fixedHeaderHeight, (el) => correctItemSize(el, "height")));
  const tfootRef = useSize(compose(fixedFooterHeight, (el) => correctItemSize(el, "height")));
  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;
  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;
  const TheTable = useEmitterValue("TableComponent");
  const TheTHead = useEmitterValue("TableHeadComponent");
  const TheTFoot = useEmitterValue("TableFooterComponent");
  const theHead = fixedHeaderContent ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    TheTHead,
    {
      key: "TableHead",
      style: { zIndex: 2, position: "sticky", top: 0 },
      ref: theadRef,
      ...contextPropIfNotDomElement(TheTHead, context)
    },
    fixedHeaderContent()
  ) : null;
  const theFoot = fixedFooterContent ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    TheTFoot,
    {
      key: "TableFoot",
      style: { zIndex: 1, position: "sticky", bottom: 0 },
      ref: tfootRef,
      ...contextPropIfNotDomElement(TheTFoot, context)
    },
    fixedFooterContent()
  ) : null;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheScroller, { ...props }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(TheViewport, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(
    TheTable,
    { style: { borderSpacing: 0, overflowAnchor: "none" }, ...contextPropIfNotDomElement(TheTable, context) },
    [theHead, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Items, { key: "TableBody" }), theFoot]
  )));
});
const {
  Component: Table,
  usePublisher,
  useEmitterValue,
  useEmitter
} = /* @__PURE__ */ systemToComponent(
  combinedSystem,
  {
    required: {},
    optional: {
      restoreStateFrom: "restoreStateFrom",
      context: "context",
      followOutput: "followOutput",
      firstItemIndex: "firstItemIndex",
      itemContent: "itemContent",
      fixedHeaderContent: "fixedHeaderContent",
      fixedFooterContent: "fixedFooterContent",
      overscan: "overscan",
      increaseViewportBy: "increaseViewportBy",
      totalCount: "totalCount",
      topItemCount: "topItemCount",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      components: "components",
      groupCounts: "groupCounts",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      computeItemKey: "computeItemKey",
      defaultItemHeight: "defaultItemHeight",
      fixedItemHeight: "fixedItemHeight",
      itemSize: "itemSize",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      data: "data",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      alignToBottom: "alignToBottom",
      useWindowScroll: "useWindowScroll",
      customScrollParent: "customScrollParent",
      scrollerRef: "scrollerRef",
      logLevel: "logLevel"
    },
    methods: {
      scrollToIndex: "scrollToIndex",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollBy: "scrollBy",
      getState: "getState"
    },
    events: {
      isScrolling: "isScrolling",
      endReached: "endReached",
      startReached: "startReached",
      rangeChanged: "rangeChanged",
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      totalListHeightChanged: "totalListHeightChanged",
      itemsRendered: "itemsRendered",
      groupIndices: "groupIndices"
    }
  },
  TableRoot
);
const Scroller = /* @__PURE__ */ buildScroller({ usePublisher, useEmitterValue, useEmitter });
const WindowScroller = /* @__PURE__ */ buildWindowScroller({ usePublisher, useEmitterValue, useEmitter });
const TableVirtuoso = Table;



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmVhY3QtdmlydHVvc29fZGlzdF9pbmRleF9tanMuNGRmZDMwNTc2NTg2Y2RjODJjM2MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ087QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWSxJQUFJLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBK0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVFQUF1RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DLFFBQVE7QUFDUjtBQUNBO0FBQ0EsWUFBWSxrREFBa0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3RUFBd0U7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFrQztBQUM1QztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlEQUFpRCwyQ0FBMkM7QUFDNUYsNkRBQTZELDJDQUEyQztBQUN4RztBQVNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxvcmlzdGJ5Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXZpcnR1b3NvL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5jb25zdCBQVUJMSVNIID0gMDtcbmNvbnN0IFNVQlNDUklCRSA9IDE7XG5jb25zdCBSRVNFVCA9IDI7XG5jb25zdCBWQUxVRSA9IDQ7XG5mdW5jdGlvbiBjb21wb3NlKGEsIGIpIHtcbiAgcmV0dXJuIChhcmcpID0+IGEoYihhcmcpKTtcbn1cbmZ1bmN0aW9uIHRocnVzaChhcmcsIHByb2MpIHtcbiAgcmV0dXJuIHByb2MoYXJnKTtcbn1cbmZ1bmN0aW9uIGN1cnJ5MnRvMShwcm9jLCBhcmcxKSB7XG4gIHJldHVybiAoYXJnMikgPT4gcHJvYyhhcmcxLCBhcmcyKTtcbn1cbmZ1bmN0aW9uIGN1cnJ5MXRvMChwcm9jLCBhcmcpIHtcbiAgcmV0dXJuICgpID0+IHByb2MoYXJnKTtcbn1cbmZ1bmN0aW9uIHRhcChhcmcsIHByb2MpIHtcbiAgcHJvYyhhcmcpO1xuICByZXR1cm4gYXJnO1xufVxuZnVuY3Rpb24gdHVwKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3M7XG59XG5mdW5jdGlvbiBjYWxsKHByb2MpIHtcbiAgcHJvYygpO1xufVxuZnVuY3Rpb24gYWx3YXlzKHZhbHVlKSB7XG4gIHJldHVybiAoKSA9PiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGpvaW5Qcm9jKC4uLnByb2NzKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcHJvY3MubWFwKGNhbGwpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKGVtaXR0ZXIsIHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gZW1pdHRlcihTVUJTQ1JJQkUsIHN1YnNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiBwdWJsaXNoKHB1Ymxpc2hlciwgdmFsdWUpIHtcbiAgcHVibGlzaGVyKFBVQkxJU0gsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0KGVtaXR0ZXIpIHtcbiAgZW1pdHRlcihSRVNFVCk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShkZXBvdCkge1xuICByZXR1cm4gZGVwb3QoVkFMVUUpO1xufVxuZnVuY3Rpb24gY29ubmVjdChlbWl0dGVyLCBwdWJsaXNoZXIpIHtcbiAgcmV0dXJuIHN1YnNjcmliZShlbWl0dGVyLCBjdXJyeTJ0bzEocHVibGlzaGVyLCBQVUJMSVNIKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVOZXh0KGVtaXR0ZXIsIHN1YnNjcmlwdGlvbikge1xuICBjb25zdCB1bnN1YiA9IGVtaXR0ZXIoU1VCU0NSSUJFLCAodmFsdWUpID0+IHtcbiAgICB1bnN1YigpO1xuICAgIHN1YnNjcmlwdGlvbih2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdW5zdWI7XG59XG5mdW5jdGlvbiBzdHJlYW0oKSB7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgcmV0dXJuIChhY3Rpb24sIGFyZykgPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZSgwLCBzdWJzY3JpcHRpb25zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goYXJnKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleE9mID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKGFyZyk7XG4gICAgICAgICAgaWYgKGluZGV4T2YgPiAtMSkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaW5kZXhPZiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgY2FzZSBQVUJMSVNIOlxuICAgICAgICBzdWJzY3JpcHRpb25zLnNsaWNlKCkuZm9yRWFjaCgoc3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uKGFyZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBhY3Rpb24gJHthY3Rpb259YCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3RhdGVmdWxTdHJlYW0oaW5pdGlhbCkge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsO1xuICBjb25zdCBpbm5lclN1YmplY3QgPSBzdHJlYW0oKTtcbiAgcmV0dXJuIChhY3Rpb24sIGFyZykgPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXJnO1xuICAgICAgICBzdWJzY3JpcHRpb24odmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUFVCTElTSDpcbiAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWQUxVRTpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5uZXJTdWJqZWN0KGFjdGlvbiwgYXJnKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGV2ZW50SGFuZGxlcihlbWl0dGVyKSB7XG4gIGxldCB1bnN1YjtcbiAgbGV0IGN1cnJlbnRTdWJzY3JpcHRpb247XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB1bnN1YiAmJiB1bnN1YigpO1xuICByZXR1cm4gZnVuY3Rpb24oYWN0aW9uLCBzdWJzY3JpcHRpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICBpZiAoY3VycmVudFN1YnNjcmlwdGlvbiA9PT0gc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIHVuc3ViID0gc3Vic2NyaWJlKGVtaXR0ZXIsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHVuc3ViO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgYWN0aW9uICR7YWN0aW9ufWApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmVhbUZyb21FbWl0dGVyKGVtaXR0ZXIpIHtcbiAgcmV0dXJuIHRhcChzdHJlYW0oKSwgKHN0cmVhbTIpID0+IGNvbm5lY3QoZW1pdHRlciwgc3RyZWFtMikpO1xufVxuZnVuY3Rpb24gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihlbWl0dGVyLCBpbml0aWFsKSB7XG4gIHJldHVybiB0YXAoc3RhdGVmdWxTdHJlYW0oaW5pdGlhbCksIChzdHJlYW0yKSA9PiBjb25uZWN0KGVtaXR0ZXIsIHN0cmVhbTIpKTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVPcGVyYXRvcnMoLi4ub3BlcmF0b3JzKSB7XG4gIHJldHVybiAoc3Vic2NyaWJlcikgPT4ge1xuICAgIHJldHVybiBvcGVyYXRvcnMucmVkdWNlUmlnaHQodGhydXNoLCBzdWJzY3JpYmVyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHBpcGUoc291cmNlLCAuLi5vcGVyYXRvcnMpIHtcbiAgY29uc3QgcHJvamVjdCA9IGNvbWJpbmVPcGVyYXRvcnMoLi4ub3BlcmF0b3JzKTtcbiAgcmV0dXJuIChhY3Rpb24sIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZShzb3VyY2UsIHByb2plY3Qoc3Vic2NyaXB0aW9uKSk7XG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICByZXNldChzb3VyY2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IocHJldmlvdXMsIG5leHQpIHtcbiAgcmV0dXJuIHByZXZpb3VzID09PSBuZXh0O1xufVxuZnVuY3Rpb24gZGlzdGluY3RVbnRpbENoYW5nZWQoY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yKSB7XG4gIGxldCBjdXJyZW50O1xuICByZXR1cm4gKGRvbmUpID0+IChuZXh0KSA9PiB7XG4gICAgaWYgKCFjb21wYXJhdG9yKGN1cnJlbnQsIG5leHQpKSB7XG4gICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgIGRvbmUobmV4dCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSkge1xuICByZXR1cm4gKGRvbmUpID0+ICh2YWx1ZSkgPT4ge1xuICAgIHByZWRpY2F0ZSh2YWx1ZSkgJiYgZG9uZSh2YWx1ZSk7XG4gIH07XG59XG5mdW5jdGlvbiBtYXAocHJvamVjdCkge1xuICByZXR1cm4gKGRvbmUpID0+IGNvbXBvc2UoZG9uZSwgcHJvamVjdCk7XG59XG5mdW5jdGlvbiBtYXBUbyh2YWx1ZSkge1xuICByZXR1cm4gKGRvbmUpID0+ICgpID0+IGRvbmUodmFsdWUpO1xufVxuZnVuY3Rpb24gc2NhbihzY2FubmVyLCBpbml0aWFsKSB7XG4gIHJldHVybiAoZG9uZSkgPT4gKHZhbHVlKSA9PiBkb25lKGluaXRpYWwgPSBzY2FubmVyKGluaXRpYWwsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBza2lwKHRpbWVzKSB7XG4gIHJldHVybiAoZG9uZSkgPT4gKHZhbHVlKSA9PiB7XG4gICAgdGltZXMgPiAwID8gdGltZXMtLSA6IGRvbmUodmFsdWUpO1xuICB9O1xufVxuZnVuY3Rpb24gdGhyb3R0bGVUaW1lKGludGVydmFsKSB7XG4gIGxldCBjdXJyZW50VmFsdWUgPSBudWxsO1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIChkb25lKSA9PiAodmFsdWUpID0+IHtcbiAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lb3V0ID0gdm9pZCAwO1xuICAgICAgZG9uZShjdXJyZW50VmFsdWUpO1xuICAgIH0sIGludGVydmFsKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlVGltZShpbnRlcnZhbCkge1xuICBsZXQgY3VycmVudFZhbHVlO1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIChkb25lKSA9PiAodmFsdWUpID0+IHtcbiAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb25lKGN1cnJlbnRWYWx1ZSk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9O1xufVxuZnVuY3Rpb24gd2l0aExhdGVzdEZyb20oLi4uc291cmNlcykge1xuICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkoc291cmNlcy5sZW5ndGgpO1xuICBsZXQgY2FsbGVkID0gMDtcbiAgbGV0IHBlbmRpbmdDYWxsID0gbnVsbDtcbiAgY29uc3QgYWxsQ2FsbGVkID0gTWF0aC5wb3coMiwgc291cmNlcy5sZW5ndGgpIC0gMTtcbiAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgYml0ID0gTWF0aC5wb3coMiwgaW5kZXgpO1xuICAgIHN1YnNjcmliZShzb3VyY2UsICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgcHJldkNhbGxlZCA9IGNhbGxlZDtcbiAgICAgIGNhbGxlZCA9IGNhbGxlZCB8IGJpdDtcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgIGlmIChwcmV2Q2FsbGVkICE9PSBhbGxDYWxsZWQgJiYgY2FsbGVkID09PSBhbGxDYWxsZWQgJiYgcGVuZGluZ0NhbGwpIHtcbiAgICAgICAgcGVuZGluZ0NhbGwoKTtcbiAgICAgICAgcGVuZGluZ0NhbGwgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIChkb25lKSA9PiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjYWxsMiA9ICgpID0+IGRvbmUoW3ZhbHVlXS5jb25jYXQodmFsdWVzKSk7XG4gICAgaWYgKGNhbGxlZCA9PT0gYWxsQ2FsbGVkKSB7XG4gICAgICBjYWxsMigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nQ2FsbCA9IGNhbGwyO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlKC4uLnNvdXJjZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICByZXR1cm4gam9pblByb2MoLi4uc291cmNlcy5tYXAoKHNvdXJjZSkgPT4gc3Vic2NyaWJlKHNvdXJjZSwgc3Vic2NyaXB0aW9uKSkpO1xuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgYWN0aW9uICR7YWN0aW9ufWApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGR1Yyhzb3VyY2UsIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcikge1xuICByZXR1cm4gcGlwZShzb3VyY2UsIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbXBhcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVMYXRlc3QoLi4uZW1pdHRlcnMpIHtcbiAgY29uc3QgaW5uZXJTdWJqZWN0ID0gc3RyZWFtKCk7XG4gIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShlbWl0dGVycy5sZW5ndGgpO1xuICBsZXQgY2FsbGVkID0gMDtcbiAgY29uc3QgYWxsQ2FsbGVkID0gTWF0aC5wb3coMiwgZW1pdHRlcnMubGVuZ3RoKSAtIDE7XG4gIGVtaXR0ZXJzLmZvckVhY2goKHNvdXJjZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBiaXQgPSBNYXRoLnBvdygyLCBpbmRleCk7XG4gICAgc3Vic2NyaWJlKHNvdXJjZSwgKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICBjYWxsZWQgPSBjYWxsZWQgfCBiaXQ7XG4gICAgICBpZiAoY2FsbGVkID09PSBhbGxDYWxsZWQpIHtcbiAgICAgICAgcHVibGlzaChpbm5lclN1YmplY3QsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24oYWN0aW9uLCBzdWJzY3JpcHRpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIGlmIChjYWxsZWQgPT09IGFsbENhbGxlZCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbih2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmUoaW5uZXJTdWJqZWN0LCBzdWJzY3JpcHRpb24pO1xuICAgICAgY2FzZSBSRVNFVDpcbiAgICAgICAgcmV0dXJuIHJlc2V0KGlubmVyU3ViamVjdCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBhY3Rpb24gJHthY3Rpb259YCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3lzdGVtKGNvbnN0cnVjdG9yLCBkZXBlbmRlbmNpZXMgPSBbXSwgeyBzaW5nbGV0b24gfSA9IHsgc2luZ2xldG9uOiB0cnVlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogaWQoKSxcbiAgICBjb25zdHJ1Y3RvcixcbiAgICBkZXBlbmRlbmNpZXMsXG4gICAgc2luZ2xldG9uXG4gIH07XG59XG5jb25zdCBpZCA9ICgpID0+IFN5bWJvbCgpO1xuZnVuY3Rpb24gaW5pdChzeXN0ZW1TcGVjKSB7XG4gIGNvbnN0IHNpbmdsZXRvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBfaW5pdCA9ICh7IGlkOiBpZDIsIGNvbnN0cnVjdG9yLCBkZXBlbmRlbmNpZXMsIHNpbmdsZXRvbiB9KSA9PiB7XG4gICAgaWYgKHNpbmdsZXRvbiAmJiBzaW5nbGV0b25zLmhhcyhpZDIpKSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9ucy5nZXQoaWQyKTtcbiAgICB9XG4gICAgY29uc3Qgc3lzdGVtMiA9IGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcy5tYXAoKGUpID0+IF9pbml0KGUpKSk7XG4gICAgaWYgKHNpbmdsZXRvbikge1xuICAgICAgc2luZ2xldG9ucy5zZXQoaWQyLCBzeXN0ZW0yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5c3RlbTI7XG4gIH07XG4gIHJldHVybiBfaW5pdChzeXN0ZW1TcGVjKTtcbn1cbmZ1bmN0aW9uIG9taXQoa2V5cywgb2JqKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBpbmRleCA9IHt9O1xuICBsZXQgaWR4ID0gMDtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpbmRleFtrZXlzW2lkeF1dID0gMTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKCFpbmRleC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCQyID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gc3lzdGVtVG9Db21wb25lbnQoc3lzdGVtU3BlYywgbWFwMiwgUm9vdCkge1xuICBjb25zdCByZXF1aXJlZFByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG1hcDIucmVxdWlyZWQgfHwge30pO1xuICBjb25zdCBvcHRpb25hbFByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG1hcDIub3B0aW9uYWwgfHwge30pO1xuICBjb25zdCBtZXRob2ROYW1lcyA9IE9iamVjdC5rZXlzKG1hcDIubWV0aG9kcyB8fCB7fSk7XG4gIGNvbnN0IGV2ZW50TmFtZXMgPSBPYmplY3Qua2V5cyhtYXAyLmV2ZW50cyB8fCB7fSk7XG4gIGNvbnN0IENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcbiAgZnVuY3Rpb24gYXBwbHlQcm9wc1RvU3lzdGVtKHN5c3RlbTIsIHByb3BzKSB7XG4gICAgaWYgKHN5c3RlbTJbXCJwcm9wc1JlYWR5XCJdKSB7XG4gICAgICBwdWJsaXNoKHN5c3RlbTJbXCJwcm9wc1JlYWR5XCJdLCBmYWxzZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWlyZWRQcm9wTmFtZSBvZiByZXF1aXJlZFByb3BOYW1lcykge1xuICAgICAgY29uc3Qgc3RyZWFtMiA9IHN5c3RlbTJbbWFwMi5yZXF1aXJlZFtyZXF1aXJlZFByb3BOYW1lXV07XG4gICAgICBwdWJsaXNoKHN0cmVhbTIsIHByb3BzW3JlcXVpcmVkUHJvcE5hbWVdKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvcHRpb25hbFByb3BOYW1lIG9mIG9wdGlvbmFsUHJvcE5hbWVzKSB7XG4gICAgICBpZiAob3B0aW9uYWxQcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBzdHJlYW0yID0gc3lzdGVtMlttYXAyLm9wdGlvbmFsW29wdGlvbmFsUHJvcE5hbWVdXTtcbiAgICAgICAgcHVibGlzaChzdHJlYW0yLCBwcm9wc1tvcHRpb25hbFByb3BOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzeXN0ZW0yW1wicHJvcHNSZWFkeVwiXSkge1xuICAgICAgcHVibGlzaChzeXN0ZW0yW1wicHJvcHNSZWFkeVwiXSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkTWV0aG9kcyhzeXN0ZW0yKSB7XG4gICAgcmV0dXJuIG1ldGhvZE5hbWVzLnJlZHVjZSgoYWNjLCBtZXRob2ROYW1lKSA9PiB7XG4gICAgICBhY2NbbWV0aG9kTmFtZV0gPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgc3RyZWFtMiA9IHN5c3RlbTJbbWFwMi5tZXRob2RzW21ldGhvZE5hbWVdXTtcbiAgICAgICAgcHVibGlzaChzdHJlYW0yLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRFdmVudEhhbmRsZXJzKHN5c3RlbTIpIHtcbiAgICByZXR1cm4gZXZlbnROYW1lcy5yZWR1Y2UoKGhhbmRsZXJzLCBldmVudE5hbWUpID0+IHtcbiAgICAgIGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBldmVudEhhbmRsZXIoc3lzdGVtMlttYXAyLmV2ZW50c1tldmVudE5hbWVdXSk7XG4gICAgICByZXR1cm4gaGFuZGxlcnM7XG4gICAgfSwge30pO1xuICB9XG4gIGNvbnN0IENvbXBvbmVudCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzV2l0aENoaWxkcmVuLCByZWYpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5wcm9wcyB9ID0gcHJvcHNXaXRoQ2hpbGRyZW47XG4gICAgY29uc3QgW3N5c3RlbTJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhcChpbml0KHN5c3RlbVNwZWMpLCAoc3lzdGVtMjIpID0+IGFwcGx5UHJvcHNUb1N5c3RlbShzeXN0ZW0yMiwgcHJvcHMpKTtcbiAgICB9KTtcbiAgICBjb25zdCBbaGFuZGxlcnNdID0gUmVhY3QudXNlU3RhdGUoY3VycnkxdG8wKGJ1aWxkRXZlbnRIYW5kbGVycywgc3lzdGVtMikpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBvZiBldmVudE5hbWVzKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICBzdWJzY3JpYmUoaGFuZGxlcnNbZXZlbnROYW1lXSwgcHJvcHNbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoaGFuZGxlcnMpLm1hcChyZXNldCk7XG4gICAgICB9O1xuICAgIH0sIFtwcm9wcywgaGFuZGxlcnMsIHN5c3RlbTJdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JDIoKCkgPT4ge1xuICAgICAgYXBwbHlQcm9wc1RvU3lzdGVtKHN5c3RlbTIsIHByb3BzKTtcbiAgICB9KTtcbiAgICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgYWx3YXlzKGJ1aWxkTWV0aG9kcyhzeXN0ZW0yKSkpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgQ29udGV4dC5Qcm92aWRlcixcbiAgICAgIHsgdmFsdWU6IHN5c3RlbTIgfSxcbiAgICAgIFJvb3QgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBSb290LFxuICAgICAgICBvbWl0KFsuLi5yZXF1aXJlZFByb3BOYW1lcywgLi4ub3B0aW9uYWxQcm9wTmFtZXMsIC4uLmV2ZW50TmFtZXNdLCBwcm9wcyksXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApIDogY2hpbGRyZW5cbiAgICApO1xuICB9KTtcbiAgY29uc3QgdXNlUHVibGlzaGVyMiA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soY3VycnkydG8xKHB1Ymxpc2gsIFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dClba2V5XSksIFtrZXldKTtcbiAgfTtcbiAgY29uc3QgdXNlRW1pdHRlclZhbHVlMiA9IChrZXkpID0+IHtcbiAgICBjb25zdCBzeXN0ZW0yID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICBjb25zdCBzb3VyY2UgPSBzeXN0ZW0yW2tleV07XG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShjdXJyeTF0bzAoZ2V0VmFsdWUsIHNvdXJjZSkpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMihcbiAgICAgICgpID0+IHN1YnNjcmliZShzb3VyY2UsIChuZXh0KSA9PiB7XG4gICAgICAgIGlmIChuZXh0ICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHNldFZhbHVlKGFsd2F5cyhuZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgW3NvdXJjZSwgdmFsdWVdXG4gICAgKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGNvbnN0IHVzZUVtaXR0ZXIyID0gKGtleSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChDb250ZXh0KTtcbiAgICBjb25zdCBzb3VyY2UgPSBjb250ZXh0W2tleV07XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCQyKCgpID0+IHN1YnNjcmliZShzb3VyY2UsIGNhbGxiYWNrKSwgW2NhbGxiYWNrLCBzb3VyY2VdKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBDb21wb25lbnQsXG4gICAgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIyLFxuICAgIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlMixcbiAgICB1c2VFbWl0dGVyOiB1c2VFbWl0dGVyMlxuICB9O1xufVxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMSA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG52YXIgTG9nTGV2ZWwgPSAvKiBAX19QVVJFX18gKi8gKChMb2dMZXZlbDIpID0+IHtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJJTkZPXCJdID0gMV0gPSBcIklORk9cIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIldBUk5cIl0gPSAyXSA9IFwiV0FSTlwiO1xuICBMb2dMZXZlbDJbTG9nTGV2ZWwyW1wiRVJST1JcIl0gPSAzXSA9IFwiRVJST1JcIjtcbiAgcmV0dXJuIExvZ0xldmVsMjtcbn0pKExvZ0xldmVsIHx8IHt9KTtcbmNvbnN0IENPTlNPTEVfTUVUSE9EX01BUCA9IHtcbiAgW1xuICAgIDBcbiAgICAvKiBERUJVRyAqL1xuICBdOiBcImRlYnVnXCIsXG4gIFtcbiAgICAxXG4gICAgLyogSU5GTyAqL1xuICBdOiBcImxvZ1wiLFxuICBbXG4gICAgMlxuICAgIC8qIFdBUk4gKi9cbiAgXTogXCJ3YXJuXCIsXG4gIFtcbiAgICAzXG4gICAgLyogRVJST1IgKi9cbiAgXTogXCJlcnJvclwiXG59O1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogZ2xvYmFsVGhpcztcbmNvbnN0IGxvZ2dlclN5c3RlbSA9IHN5c3RlbShcbiAgKCkgPT4ge1xuICAgIGNvbnN0IGxvZ0xldmVsID0gc3RhdGVmdWxTdHJlYW0oXG4gICAgICAzXG4gICAgICAvKiBFUlJPUiAqL1xuICAgICk7XG4gICAgY29uc3QgbG9nID0gc3RhdGVmdWxTdHJlYW0oKGxhYmVsLCBtZXNzYWdlLCBsZXZlbCA9IDEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IChfYSA9IGdldEdsb2JhbFRoaXMoKVtcIlZJUlRVT1NPX0xPR19MRVZFTFwiXSkgIT0gbnVsbCA/IF9hIDogZ2V0VmFsdWUobG9nTGV2ZWwpO1xuICAgICAgaWYgKGxldmVsID49IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICBjb25zb2xlW0NPTlNPTEVfTUVUSE9EX01BUFtsZXZlbF1dKFxuICAgICAgICAgIFwiJWNyZWFjdC12aXJ0dW9zbzogJWMlcyAlb1wiLFxuICAgICAgICAgIFwiY29sb3I6ICMwMjUzYjM7IGZvbnQtd2VpZ2h0OiBib2xkXCIsXG4gICAgICAgICAgXCJjb2xvcjogaW5pdGlhbFwiLFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nLFxuICAgICAgbG9nTGV2ZWxcbiAgICB9O1xuICB9LFxuICBbXSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHVzZVNpemVXaXRoRWxSZWYoY2FsbGJhY2ssIGVuYWJsZWQgPSB0cnVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgbGV0IGNhbGxiYWNrUmVmID0gKF9lbCkgPT4ge1xuICB9O1xuICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVudHJpZXNbMF0udGFyZ2V0O1xuICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgW2NhbGxiYWNrXSk7XG4gICAgY2FsbGJhY2tSZWYgPSAoZWxSZWYpID0+IHtcbiAgICAgIGlmIChlbFJlZiAmJiBlbmFibGVkKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxSZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IGVsUmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyByZWYsIGNhbGxiYWNrUmVmIH07XG59XG5mdW5jdGlvbiB1c2VTaXplKGNhbGxiYWNrLCBlbmFibGVkID0gdHJ1ZSkge1xuICByZXR1cm4gdXNlU2l6ZVdpdGhFbFJlZihjYWxsYmFjaywgZW5hYmxlZCkuY2FsbGJhY2tSZWY7XG59XG5mdW5jdGlvbiB1c2VDaGFuZ2VkTGlzdENvbnRlbnRzU2l6ZXMoY2FsbGJhY2ssIGl0ZW1TaXplLCBlbmFibGVkLCBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLCBsb2csIGdhcCwgY3VzdG9tU2Nyb2xsUGFyZW50KSB7XG4gIGNvbnN0IG1lbW9lZENhbGxiYWNrID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsKSA9PiB7XG4gICAgICBjb25zdCByYW5nZXMgPSBnZXRDaGFuZ2VkQ2hpbGRTaXplcyhlbC5jaGlsZHJlbiwgaXRlbVNpemUsIFwib2Zmc2V0SGVpZ2h0XCIsIGxvZyk7XG4gICAgICBsZXQgc2Nyb2xsYWJsZUVsZW1lbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgICAgd2hpbGUgKCFzY3JvbGxhYmxlRWxlbWVudC5kYXRhc2V0W1widmlydHVvc29TY3JvbGxlclwiXSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudCA9IHNjcm9sbGFibGVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCB3aW5kb3dTY3JvbGxpbmcgPSBzY3JvbGxhYmxlRWxlbWVudC5sYXN0RWxlbWVudENoaWxkLmRhdGFzZXRbXCJ2aWV3cG9ydFR5cGVcIl0gPT09IFwid2luZG93XCI7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBjdXN0b21TY3JvbGxQYXJlbnQgPyBjdXN0b21TY3JvbGxQYXJlbnQuc2Nyb2xsVG9wIDogd2luZG93U2Nyb2xsaW5nID8gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBjdXN0b21TY3JvbGxQYXJlbnQgPyBjdXN0b21TY3JvbGxQYXJlbnQuc2Nyb2xsSGVpZ2h0IDogd2luZG93U2Nyb2xsaW5nID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA6IHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gY3VzdG9tU2Nyb2xsUGFyZW50ID8gY3VzdG9tU2Nyb2xsUGFyZW50Lm9mZnNldEhlaWdodCA6IHdpbmRvd1Njcm9sbGluZyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHNjcm9sbGFibGVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2soe1xuICAgICAgICBzY3JvbGxUb3A6IE1hdGgubWF4KHNjcm9sbFRvcCwgMCksXG4gICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgdmlld3BvcnRIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgZ2FwID09IG51bGwgPyB2b2lkIDAgOiBnYXAocmVzb2x2ZUdhcFZhbHVlJDEoXCJyb3ctZ2FwXCIsIGdldENvbXB1dGVkU3R5bGUoZWwpLnJvd0dhcCwgbG9nKSk7XG4gICAgICBpZiAocmFuZ2VzICE9PSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrKHJhbmdlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbY2FsbGJhY2ssIGl0ZW1TaXplLCBsb2csIGdhcCwgY3VzdG9tU2Nyb2xsUGFyZW50LCBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrXVxuICApO1xuICByZXR1cm4gdXNlU2l6ZVdpdGhFbFJlZihtZW1vZWRDYWxsYmFjaywgZW5hYmxlZCk7XG59XG5mdW5jdGlvbiBnZXRDaGFuZ2VkQ2hpbGRTaXplcyhjaGlsZHJlbiwgaXRlbVNpemUsIGZpZWxkLCBsb2cpIHtcbiAgY29uc3QgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbi5pdGVtKGkpO1xuICAgIGlmICghY2hpbGQgfHwgY2hpbGQuZGF0YXNldC5pbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjaGlsZC5kYXRhc2V0LmluZGV4KTtcbiAgICBjb25zdCBrbm93blNpemUgPSBwYXJzZUZsb2F0KGNoaWxkLmRhdGFzZXQua25vd25TaXplKTtcbiAgICBjb25zdCBzaXplID0gaXRlbVNpemUoY2hpbGQsIGZpZWxkKTtcbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgbG9nKFwiWmVyby1zaXplZCBlbGVtZW50LCB0aGlzIHNob3VsZCBub3QgaGFwcGVuXCIsIHsgY2hpbGQgfSwgTG9nTGV2ZWwuRVJST1IpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA9PT0ga25vd25TaXplKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbGFzdFJlc3VsdCA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDAgfHwgbGFzdFJlc3VsdC5zaXplICE9PSBzaXplIHx8IGxhc3RSZXN1bHQuZW5kSW5kZXggIT09IGluZGV4IC0gMSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHsgc3RhcnRJbmRleDogaW5kZXgsIGVuZEluZGV4OiBpbmRleCwgc2l6ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdLmVuZEluZGV4Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUdhcFZhbHVlJDEocHJvcGVydHksIHZhbHVlLCBsb2cpIHtcbiAgaWYgKHZhbHVlICE9PSBcIm5vcm1hbFwiICYmICEodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLmVuZHNXaXRoKFwicHhcIikpKSB7XG4gICAgbG9nKGAke3Byb3BlcnR5fSB3YXMgbm90IHJlc29sdmVkIHRvIHBpeGVsIHZhbHVlIGNvcnJlY3RseWAsIHZhbHVlLCBMb2dMZXZlbC5XQVJOKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IFwibm9ybWFsXCIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogXCIwXCIsIDEwKTtcbn1cbmZ1bmN0aW9uIGNvcnJlY3RJdGVtU2l6ZShlbCwgZGltZW5zaW9uKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl0pO1xufVxuZnVuY3Rpb24gYXBwcm94aW1hdGVseUVxdWFsKG51bTEsIG51bTIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKG51bTEgLSBudW0yKSA8IDEuMDE7XG59XG5mdW5jdGlvbiB1c2VTY3JvbGxUb3Aoc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjaywgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCwgc2Nyb2xsZXJFbGVtZW50LCBzY3JvbGxlclJlZkNhbGxiYWNrID0gbm9vcCwgY3VzdG9tU2Nyb2xsUGFyZW50KSB7XG4gIGNvbnN0IHNjcm9sbGVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzY3JvbGxUb3BUYXJnZXQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGhhbmRsZXIgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXYpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZXYudGFyZ2V0O1xuICAgICAgY29uc3Qgd2luZG93U2Nyb2xsID0gZWwgPT09IHdpbmRvdyB8fCBlbCA9PT0gZG9jdW1lbnQ7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3dTY3JvbGwgPyB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IGVsLnNjcm9sbFRvcDtcbiAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHdpbmRvd1Njcm9sbCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgOiBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHdpbmRvd1Njcm9sbCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGVsLm9mZnNldEhlaWdodDtcbiAgICAgIGNvbnN0IGNhbGwyID0gKCkgPT4ge1xuICAgICAgICBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrKHtcbiAgICAgICAgICBzY3JvbGxUb3A6IE1hdGgubWF4KHNjcm9sbFRvcCwgMCksXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChldi5zdXBwcmVzc0ZsdXNoU3luYykge1xuICAgICAgICBjYWxsMigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKGNhbGwyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxUb3BUYXJnZXQuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSBzY3JvbGxUb3BUYXJnZXQuY3VycmVudCB8fCBzY3JvbGxUb3AgPD0gMCB8fCBzY3JvbGxUb3AgPT09IHNjcm9sbEhlaWdodCAtIHZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgICAgICAgc2Nyb2xsVG9wVGFyZ2V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQodHJ1ZSk7XG4gICAgICAgICAgaWYgKHRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW3Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2ssIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWRdXG4gICk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbG9jYWxSZWYgPSBjdXN0b21TY3JvbGxQYXJlbnQgPyBjdXN0b21TY3JvbGxQYXJlbnQgOiBzY3JvbGxlclJlZi5jdXJyZW50O1xuICAgIHNjcm9sbGVyUmVmQ2FsbGJhY2soY3VzdG9tU2Nyb2xsUGFyZW50ID8gY3VzdG9tU2Nyb2xsUGFyZW50IDogc2Nyb2xsZXJSZWYuY3VycmVudCk7XG4gICAgaGFuZGxlcih7IHRhcmdldDogbG9jYWxSZWYsIHN1cHByZXNzRmx1c2hTeW5jOiB0cnVlIH0pO1xuICAgIGxvY2FsUmVmLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzY3JvbGxlclJlZkNhbGxiYWNrKG51bGwpO1xuICAgICAgbG9jYWxSZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbc2Nyb2xsZXJSZWYsIGhhbmRsZXIsIHNjcm9sbGVyRWxlbWVudCwgc2Nyb2xsZXJSZWZDYWxsYmFjaywgY3VzdG9tU2Nyb2xsUGFyZW50XSk7XG4gIGZ1bmN0aW9uIHNjcm9sbFRvQ2FsbGJhY2sobG9jYXRpb24pIHtcbiAgICBjb25zdCBzY3JvbGxlckVsZW1lbnQyID0gc2Nyb2xsZXJSZWYuY3VycmVudDtcbiAgICBpZiAoIXNjcm9sbGVyRWxlbWVudDIgfHwgXCJvZmZzZXRIZWlnaHRcIiBpbiBzY3JvbGxlckVsZW1lbnQyICYmIHNjcm9sbGVyRWxlbWVudDIub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzU21vb3RoID0gbG9jYXRpb24uYmVoYXZpb3IgPT09IFwic21vb3RoXCI7XG4gICAgbGV0IG9mZnNldEhlaWdodDtcbiAgICBsZXQgc2Nyb2xsSGVpZ2h0O1xuICAgIGxldCBzY3JvbGxUb3A7XG4gICAgaWYgKHNjcm9sbGVyRWxlbWVudDIgPT09IHdpbmRvdykge1xuICAgICAgc2Nyb2xsSGVpZ2h0ID0gTWF0aC5tYXgoY29ycmVjdEl0ZW1TaXplKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJoZWlnaHRcIiksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpO1xuICAgICAgb2Zmc2V0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgc2Nyb2xsVG9wID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsSGVpZ2h0ID0gc2Nyb2xsZXJFbGVtZW50Mi5zY3JvbGxIZWlnaHQ7XG4gICAgICBvZmZzZXRIZWlnaHQgPSBjb3JyZWN0SXRlbVNpemUoc2Nyb2xsZXJFbGVtZW50MiwgXCJoZWlnaHRcIik7XG4gICAgICBzY3JvbGxUb3AgPSBzY3JvbGxlckVsZW1lbnQyLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgY29uc3QgbWF4U2Nyb2xsVG9wID0gc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0O1xuICAgIGxvY2F0aW9uLnRvcCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLm1pbihtYXhTY3JvbGxUb3AsIGxvY2F0aW9uLnRvcCksIDApKTtcbiAgICBpZiAoYXBwcm94aW1hdGVseUVxdWFsKG9mZnNldEhlaWdodCwgc2Nyb2xsSGVpZ2h0KSB8fCBsb2NhdGlvbi50b3AgPT09IHNjcm9sbFRvcCkge1xuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayh7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCB2aWV3cG9ydEhlaWdodDogb2Zmc2V0SGVpZ2h0IH0pO1xuICAgICAgaWYgKGlzU21vb3RoKSB7XG4gICAgICAgIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQodHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1Ntb290aCkge1xuICAgICAgc2Nyb2xsVG9wVGFyZ2V0LmN1cnJlbnQgPSBsb2NhdGlvbi50b3A7XG4gICAgICBpZiAodGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHNjcm9sbFRvcFRhcmdldC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCh0cnVlKTtcbiAgICAgIH0sIDFlMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbFRvcFRhcmdldC5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2Nyb2xsZXJFbGVtZW50Mi5zY3JvbGxUbyhsb2NhdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gc2Nyb2xsQnlDYWxsYmFjayhsb2NhdGlvbikge1xuICAgIHNjcm9sbGVyUmVmLmN1cnJlbnQuc2Nyb2xsQnkobG9jYXRpb24pO1xuICB9XG4gIHJldHVybiB7IHNjcm9sbGVyUmVmLCBzY3JvbGxCeUNhbGxiYWNrLCBzY3JvbGxUb0NhbGxiYWNrIH07XG59XG5jb25zdCBkb21JT1N5c3RlbSA9IHN5c3RlbShcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gc3RyZWFtKCk7XG4gICAgY29uc3QgZGV2aWF0aW9uID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHN0YXRlZnVsU2Nyb2xsVG9wID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBoZWFkZXJIZWlnaHQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBmaXhlZEhlYWRlckhlaWdodCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGZpeGVkRm9vdGVySGVpZ2h0ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgZm9vdGVySGVpZ2h0ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgc2Nyb2xsVG8gPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzY3JvbGxCeSA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHNjcm9sbGluZ0luUHJvZ3Jlc3MgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlLFxuICAgICAgICBtYXAoKHsgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyIH0pID0+IHNjcm9sbFRvcDIpXG4gICAgICApLFxuICAgICAgc2Nyb2xsVG9wXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgICAgIG1hcCgoeyBzY3JvbGxIZWlnaHQ6IHNjcm9sbEhlaWdodDIgfSkgPT4gc2Nyb2xsSGVpZ2h0MilcbiAgICAgICksXG4gICAgICBzY3JvbGxIZWlnaHRcbiAgICApO1xuICAgIGNvbm5lY3Qoc2Nyb2xsVG9wLCBzdGF0ZWZ1bFNjcm9sbFRvcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGlucHV0XG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgIHNjcm9sbFRvcCxcbiAgICAgIHZpZXdwb3J0SGVpZ2h0LFxuICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgZml4ZWRIZWFkZXJIZWlnaHQsXG4gICAgICBmaXhlZEZvb3RlckhlaWdodCxcbiAgICAgIGZvb3RlckhlaWdodCxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQsXG4gICAgICAvLyBzaWduYWxzXG4gICAgICBzY3JvbGxUbyxcbiAgICAgIHNjcm9sbEJ5LFxuICAgICAgLy8gc3RhdGVcbiAgICAgIHN0YXRlZnVsU2Nyb2xsVG9wLFxuICAgICAgZGV2aWF0aW9uLFxuICAgICAgc2Nyb2xsaW5nSW5Qcm9ncmVzc1xuICAgIH07XG4gIH0sXG4gIFtdLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3QgTklMX05PREUgPSB7IGx2bDogMCB9O1xuZnVuY3Rpb24gbmV3QUFOb2RlKGssIHYsIGx2bCwgbCA9IE5JTF9OT0RFLCByID0gTklMX05PREUpIHtcbiAgcmV0dXJuIHsgaywgdiwgbHZsLCBsLCByIH07XG59XG5mdW5jdGlvbiBlbXB0eShub2RlKSB7XG4gIHJldHVybiBub2RlID09PSBOSUxfTk9ERTtcbn1cbmZ1bmN0aW9uIG5ld1RyZWUoKSB7XG4gIHJldHVybiBOSUxfTk9ERTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShub2RlLCBrZXkpIHtcbiAgaWYgKGVtcHR5KG5vZGUpKVxuICAgIHJldHVybiBOSUxfTk9ERTtcbiAgY29uc3QgeyBrLCBsLCByIH0gPSBub2RlO1xuICBpZiAoa2V5ID09PSBrKSB7XG4gICAgaWYgKGVtcHR5KGwpKSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9IGVsc2UgaWYgKGVtcHR5KHIpKSB7XG4gICAgICByZXR1cm4gbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW2xhc3RLZXksIGxhc3RWYWx1ZV0gPSBsYXN0KGwpO1xuICAgICAgcmV0dXJuIGFkanVzdChjbG9uZShub2RlLCB7IGs6IGxhc3RLZXksIHY6IGxhc3RWYWx1ZSwgbDogZGVsZXRlTGFzdChsKSB9KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleSA8IGspIHtcbiAgICByZXR1cm4gYWRqdXN0KGNsb25lKG5vZGUsIHsgbDogcmVtb3ZlKGwsIGtleSkgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhZGp1c3QoY2xvbmUobm9kZSwgeyByOiByZW1vdmUociwga2V5KSB9KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmQobm9kZSwga2V5KSB7XG4gIGlmIChlbXB0eShub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5ID09PSBub2RlLmspIHtcbiAgICByZXR1cm4gbm9kZS52O1xuICB9IGVsc2UgaWYgKGtleSA8IG5vZGUuaykge1xuICAgIHJldHVybiBmaW5kKG5vZGUubCwga2V5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZChub2RlLnIsIGtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRNYXhLZXlWYWx1ZShub2RlLCB2YWx1ZSwgZmllbGQgPSBcImtcIikge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gWy1JbmZpbml0eSwgdm9pZCAwXTtcbiAgfVxuICBpZiAoTnVtYmVyKG5vZGVbZmllbGRdKSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gW25vZGUuaywgbm9kZS52XTtcbiAgfVxuICBpZiAoTnVtYmVyKG5vZGVbZmllbGRdKSA8IHZhbHVlKSB7XG4gICAgY29uc3QgciA9IGZpbmRNYXhLZXlWYWx1ZShub2RlLnIsIHZhbHVlLCBmaWVsZCk7XG4gICAgaWYgKHJbMF0gPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuIFtub2RlLmssIG5vZGUudl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluZE1heEtleVZhbHVlKG5vZGUubCwgdmFsdWUsIGZpZWxkKTtcbn1cbmZ1bmN0aW9uIGluc2VydChub2RlLCBrLCB2KSB7XG4gIGlmIChlbXB0eShub2RlKSkge1xuICAgIHJldHVybiBuZXdBQU5vZGUoaywgdiwgMSk7XG4gIH1cbiAgaWYgKGsgPT09IG5vZGUuaykge1xuICAgIHJldHVybiBjbG9uZShub2RlLCB7IGssIHYgfSk7XG4gIH0gZWxzZSBpZiAoayA8IG5vZGUuaykge1xuICAgIHJldHVybiByZWJhbGFuY2UoY2xvbmUobm9kZSwgeyBsOiBpbnNlcnQobm9kZS5sLCBrLCB2KSB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlYmFsYW5jZShjbG9uZShub2RlLCB7IHI6IGluc2VydChub2RlLnIsIGssIHYpIH0pKTtcbiAgfVxufVxuZnVuY3Rpb24gd2Fsa1dpdGhpbihub2RlLCBzdGFydCwgZW5kKSB7XG4gIGlmIChlbXB0eShub2RlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB7IGssIHYsIGwsIHIgfSA9IG5vZGU7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgaWYgKGsgPiBzdGFydCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQod2Fsa1dpdGhpbihsLCBzdGFydCwgZW5kKSk7XG4gIH1cbiAgaWYgKGsgPj0gc3RhcnQgJiYgayA8PSBlbmQpIHtcbiAgICByZXN1bHQucHVzaCh7IGssIHYgfSk7XG4gIH1cbiAgaWYgKGsgPD0gZW5kKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh3YWxrV2l0aGluKHIsIHN0YXJ0LCBlbmQpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gIGlmIChlbXB0eShub2RlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gWy4uLndhbGsobm9kZS5sKSwgeyBrOiBub2RlLmssIHY6IG5vZGUudiB9LCAuLi53YWxrKG5vZGUucildO1xufVxuZnVuY3Rpb24gbGFzdChub2RlKSB7XG4gIHJldHVybiBlbXB0eShub2RlLnIpID8gW25vZGUuaywgbm9kZS52XSA6IGxhc3Qobm9kZS5yKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUxhc3Qobm9kZSkge1xuICByZXR1cm4gZW1wdHkobm9kZS5yKSA/IG5vZGUubCA6IGFkanVzdChjbG9uZShub2RlLCB7IHI6IGRlbGV0ZUxhc3Qobm9kZS5yKSB9KSk7XG59XG5mdW5jdGlvbiBjbG9uZShub2RlLCBhcmdzKSB7XG4gIHJldHVybiBuZXdBQU5vZGUoXG4gICAgYXJncy5rICE9PSB2b2lkIDAgPyBhcmdzLmsgOiBub2RlLmssXG4gICAgYXJncy52ICE9PSB2b2lkIDAgPyBhcmdzLnYgOiBub2RlLnYsXG4gICAgYXJncy5sdmwgIT09IHZvaWQgMCA/IGFyZ3MubHZsIDogbm9kZS5sdmwsXG4gICAgYXJncy5sICE9PSB2b2lkIDAgPyBhcmdzLmwgOiBub2RlLmwsXG4gICAgYXJncy5yICE9PSB2b2lkIDAgPyBhcmdzLnIgOiBub2RlLnJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzU2luZ2xlKG5vZGUpIHtcbiAgcmV0dXJuIGVtcHR5KG5vZGUpIHx8IG5vZGUubHZsID4gbm9kZS5yLmx2bDtcbn1cbmZ1bmN0aW9uIHJlYmFsYW5jZShub2RlKSB7XG4gIHJldHVybiBzcGxpdChza2V3KG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGFkanVzdChub2RlKSB7XG4gIGNvbnN0IHsgbCwgciwgbHZsIH0gPSBub2RlO1xuICBpZiAoci5sdmwgPj0gbHZsIC0gMSAmJiBsLmx2bCA+PSBsdmwgLSAxKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0gZWxzZSBpZiAobHZsID4gci5sdmwgKyAxKSB7XG4gICAgaWYgKGlzU2luZ2xlKGwpKSB7XG4gICAgICByZXR1cm4gc2tldyhjbG9uZShub2RlLCB7IGx2bDogbHZsIC0gMSB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZW1wdHkobCkgJiYgIWVtcHR5KGwucikpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKGwuciwge1xuICAgICAgICAgIGw6IGNsb25lKGwsIHsgcjogbC5yLmwgfSksXG4gICAgICAgICAgcjogY2xvbmUobm9kZSwge1xuICAgICAgICAgICAgbDogbC5yLnIsXG4gICAgICAgICAgICBsdmw6IGx2bCAtIDFcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBsdmxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVtcHR5IG5vZGVzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNTaW5nbGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBzcGxpdChjbG9uZShub2RlLCB7IGx2bDogbHZsIC0gMSB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZW1wdHkocikgJiYgIWVtcHR5KHIubCkpIHtcbiAgICAgICAgY29uc3QgcmwgPSByLmw7XG4gICAgICAgIGNvbnN0IHJsdmwgPSBpc1NpbmdsZShybCkgPyByLmx2bCAtIDEgOiByLmx2bDtcbiAgICAgICAgcmV0dXJuIGNsb25lKHJsLCB7XG4gICAgICAgICAgbDogY2xvbmUobm9kZSwge1xuICAgICAgICAgICAgcjogcmwubCxcbiAgICAgICAgICAgIGx2bDogbHZsIC0gMVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHI6IHNwbGl0KGNsb25lKHIsIHsgbDogcmwuciwgbHZsOiBybHZsIH0pKSxcbiAgICAgICAgICBsdmw6IHJsLmx2bCArIDFcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVtcHR5IG5vZGVzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmFuZ2VzV2l0aGluKG5vZGUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGlmIChlbXB0eShub2RlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBhZGp1c3RlZFN0YXJ0ID0gZmluZE1heEtleVZhbHVlKG5vZGUsIHN0YXJ0SW5kZXgpWzBdO1xuICByZXR1cm4gdG9SYW5nZXMod2Fsa1dpdGhpbihub2RlLCBhZGp1c3RlZFN0YXJ0LCBlbmRJbmRleCkpO1xufVxuZnVuY3Rpb24gYXJyYXlUb1JhbmdlcyhpdGVtcywgcGFyc2VyKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgeyBpbmRleDogc3RhcnQsIHZhbHVlIH0gPSBwYXJzZXIoaXRlbXNbMF0pO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgaW5kZXg6IG5leHRJbmRleCwgdmFsdWU6IG5leHRWYWx1ZSB9ID0gcGFyc2VyKGl0ZW1zW2ldKTtcbiAgICByZXN1bHQucHVzaCh7IHN0YXJ0LCBlbmQ6IG5leHRJbmRleCAtIDEsIHZhbHVlIH0pO1xuICAgIHN0YXJ0ID0gbmV4dEluZGV4O1xuICAgIHZhbHVlID0gbmV4dFZhbHVlO1xuICB9XG4gIHJlc3VsdC5wdXNoKHsgc3RhcnQsIGVuZDogSW5maW5pdHksIHZhbHVlIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9SYW5nZXMobm9kZXMpIHtcbiAgcmV0dXJuIGFycmF5VG9SYW5nZXMobm9kZXMsICh7IGs6IGluZGV4LCB2OiB2YWx1ZSB9KSA9PiAoeyBpbmRleCwgdmFsdWUgfSkpO1xufVxuZnVuY3Rpb24gc3BsaXQobm9kZSkge1xuICBjb25zdCB7IHIsIGx2bCB9ID0gbm9kZTtcbiAgcmV0dXJuICFlbXB0eShyKSAmJiAhZW1wdHkoci5yKSAmJiByLmx2bCA9PT0gbHZsICYmIHIuci5sdmwgPT09IGx2bCA/IGNsb25lKHIsIHsgbDogY2xvbmUobm9kZSwgeyByOiByLmwgfSksIGx2bDogbHZsICsgMSB9KSA6IG5vZGU7XG59XG5mdW5jdGlvbiBza2V3KG5vZGUpIHtcbiAgY29uc3QgeyBsIH0gPSBub2RlO1xuICByZXR1cm4gIWVtcHR5KGwpICYmIGwubHZsID09PSBub2RlLmx2bCA/IGNsb25lKGwsIHsgcjogY2xvbmUobm9kZSwgeyBsOiBsLnIgfSkgfSkgOiBub2RlO1xufVxuZnVuY3Rpb24gZmluZEluZGV4T2ZDbG9zZXN0U21hbGxlck9yRXF1YWwoaXRlbXMsIHZhbHVlLCBjb21wYXJhdG9yLCBzdGFydCA9IDApIHtcbiAgbGV0IGVuZCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF07XG4gICAgY29uc3QgbWF0Y2ggPSBjb21wYXJhdG9yKGl0ZW0sIHZhbHVlKTtcbiAgICBpZiAobWF0Y2ggPT09IDApIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09PSAtMSkge1xuICAgICAgaWYgKGVuZCAtIHN0YXJ0IDwgMikge1xuICAgICAgICByZXR1cm4gaW5kZXggLSAxO1xuICAgICAgfVxuICAgICAgZW5kID0gaW5kZXggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBzdGFydCA9IGluZGV4ICsgMTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYmluYXJ5IGZpbmRpbmcgcmVjb3JkIGluIGFycmF5IC0gJHtpdGVtcy5qb2luKFwiLFwiKX0sIHNlYXJjaGVkIGZvciAke3ZhbHVlfWApO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3RTbWFsbGVyT3JFcXVhbChpdGVtcywgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgcmV0dXJuIGl0ZW1zW2ZpbmRJbmRleE9mQ2xvc2VzdFNtYWxsZXJPckVxdWFsKGl0ZW1zLCB2YWx1ZSwgY29tcGFyYXRvcildO1xufVxuZnVuY3Rpb24gZmluZFJhbmdlKGl0ZW1zLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgY29tcGFyYXRvcikge1xuICBjb25zdCBzdGFydEluZGV4ID0gZmluZEluZGV4T2ZDbG9zZXN0U21hbGxlck9yRXF1YWwoaXRlbXMsIHN0YXJ0VmFsdWUsIGNvbXBhcmF0b3IpO1xuICBjb25zdCBlbmRJbmRleCA9IGZpbmRJbmRleE9mQ2xvc2VzdFNtYWxsZXJPckVxdWFsKGl0ZW1zLCBlbmRWYWx1ZSwgY29tcGFyYXRvciwgc3RhcnRJbmRleCk7XG4gIHJldHVybiBpdGVtcy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCArIDEpO1xufVxuY29uc3QgcmVjYWxjU3lzdGVtID0gc3lzdGVtKFxuICAoKSA9PiB7XG4gICAgY29uc3QgcmVjYWxjSW5Qcm9ncmVzcyA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICByZXR1cm4geyByZWNhbGNJblByb2dyZXNzIH07XG4gIH0sXG4gIFtdLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuZnVuY3Rpb24gcmFuZ2VJbmNsdWRlcyhyZWZSYW5nZSkge1xuICBjb25zdCB7IHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByZWZSYW5nZTtcbiAgcmV0dXJuIChyYW5nZSkgPT4ge1xuICAgIHJldHVybiByYW5nZS5zdGFydCA9PT0gc3RhcnRJbmRleCAmJiAocmFuZ2UuZW5kID09PSBlbmRJbmRleCB8fCByYW5nZS5lbmQgPT09IEluZmluaXR5KSAmJiByYW5nZS52YWx1ZSA9PT0gc2l6ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFmZmVjdGVkR3JvdXBDb3VudChvZmZzZXQsIGdyb3VwSW5kaWNlcykge1xuICBsZXQgcmVjb2duaXplZE9mZnNldEl0ZW1zID0gMDtcbiAgbGV0IGdyb3VwSW5kZXggPSAwO1xuICB3aGlsZSAocmVjb2duaXplZE9mZnNldEl0ZW1zIDwgb2Zmc2V0KSB7XG4gICAgcmVjb2duaXplZE9mZnNldEl0ZW1zICs9IGdyb3VwSW5kaWNlc1tncm91cEluZGV4ICsgMV0gLSBncm91cEluZGljZXNbZ3JvdXBJbmRleF0gLSAxO1xuICAgIGdyb3VwSW5kZXgrKztcbiAgfVxuICBjb25zdCBvZmZzZXRJc0V4YWN0ID0gcmVjb2duaXplZE9mZnNldEl0ZW1zID09PSBvZmZzZXQ7XG4gIHJldHVybiBncm91cEluZGV4IC0gKG9mZnNldElzRXhhY3QgPyAwIDogMSk7XG59XG5mdW5jdGlvbiBpbnNlcnRSYW5nZXMoc2l6ZVRyZWUsIHJhbmdlcykge1xuICBsZXQgc3luY1N0YXJ0ID0gZW1wdHkoc2l6ZVRyZWUpID8gMCA6IEluZmluaXR5O1xuICBmb3IgKGNvbnN0IHJhbmdlIG9mIHJhbmdlcykge1xuICAgIGNvbnN0IHsgc2l6ZSwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIHN5bmNTdGFydCA9IE1hdGgubWluKHN5bmNTdGFydCwgc3RhcnRJbmRleCk7XG4gICAgaWYgKGVtcHR5KHNpemVUcmVlKSkge1xuICAgICAgc2l6ZVRyZWUgPSBpbnNlcnQoc2l6ZVRyZWUsIDAsIHNpemUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXBwaW5nUmFuZ2VzID0gcmFuZ2VzV2l0aGluKHNpemVUcmVlLCBzdGFydEluZGV4IC0gMSwgZW5kSW5kZXggKyAxKTtcbiAgICBpZiAob3ZlcmxhcHBpbmdSYW5nZXMuc29tZShyYW5nZUluY2x1ZGVzKHJhbmdlKSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgZmlyc3RQYXNzRG9uZSA9IGZhbHNlO1xuICAgIGxldCBzaG91bGRJbnNlcnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHsgc3RhcnQ6IHJhbmdlU3RhcnQsIGVuZDogcmFuZ2VFbmQsIHZhbHVlOiByYW5nZVZhbHVlIH0gb2Ygb3ZlcmxhcHBpbmdSYW5nZXMpIHtcbiAgICAgIGlmICghZmlyc3RQYXNzRG9uZSkge1xuICAgICAgICBzaG91bGRJbnNlcnQgPSByYW5nZVZhbHVlICE9PSBzaXplO1xuICAgICAgICBmaXJzdFBhc3NEb25lID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbmRJbmRleCA+PSByYW5nZVN0YXJ0IHx8IHNpemUgPT09IHJhbmdlVmFsdWUpIHtcbiAgICAgICAgICBzaXplVHJlZSA9IHJlbW92ZShzaXplVHJlZSwgcmFuZ2VTdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYW5nZUVuZCA+IGVuZEluZGV4ICYmIGVuZEluZGV4ID49IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgaWYgKHJhbmdlVmFsdWUgIT09IHNpemUpIHtcbiAgICAgICAgICBzaXplVHJlZSA9IGluc2VydChzaXplVHJlZSwgZW5kSW5kZXggKyAxLCByYW5nZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkSW5zZXJ0KSB7XG4gICAgICBzaXplVHJlZSA9IGluc2VydChzaXplVHJlZSwgc3RhcnRJbmRleCwgc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbc2l6ZVRyZWUsIHN5bmNTdGFydF07XG59XG5mdW5jdGlvbiBpbml0aWFsU2l6ZVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIG9mZnNldFRyZWU6IFtdLFxuICAgIHNpemVUcmVlOiBuZXdUcmVlKCksXG4gICAgZ3JvdXBPZmZzZXRUcmVlOiBuZXdUcmVlKCksXG4gICAgbGFzdEluZGV4OiAwLFxuICAgIGxhc3RPZmZzZXQ6IDAsXG4gICAgbGFzdFNpemU6IDAsXG4gICAgZ3JvdXBJbmRpY2VzOiBbXVxuICB9O1xufVxuZnVuY3Rpb24gaW5kZXhDb21wYXJhdG9yKHsgaW5kZXg6IGl0ZW1JbmRleCB9LCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPT09IGl0ZW1JbmRleCA/IDAgOiBpbmRleCA8IGl0ZW1JbmRleCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIG9mZnNldENvbXBhcmF0b3IoeyBvZmZzZXQ6IGl0ZW1PZmZzZXQgfSwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXQgPT09IGl0ZW1PZmZzZXQgPyAwIDogb2Zmc2V0IDwgaXRlbU9mZnNldCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIG9mZnNldFBvaW50UGFyc2VyKHBvaW50KSB7XG4gIHJldHVybiB7IGluZGV4OiBwb2ludC5pbmRleCwgdmFsdWU6IHBvaW50IH07XG59XG5mdW5jdGlvbiByYW5nZXNXaXRoaW5PZmZzZXRzKHRyZWUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIG1pblN0YXJ0SW5kZXggPSAwKSB7XG4gIGlmIChtaW5TdGFydEluZGV4ID4gMCkge1xuICAgIHN0YXJ0T2Zmc2V0ID0gTWF0aC5tYXgoc3RhcnRPZmZzZXQsIGZpbmRDbG9zZXN0U21hbGxlck9yRXF1YWwodHJlZSwgbWluU3RhcnRJbmRleCwgaW5kZXhDb21wYXJhdG9yKS5vZmZzZXQpO1xuICB9XG4gIHJldHVybiBhcnJheVRvUmFuZ2VzKGZpbmRSYW5nZSh0cmVlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBvZmZzZXRDb21wYXJhdG9yKSwgb2Zmc2V0UG9pbnRQYXJzZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlT2Zmc2V0VHJlZShwcmV2T2Zmc2V0VHJlZSwgc3luY1N0YXJ0LCBzaXplVHJlZSwgZ2FwKSB7XG4gIGxldCBvZmZzZXRUcmVlID0gcHJldk9mZnNldFRyZWU7XG4gIGxldCBwcmV2SW5kZXggPSAwO1xuICBsZXQgcHJldlNpemUgPSAwO1xuICBsZXQgcHJldk9mZnNldCA9IDA7XG4gIGxldCBzdGFydEluZGV4ID0gMDtcbiAgaWYgKHN5bmNTdGFydCAhPT0gMCkge1xuICAgIHN0YXJ0SW5kZXggPSBmaW5kSW5kZXhPZkNsb3Nlc3RTbWFsbGVyT3JFcXVhbChvZmZzZXRUcmVlLCBzeW5jU3RhcnQgLSAxLCBpbmRleENvbXBhcmF0b3IpO1xuICAgIGNvbnN0IG9mZnNldEluZm8gPSBvZmZzZXRUcmVlW3N0YXJ0SW5kZXhdO1xuICAgIHByZXZPZmZzZXQgPSBvZmZzZXRJbmZvLm9mZnNldDtcbiAgICBjb25zdCBrdiA9IGZpbmRNYXhLZXlWYWx1ZShzaXplVHJlZSwgc3luY1N0YXJ0IC0gMSk7XG4gICAgcHJldkluZGV4ID0ga3ZbMF07XG4gICAgcHJldlNpemUgPSBrdlsxXTtcbiAgICBpZiAob2Zmc2V0VHJlZS5sZW5ndGggJiYgb2Zmc2V0VHJlZVtzdGFydEluZGV4XS5zaXplID09PSBmaW5kTWF4S2V5VmFsdWUoc2l6ZVRyZWUsIHN5bmNTdGFydClbMV0pIHtcbiAgICAgIHN0YXJ0SW5kZXggLT0gMTtcbiAgICB9XG4gICAgb2Zmc2V0VHJlZSA9IG9mZnNldFRyZWUuc2xpY2UoMCwgc3RhcnRJbmRleCArIDEpO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldFRyZWUgPSBbXTtcbiAgfVxuICBmb3IgKGNvbnN0IHsgc3RhcnQ6IHN0YXJ0SW5kZXgyLCB2YWx1ZSB9IG9mIHJhbmdlc1dpdGhpbihzaXplVHJlZSwgc3luY1N0YXJ0LCBJbmZpbml0eSkpIHtcbiAgICBjb25zdCBpbmRleE9mZnNldCA9IHN0YXJ0SW5kZXgyIC0gcHJldkluZGV4O1xuICAgIGNvbnN0IGFPZmZzZXQgPSBpbmRleE9mZnNldCAqIHByZXZTaXplICsgcHJldk9mZnNldCArIGluZGV4T2Zmc2V0ICogZ2FwO1xuICAgIG9mZnNldFRyZWUucHVzaCh7XG4gICAgICBvZmZzZXQ6IGFPZmZzZXQsXG4gICAgICBzaXplOiB2YWx1ZSxcbiAgICAgIGluZGV4OiBzdGFydEluZGV4MlxuICAgIH0pO1xuICAgIHByZXZJbmRleCA9IHN0YXJ0SW5kZXgyO1xuICAgIHByZXZPZmZzZXQgPSBhT2Zmc2V0O1xuICAgIHByZXZTaXplID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvZmZzZXRUcmVlLFxuICAgIGxhc3RJbmRleDogcHJldkluZGV4LFxuICAgIGxhc3RPZmZzZXQ6IHByZXZPZmZzZXQsXG4gICAgbGFzdFNpemU6IHByZXZTaXplXG4gIH07XG59XG5mdW5jdGlvbiBzaXplU3RhdGVSZWR1Y2VyKHN0YXRlLCBbcmFuZ2VzLCBncm91cEluZGljZXMsIGxvZywgZ2FwXSkge1xuICBpZiAocmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICBsb2coXCJyZWNlaXZlZCBpdGVtIHNpemVzXCIsIHJhbmdlcywgTG9nTGV2ZWwuREVCVUcpO1xuICB9XG4gIGNvbnN0IHNpemVUcmVlID0gc3RhdGUuc2l6ZVRyZWU7XG4gIGxldCBuZXdTaXplVHJlZSA9IHNpemVUcmVlO1xuICBsZXQgc3luY1N0YXJ0ID0gMDtcbiAgaWYgKGdyb3VwSW5kaWNlcy5sZW5ndGggPiAwICYmIGVtcHR5KHNpemVUcmVlKSAmJiByYW5nZXMubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgZ3JvdXBTaXplID0gcmFuZ2VzWzBdLnNpemU7XG4gICAgY29uc3QgaXRlbVNpemUgPSByYW5nZXNbMV0uc2l6ZTtcbiAgICBuZXdTaXplVHJlZSA9IGdyb3VwSW5kaWNlcy5yZWR1Y2UoKHRyZWUsIGdyb3VwSW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBpbnNlcnQoaW5zZXJ0KHRyZWUsIGdyb3VwSW5kZXgsIGdyb3VwU2l6ZSksIGdyb3VwSW5kZXggKyAxLCBpdGVtU2l6ZSk7XG4gICAgfSwgbmV3U2l6ZVRyZWUpO1xuICB9IGVsc2Uge1xuICAgIFtuZXdTaXplVHJlZSwgc3luY1N0YXJ0XSA9IGluc2VydFJhbmdlcyhuZXdTaXplVHJlZSwgcmFuZ2VzKTtcbiAgfVxuICBpZiAobmV3U2l6ZVRyZWUgPT09IHNpemVUcmVlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGNvbnN0IHsgb2Zmc2V0VHJlZTogbmV3T2Zmc2V0VHJlZSwgbGFzdEluZGV4LCBsYXN0U2l6ZSwgbGFzdE9mZnNldCB9ID0gY3JlYXRlT2Zmc2V0VHJlZShzdGF0ZS5vZmZzZXRUcmVlLCBzeW5jU3RhcnQsIG5ld1NpemVUcmVlLCBnYXApO1xuICByZXR1cm4ge1xuICAgIHNpemVUcmVlOiBuZXdTaXplVHJlZSxcbiAgICBvZmZzZXRUcmVlOiBuZXdPZmZzZXRUcmVlLFxuICAgIGxhc3RJbmRleCxcbiAgICBsYXN0T2Zmc2V0LFxuICAgIGxhc3RTaXplLFxuICAgIGdyb3VwT2Zmc2V0VHJlZTogZ3JvdXBJbmRpY2VzLnJlZHVjZSgodHJlZSwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBpbnNlcnQodHJlZSwgaW5kZXgsIG9mZnNldE9mKGluZGV4LCBuZXdPZmZzZXRUcmVlLCBnYXApKTtcbiAgICB9LCBuZXdUcmVlKCkpLFxuICAgIGdyb3VwSW5kaWNlc1xuICB9O1xufVxuZnVuY3Rpb24gb2Zmc2V0T2YoaW5kZXgsIHRyZWUsIGdhcCkge1xuICBpZiAodHJlZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCB7IG9mZnNldCwgaW5kZXg6IHN0YXJ0SW5kZXgsIHNpemUgfSA9IGZpbmRDbG9zZXN0U21hbGxlck9yRXF1YWwodHJlZSwgaW5kZXgsIGluZGV4Q29tcGFyYXRvcik7XG4gIGNvbnN0IGl0ZW1Db3VudCA9IGluZGV4IC0gc3RhcnRJbmRleDtcbiAgY29uc3QgdG9wID0gc2l6ZSAqIGl0ZW1Db3VudCArIChpdGVtQ291bnQgLSAxKSAqIGdhcCArIG9mZnNldDtcbiAgcmV0dXJuIHRvcCA+IDAgPyB0b3AgKyBnYXAgOiB0b3A7XG59XG5mdW5jdGlvbiBpc0dyb3VwTG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbi5ncm91cEluZGV4ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gb3JpZ2luYWxJbmRleEZyb21Mb2NhdGlvbihsb2NhdGlvbiwgc2l6ZXMsIGxhc3RJbmRleCkge1xuICBpZiAoaXNHcm91cExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgIHJldHVybiBzaXplcy5ncm91cEluZGljZXNbbG9jYXRpb24uZ3JvdXBJbmRleF0gKyAxO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG51bWVyaWNJbmRleCA9IGxvY2F0aW9uLmluZGV4ID09PSBcIkxBU1RcIiA/IGxhc3RJbmRleCA6IGxvY2F0aW9uLmluZGV4O1xuICAgIGxldCByZXN1bHQgPSBvcmlnaW5hbEluZGV4RnJvbUl0ZW1JbmRleChudW1lcmljSW5kZXgsIHNpemVzKTtcbiAgICByZXN1bHQgPSBNYXRoLm1heCgwLCByZXN1bHQsIE1hdGgubWluKGxhc3RJbmRleCwgcmVzdWx0KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gb3JpZ2luYWxJbmRleEZyb21JdGVtSW5kZXgoaXRlbUluZGV4LCBzaXplcykge1xuICBpZiAoIWhhc0dyb3VwcyhzaXplcykpIHtcbiAgICByZXR1cm4gaXRlbUluZGV4O1xuICB9XG4gIGxldCBncm91cE9mZnNldCA9IDA7XG4gIHdoaWxlIChzaXplcy5ncm91cEluZGljZXNbZ3JvdXBPZmZzZXRdIDw9IGl0ZW1JbmRleCArIGdyb3VwT2Zmc2V0KSB7XG4gICAgZ3JvdXBPZmZzZXQrKztcbiAgfVxuICByZXR1cm4gaXRlbUluZGV4ICsgZ3JvdXBPZmZzZXQ7XG59XG5mdW5jdGlvbiBoYXNHcm91cHMoc2l6ZXMpIHtcbiAgcmV0dXJuICFlbXB0eShzaXplcy5ncm91cE9mZnNldFRyZWUpO1xufVxuZnVuY3Rpb24gc2l6ZVRyZWVUb1JhbmdlcyhzaXplVHJlZSkge1xuICByZXR1cm4gd2FsayhzaXplVHJlZSkubWFwKCh7IGs6IHN0YXJ0SW5kZXgsIHY6IHNpemUgfSwgaW5kZXgsIHNpemVBcnJheSkgPT4ge1xuICAgIGNvbnN0IG5leHRTaXplID0gc2l6ZUFycmF5W2luZGV4ICsgMV07XG4gICAgY29uc3QgZW5kSW5kZXggPSBuZXh0U2l6ZSA/IG5leHRTaXplLmsgLSAxIDogSW5maW5pdHk7XG4gICAgcmV0dXJuIHsgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNpemUgfTtcbiAgfSk7XG59XG5jb25zdCBTSVpFX01BUCA9IHtcbiAgb2Zmc2V0SGVpZ2h0OiBcImhlaWdodFwiLFxuICBvZmZzZXRXaWR0aDogXCJ3aWR0aFwiXG59O1xuY29uc3Qgc2l6ZVN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IGxvZyB9LCB7IHJlY2FsY0luUHJvZ3Jlc3MgfV0pID0+IHtcbiAgICBjb25zdCBzaXplUmFuZ2VzID0gc3RyZWFtKCk7XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHN0YXRlZnVsVG90YWxDb3VudCA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIodG90YWxDb3VudCwgMCk7XG4gICAgY29uc3QgdW5zaGlmdFdpdGggPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzaGlmdFdpdGggPSBzdHJlYW0oKTtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGdyb3VwSW5kaWNlcyA9IHN0YXRlZnVsU3RyZWFtKFtdKTtcbiAgICBjb25zdCBmaXhlZEl0ZW1TaXplID0gc3RhdGVmdWxTdHJlYW0odm9pZCAwKTtcbiAgICBjb25zdCBkZWZhdWx0SXRlbVNpemUgPSBzdGF0ZWZ1bFN0cmVhbSh2b2lkIDApO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gc3RhdGVmdWxTdHJlYW0oKGVsLCBmaWVsZCkgPT4gY29ycmVjdEl0ZW1TaXplKGVsLCBTSVpFX01BUFtmaWVsZF0pKTtcbiAgICBjb25zdCBkYXRhID0gc3RhdGVmdWxTdHJlYW0odm9pZCAwKTtcbiAgICBjb25zdCBnYXAgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBpbml0aWFsID0gaW5pdGlhbFNpemVTdGF0ZSgpO1xuICAgIGNvbnN0IHNpemVzID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoc2l6ZVJhbmdlcywgd2l0aExhdGVzdEZyb20oZ3JvdXBJbmRpY2VzLCBsb2csIGdhcCksIHNjYW4oc2l6ZVN0YXRlUmVkdWNlciwgaW5pdGlhbCksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLFxuICAgICAgaW5pdGlhbFxuICAgICk7XG4gICAgY29uc3QgcHJldkdyb3VwSW5kaWNlcyA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBncm91cEluZGljZXMsXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgIHNjYW4oKHByZXYsIGN1cnIpID0+ICh7IHByZXY6IHByZXYuY3VycmVudCwgY3VycmVudDogY3VyciB9KSwge1xuICAgICAgICAgIHByZXY6IFtdLFxuICAgICAgICAgIGN1cnJlbnQ6IFtdXG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKHsgcHJldiB9KSA9PiBwcmV2KVxuICAgICAgKSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgZ3JvdXBJbmRpY2VzLFxuICAgICAgICBmaWx0ZXIoKGluZGV4ZXMpID0+IGluZGV4ZXMubGVuZ3RoID4gMCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNpemVzLCBnYXApLFxuICAgICAgICBtYXAoKFtncm91cEluZGljZXMyLCBzaXplczIsIGdhcDJdKSA9PiB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBPZmZzZXRUcmVlID0gZ3JvdXBJbmRpY2VzMi5yZWR1Y2UoKHRyZWUsIGluZGV4LCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQodHJlZSwgaW5kZXgsIG9mZnNldE9mKGluZGV4LCBzaXplczIub2Zmc2V0VHJlZSwgZ2FwMikgfHwgaWR4KTtcbiAgICAgICAgICB9LCBuZXdUcmVlKCkpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zaXplczIsXG4gICAgICAgICAgICBncm91cEluZGljZXM6IGdyb3VwSW5kaWNlczIsXG4gICAgICAgICAgICBncm91cE9mZnNldFRyZWVcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNpemVzXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgdG90YWxDb3VudCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMpLFxuICAgICAgICBmaWx0ZXIoKFt0b3RhbENvdW50MiwgeyBsYXN0SW5kZXggfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4gdG90YWxDb3VudDIgPCBsYXN0SW5kZXg7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKFt0b3RhbENvdW50MiwgeyBsYXN0SW5kZXgsIGxhc3RTaXplIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhcnRJbmRleDogdG90YWxDb3VudDIsXG4gICAgICAgICAgICAgIGVuZEluZGV4OiBsYXN0SW5kZXgsXG4gICAgICAgICAgICAgIHNpemU6IGxhc3RTaXplXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBzaXplUmFuZ2VzXG4gICAgKTtcbiAgICBjb25uZWN0KGZpeGVkSXRlbVNpemUsIGRlZmF1bHRJdGVtU2l6ZSk7XG4gICAgY29uc3QgdHJhY2tJdGVtU2l6ZXMgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgZml4ZWRJdGVtU2l6ZSxcbiAgICAgICAgbWFwKChzaXplKSA9PiBzaXplID09PSB2b2lkIDApXG4gICAgICApLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRlZmF1bHRJdGVtU2l6ZSxcbiAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwICYmIGVtcHR5KGdldFZhbHVlKHNpemVzKS5zaXplVHJlZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKHNpemUpID0+IFt7IHN0YXJ0SW5kZXg6IDAsIGVuZEluZGV4OiAwLCBzaXplIH1dKVxuICAgICAgKSxcbiAgICAgIHNpemVSYW5nZXNcbiAgICApO1xuICAgIGNvbnN0IGxpc3RSZWZyZXNoID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBzaXplUmFuZ2VzLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcyksXG4gICAgICAgIHNjYW4oXG4gICAgICAgICAgKHsgc2l6ZXM6IG9sZFNpemVzIH0sIFtfLCBuZXdTaXplc10pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNoYW5nZWQ6IG5ld1NpemVzICE9PSBvbGRTaXplcyxcbiAgICAgICAgICAgICAgc2l6ZXM6IG5ld1NpemVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBjaGFuZ2VkOiBmYWxzZSwgc2l6ZXM6IGluaXRpYWwgfVxuICAgICAgICApLFxuICAgICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS5jaGFuZ2VkKVxuICAgICAgKVxuICAgICk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgZmlyc3RJdGVtSW5kZXgsXG4gICAgICAgIHNjYW4oXG4gICAgICAgICAgKHByZXYsIG5leHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGRpZmY6IHByZXYucHJldiAtIG5leHQsIHByZXY6IG5leHQgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgZGlmZjogMCwgcHJldjogMCB9XG4gICAgICAgICksXG4gICAgICAgIG1hcCgodmFsKSA9PiB2YWwuZGlmZilcbiAgICAgICksXG4gICAgICAob2Zmc2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ3JvdXBJbmRpY2VzOiBncm91cEluZGljZXMyIH0gPSBnZXRWYWx1ZShzaXplcyk7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgcHVibGlzaChyZWNhbGNJblByb2dyZXNzLCB0cnVlKTtcbiAgICAgICAgICBwdWJsaXNoKHVuc2hpZnRXaXRoLCBvZmZzZXQgKyBhZmZlY3RlZEdyb3VwQ291bnQob2Zmc2V0LCBncm91cEluZGljZXMyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIGNvbnN0IHByZXZHcm91cEluZGljZXNWYWx1ZSA9IGdldFZhbHVlKHByZXZHcm91cEluZGljZXMpO1xuICAgICAgICAgIGlmIChwcmV2R3JvdXBJbmRpY2VzVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb2Zmc2V0IC09IGFmZmVjdGVkR3JvdXBDb3VudCgtb2Zmc2V0LCBwcmV2R3JvdXBJbmRpY2VzVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdWJsaXNoKHNoaWZ0V2l0aCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgc3Vic2NyaWJlKHBpcGUoZmlyc3RJdGVtSW5kZXgsIHdpdGhMYXRlc3RGcm9tKGxvZykpLCAoW2luZGV4LCBsb2cyXSkgPT4ge1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBsb2cyKFxuICAgICAgICAgIFwiYGZpcnN0SXRlbUluZGV4YCBwcm9wIHNob3VsZCBub3QgYmUgc2V0IHRvIGxlc3MgdGhhbiB6ZXJvLiBJZiB5b3UgZG9uJ3Qga25vdyB0aGUgdG90YWwgY291bnQsIGp1c3QgdXNlIGEgdmVyeSBoaWdoIHZhbHVlXCIsXG4gICAgICAgICAgeyBmaXJzdEl0ZW1JbmRleCB9LFxuICAgICAgICAgIExvZ0xldmVsLkVSUk9SXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYmVmb3JlVW5zaGlmdFdpdGggPSBzdHJlYW1Gcm9tRW1pdHRlcih1bnNoaWZ0V2l0aCk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHVuc2hpZnRXaXRoLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcyksXG4gICAgICAgIG1hcCgoW3Vuc2hpZnRXaXRoMiwgc2l6ZXMyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGdyb3VwZWRNb2RlID0gc2l6ZXMyLmdyb3VwSW5kaWNlcy5sZW5ndGggPiAwO1xuICAgICAgICAgIGNvbnN0IGluaXRpYWxSYW5nZXMgPSBbXTtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0U2l6ZSA9IHNpemVzMi5sYXN0U2l6ZTtcbiAgICAgICAgICBpZiAoZ3JvdXBlZE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0R3JvdXBTaXplID0gZmluZChzaXplczIuc2l6ZVRyZWUsIDApO1xuICAgICAgICAgICAgbGV0IHByZXBlbmRlZEdyb3VwSXRlbXNDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZ3JvdXBJbmRleCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocHJlcGVuZGVkR3JvdXBJdGVtc0NvdW50IDwgdW5zaGlmdFdpdGgyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRoZUdyb3VwSW5kZXggPSBzaXplczIuZ3JvdXBJbmRpY2VzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBncm91cEl0ZW1Db3VudCA9IHNpemVzMi5ncm91cEluZGljZXMubGVuZ3RoID09PSBncm91cEluZGV4ICsgMSA/IEluZmluaXR5IDogc2l6ZXMyLmdyb3VwSW5kaWNlc1tncm91cEluZGV4ICsgMV0gLSB0aGVHcm91cEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgaW5pdGlhbFJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiB0aGVHcm91cEluZGV4LFxuICAgICAgICAgICAgICAgIGVuZEluZGV4OiB0aGVHcm91cEluZGV4LFxuICAgICAgICAgICAgICAgIHNpemU6IGZpcnN0R3JvdXBTaXplXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpbml0aWFsUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHRoZUdyb3VwSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgIGVuZEluZGV4OiB0aGVHcm91cEluZGV4ICsgMSArIGdyb3VwSXRlbUNvdW50IC0gMSxcbiAgICAgICAgICAgICAgICBzaXplOiBkZWZhdWx0U2l6ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrO1xuICAgICAgICAgICAgICBwcmVwZW5kZWRHcm91cEl0ZW1zQ291bnQgKz0gZ3JvdXBJdGVtQ291bnQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZVRyZWVLViA9IHdhbGsoc2l6ZXMyLnNpemVUcmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0R3JvdXBJc0V4cGFuZGVkID0gcHJlcGVuZGVkR3JvdXBJdGVtc0NvdW50ICE9PSB1bnNoaWZ0V2l0aDI7XG4gICAgICAgICAgICBpZiAoZmlyc3RHcm91cElzRXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgc2l6ZVRyZWVLVi5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpemVUcmVlS1YucmVkdWNlKFxuICAgICAgICAgICAgICAoYWNjLCB7IGs6IGluZGV4LCB2OiBzaXplIH0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gYWNjLnJhbmdlcztcbiAgICAgICAgICAgICAgICBpZiAoYWNjLnByZXZTaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICByYW5nZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmFjYy5yYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBhY2MucHJldkluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4OiBpbmRleCArIHVuc2hpZnRXaXRoMiAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZTogYWNjLnByZXZTaXplXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICByYW5nZXMsXG4gICAgICAgICAgICAgICAgICBwcmV2SW5kZXg6IGluZGV4ICsgdW5zaGlmdFdpdGgyLFxuICAgICAgICAgICAgICAgICAgcHJldlNpemU6IHNpemVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzOiBpbml0aWFsUmFuZ2VzLFxuICAgICAgICAgICAgICAgIHByZXZJbmRleDogdW5zaGlmdFdpdGgyLFxuICAgICAgICAgICAgICAgIHByZXZTaXplOiAwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkucmFuZ2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd2FsayhzaXplczIuc2l6ZVRyZWUpLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIHsgazogaW5kZXgsIHY6IHNpemUgfSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJhbmdlczogWy4uLmFjYy5yYW5nZXMsIHsgc3RhcnRJbmRleDogYWNjLnByZXZJbmRleCwgZW5kSW5kZXg6IGluZGV4ICsgdW5zaGlmdFdpdGgyIC0gMSwgc2l6ZTogYWNjLnByZXZTaXplIH1dLFxuICAgICAgICAgICAgICAgIHByZXZJbmRleDogaW5kZXggKyB1bnNoaWZ0V2l0aDIsXG4gICAgICAgICAgICAgICAgcHJldlNpemU6IHNpemVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJhbmdlczogW10sXG4gICAgICAgICAgICAgIHByZXZJbmRleDogMCxcbiAgICAgICAgICAgICAgcHJldlNpemU6IGRlZmF1bHRTaXplXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKS5yYW5nZXM7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2l6ZVJhbmdlc1xuICAgICk7XG4gICAgY29uc3Qgc2hpZnRXaXRoT2Zmc2V0ID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBzaGlmdFdpdGgsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNpemVzLCBnYXApLFxuICAgICAgICBtYXAoKFtzaGlmdFdpdGgyLCB7IG9mZnNldFRyZWUgfSwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdGaXJzdEl0ZW1JbmRleCA9IC1zaGlmdFdpdGgyO1xuICAgICAgICAgIHJldHVybiBvZmZzZXRPZihuZXdGaXJzdEl0ZW1JbmRleCwgb2Zmc2V0VHJlZSwgZ2FwMik7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2hpZnRXaXRoLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgZ2FwKSxcbiAgICAgICAgbWFwKChbc2hpZnRXaXRoMiwgc2l6ZXMyLCBnYXAyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGdyb3VwZWRNb2RlID0gc2l6ZXMyLmdyb3VwSW5kaWNlcy5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChncm91cGVkTW9kZSkge1xuICAgICAgICAgICAgaWYgKGVtcHR5KHNpemVzMi5zaXplVHJlZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpemVzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTaXplVHJlZSA9IG5ld1RyZWUoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZHcm91cEluZGljZXNWYWx1ZSA9IGdldFZhbHVlKHByZXZHcm91cEluZGljZXMpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWRJdGVtc0NvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBncm91cEluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBncm91cE9mZnNldCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocmVtb3ZlZEl0ZW1zQ291bnQgPCAtc2hpZnRXaXRoMikge1xuICAgICAgICAgICAgICBncm91cE9mZnNldCA9IHByZXZHcm91cEluZGljZXNWYWx1ZVtncm91cEluZGV4XTtcbiAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJdGVtQ291bnQgPSBwcmV2R3JvdXBJbmRpY2VzVmFsdWVbZ3JvdXBJbmRleCArIDFdIC0gZ3JvdXBPZmZzZXQgLSAxO1xuICAgICAgICAgICAgICBncm91cEluZGV4Kys7XG4gICAgICAgICAgICAgIHJlbW92ZWRJdGVtc0NvdW50ICs9IGdyb3VwSXRlbUNvdW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1NpemVUcmVlID0gd2FsayhzaXplczIuc2l6ZVRyZWUpLnJlZHVjZSgoYWNjLCB7IGssIHYgfSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0KGFjYywgTWF0aC5tYXgoMCwgayArIHNoaWZ0V2l0aDIpLCB2KTtcbiAgICAgICAgICAgIH0sIG5ld1NpemVUcmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGFHcm91cElzU2hydW5rID0gcmVtb3ZlZEl0ZW1zQ291bnQgIT09IC1zaGlmdFdpdGgyO1xuICAgICAgICAgICAgaWYgKGFHcm91cElzU2hydW5rKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0R3JvdXBTaXplID0gZmluZChzaXplczIuc2l6ZVRyZWUsIGdyb3VwT2Zmc2V0KTtcbiAgICAgICAgICAgICAgbmV3U2l6ZVRyZWUgPSBpbnNlcnQobmV3U2l6ZVRyZWUsIDAsIGZpcnN0R3JvdXBTaXplKTtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEl0ZW1TaXplID0gZmluZE1heEtleVZhbHVlKHNpemVzMi5zaXplVHJlZSwgLXNoaWZ0V2l0aDIgKyAxKVsxXTtcbiAgICAgICAgICAgICAgbmV3U2l6ZVRyZWUgPSBpbnNlcnQobmV3U2l6ZVRyZWUsIDEsIG5leHRJdGVtU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zaXplczIsXG4gICAgICAgICAgICAgIHNpemVUcmVlOiBuZXdTaXplVHJlZSxcbiAgICAgICAgICAgICAgLi4uY3JlYXRlT2Zmc2V0VHJlZShzaXplczIub2Zmc2V0VHJlZSwgMCwgbmV3U2l6ZVRyZWUsIGdhcDIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTaXplVHJlZSA9IHdhbGsoc2l6ZXMyLnNpemVUcmVlKS5yZWR1Y2UoKGFjYywgeyBrLCB2IH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluc2VydChhY2MsIE1hdGgubWF4KDAsIGsgKyBzaGlmdFdpdGgyKSwgdik7XG4gICAgICAgICAgICB9LCBuZXdUcmVlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc2l6ZXMyLFxuICAgICAgICAgICAgICBzaXplVHJlZTogbmV3U2l6ZVRyZWUsXG4gICAgICAgICAgICAgIC4uLmNyZWF0ZU9mZnNldFRyZWUoc2l6ZXMyLm9mZnNldFRyZWUsIDAsIG5ld1NpemVUcmVlLCBnYXAyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2l6ZXNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgZGF0YSxcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgICBzaXplUmFuZ2VzLFxuICAgICAgZ3JvdXBJbmRpY2VzLFxuICAgICAgZGVmYXVsdEl0ZW1TaXplLFxuICAgICAgZml4ZWRJdGVtU2l6ZSxcbiAgICAgIHVuc2hpZnRXaXRoLFxuICAgICAgc2hpZnRXaXRoLFxuICAgICAgc2hpZnRXaXRoT2Zmc2V0LFxuICAgICAgYmVmb3JlVW5zaGlmdFdpdGgsXG4gICAgICBmaXJzdEl0ZW1JbmRleCxcbiAgICAgIGdhcCxcbiAgICAgIC8vIG91dHB1dFxuICAgICAgc2l6ZXMsXG4gICAgICBsaXN0UmVmcmVzaCxcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudCxcbiAgICAgIHRyYWNrSXRlbVNpemVzLFxuICAgICAgaXRlbVNpemVcbiAgICB9O1xuICB9LFxuICB0dXAobG9nZ2VyU3lzdGVtLCByZWNhbGNTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3QgU1VQUE9SVFNfU0NST0xMX1RPX09QVElPTlMgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJzY3JvbGxCZWhhdmlvclwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUluZGV4TG9jYXRpb24obG9jYXRpb24pIHtcbiAgY29uc3QgcmVzdWx0ID0gdHlwZW9mIGxvY2F0aW9uID09PSBcIm51bWJlclwiID8geyBpbmRleDogbG9jYXRpb24gfSA6IGxvY2F0aW9uO1xuICBpZiAoIXJlc3VsdC5hbGlnbikge1xuICAgIHJlc3VsdC5hbGlnbiA9IFwic3RhcnRcIjtcbiAgfVxuICBpZiAoIXJlc3VsdC5iZWhhdmlvciB8fCAhU1VQUE9SVFNfU0NST0xMX1RPX09QVElPTlMpIHtcbiAgICByZXN1bHQuYmVoYXZpb3IgPSBcImF1dG9cIjtcbiAgfVxuICBpZiAoIXJlc3VsdC5vZmZzZXQpIHtcbiAgICByZXN1bHQub2Zmc2V0ID0gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgc2Nyb2xsVG9JbmRleFN5c3RlbSA9IHN5c3RlbShcbiAgKFtcbiAgICB7IHNpemVzLCB0b3RhbENvdW50LCBsaXN0UmVmcmVzaCwgZ2FwIH0sXG4gICAge1xuICAgICAgc2Nyb2xsaW5nSW5Qcm9ncmVzcyxcbiAgICAgIHZpZXdwb3J0SGVpZ2h0LFxuICAgICAgc2Nyb2xsVG8sXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkLFxuICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgZm9vdGVySGVpZ2h0LFxuICAgICAgZml4ZWRIZWFkZXJIZWlnaHQsXG4gICAgICBmaXhlZEZvb3RlckhlaWdodFxuICAgIH0sXG4gICAgeyBsb2cgfVxuICBdKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsVG9JbmRleCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHRvcExpc3RIZWlnaHQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBsZXQgdW5zdWJzY3JpYmVOZXh0TGlzdFJlZnJlc2ggPSBudWxsO1xuICAgIGxldCBjbGVhcnRUaW1lb3V0UmVmID0gbnVsbDtcbiAgICBsZXQgdW5zdWJzY3JpYmVMaXN0UmVmcmVzaCA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIGlmICh1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCkge1xuICAgICAgICB1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCgpO1xuICAgICAgICB1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodW5zdWJzY3JpYmVMaXN0UmVmcmVzaCkge1xuICAgICAgICB1bnN1YnNjcmliZUxpc3RSZWZyZXNoKCk7XG4gICAgICAgIHVuc3Vic2NyaWJlTGlzdFJlZnJlc2ggPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNsZWFydFRpbWVvdXRSZWYpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsZWFydFRpbWVvdXRSZWYpO1xuICAgICAgICBjbGVhcnRUaW1lb3V0UmVmID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHB1Ymxpc2goc2Nyb2xsaW5nSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgIH1cbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMsIHZpZXdwb3J0SGVpZ2h0LCB0b3RhbENvdW50LCB0b3BMaXN0SGVpZ2h0LCBoZWFkZXJIZWlnaHQsIGZvb3RlckhlaWdodCwgbG9nKSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oZ2FwLCBmaXhlZEhlYWRlckhlaWdodCwgZml4ZWRGb290ZXJIZWlnaHQpLFxuICAgICAgICBtYXAoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgIFtsb2NhdGlvbiwgc2l6ZXMyLCB2aWV3cG9ydEhlaWdodDIsIHRvdGFsQ291bnQyLCB0b3BMaXN0SGVpZ2h0MiwgaGVhZGVySGVpZ2h0MiwgZm9vdGVySGVpZ2h0MiwgbG9nMl0sXG4gICAgICAgICAgICBnYXAyLFxuICAgICAgICAgICAgZml4ZWRIZWFkZXJIZWlnaHQyLFxuICAgICAgICAgICAgZml4ZWRGb290ZXJIZWlnaHQyXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsTG9jYXRpb24gPSBub3JtYWxpemVJbmRleExvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYWxpZ24sIGJlaGF2aW9yLCBvZmZzZXQgfSA9IG5vcm1hbExvY2F0aW9uO1xuICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gdG90YWxDb3VudDIgLSAxO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvcmlnaW5hbEluZGV4RnJvbUxvY2F0aW9uKG5vcm1hbExvY2F0aW9uLCBzaXplczIsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gb2Zmc2V0T2YoaW5kZXgsIHNpemVzMi5vZmZzZXRUcmVlLCBnYXAyKSArIGhlYWRlckhlaWdodDI7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgdG9wICs9IGZpeGVkSGVhZGVySGVpZ2h0MiArIGZpbmRNYXhLZXlWYWx1ZShzaXplczIuc2l6ZVRyZWUsIGluZGV4KVsxXSAtIHZpZXdwb3J0SGVpZ2h0MiArIGZpeGVkRm9vdGVySGVpZ2h0MjtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0b3AgKz0gZm9vdGVySGVpZ2h0MjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgICB0b3AgKz0gKGZpeGVkSGVhZGVySGVpZ2h0MiArIGZpbmRNYXhLZXlWYWx1ZShzaXplczIuc2l6ZVRyZWUsIGluZGV4KVsxXSAtIHZpZXdwb3J0SGVpZ2h0MiArIGZpeGVkRm9vdGVySGVpZ2h0MikgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9wIC09IHRvcExpc3RIZWlnaHQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgICB0b3AgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0cnkgPSAobGlzdENoYW5nZWQpID0+IHtcbiAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICBpZiAobGlzdENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsb2cyKFwicmV0cnlpbmcgdG8gc2Nyb2xsIHRvXCIsIHsgbG9jYXRpb24gfSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsVG9JbmRleCwgbG9jYXRpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZzIoXCJsaXN0IGRpZCBub3QgY2hhbmdlLCBzY3JvbGwgc3VjY2Vzc2Z1bFwiLCB7fSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiKSB7XG4gICAgICAgICAgICAgIGxldCBsaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bnN1YnNjcmliZUxpc3RSZWZyZXNoID0gc3Vic2NyaWJlKGxpc3RSZWZyZXNoLCAoY2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RDaGFuZ2VkID0gbGlzdENoYW5nZWQgfHwgY2hhbmdlZDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHVuc3Vic2NyaWJlTmV4dExpc3RSZWZyZXNoID0gaGFuZGxlTmV4dChzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0cnkobGlzdENoYW5nZWQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuc3Vic2NyaWJlTmV4dExpc3RSZWZyZXNoID0gaGFuZGxlTmV4dChwaXBlKGxpc3RSZWZyZXNoLCB3YXRjaENoYW5nZXNGb3IoMTUwKSksIHJldHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFydFRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgfSwgMTIwMCk7XG4gICAgICAgICAgICBwdWJsaXNoKHNjcm9sbGluZ0luUHJvZ3Jlc3MsIHRydWUpO1xuICAgICAgICAgICAgbG9nMihcInNjcm9sbGluZyBmcm9tIGluZGV4IHRvXCIsIHsgaW5kZXgsIHRvcCwgYmVoYXZpb3IgfSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdG9wLCBiZWhhdmlvciB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIHNjcm9sbFRvXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgIHRvcExpc3RIZWlnaHRcbiAgICB9O1xuICB9LFxuICB0dXAoc2l6ZVN5c3RlbSwgZG9tSU9TeXN0ZW0sIGxvZ2dlclN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiB3YXRjaENoYW5nZXNGb3IobGltaXQpIHtcbiAgcmV0dXJuIChkb25lKSA9PiB7XG4gICAgY29uc3QgdGltZW91dFJlZiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9uZShmYWxzZSk7XG4gICAgfSwgbGltaXQpO1xuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkb25lKHRydWUpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbmNvbnN0IFVQID0gXCJ1cFwiO1xuY29uc3QgRE9XTiA9IFwiZG93blwiO1xuY29uc3QgTk9ORSQxID0gXCJub25lXCI7XG5jb25zdCBJTklUSUFMX0JPVFRPTV9TVEFURSA9IHtcbiAgYXRCb3R0b206IGZhbHNlLFxuICBub3RBdEJvdHRvbUJlY2F1c2U6IFwiTk9UX1NIT1dJTkdfTEFTVF9JVEVNXCIsXG4gIHN0YXRlOiB7XG4gICAgb2Zmc2V0Qm90dG9tOiAwLFxuICAgIHNjcm9sbFRvcDogMCxcbiAgICB2aWV3cG9ydEhlaWdodDogMCxcbiAgICBzY3JvbGxIZWlnaHQ6IDBcbiAgfVxufTtcbmNvbnN0IERFRkFVTFRfQVRfVE9QX1RIUkVTSE9MRCA9IDA7XG5jb25zdCBzdGF0ZUZsYWdzU3lzdGVtID0gc3lzdGVtKChbeyBzY3JvbGxDb250YWluZXJTdGF0ZSwgc2Nyb2xsVG9wLCB2aWV3cG9ydEhlaWdodCwgaGVhZGVySGVpZ2h0LCBmb290ZXJIZWlnaHQsIHNjcm9sbEJ5IH1dKSA9PiB7XG4gIGNvbnN0IGlzQXRCb3R0b20gPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gIGNvbnN0IGlzQXRUb3AgPSBzdGF0ZWZ1bFN0cmVhbSh0cnVlKTtcbiAgY29uc3QgYXRCb3R0b21TdGF0ZUNoYW5nZSA9IHN0cmVhbSgpO1xuICBjb25zdCBhdFRvcFN0YXRlQ2hhbmdlID0gc3RyZWFtKCk7XG4gIGNvbnN0IGF0Qm90dG9tVGhyZXNob2xkID0gc3RhdGVmdWxTdHJlYW0oNCk7XG4gIGNvbnN0IGF0VG9wVGhyZXNob2xkID0gc3RhdGVmdWxTdHJlYW0oREVGQVVMVF9BVF9UT1BfVEhSRVNIT0xEKTtcbiAgY29uc3QgaXNTY3JvbGxpbmcgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgIHBpcGUoXG4gICAgICBtZXJnZShwaXBlKGR1YyhzY3JvbGxUb3ApLCBza2lwKDEpLCBtYXBUbyh0cnVlKSksIHBpcGUoZHVjKHNjcm9sbFRvcCksIHNraXAoMSksIG1hcFRvKGZhbHNlKSwgZGVib3VuY2VUaW1lKDEwMCkpKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApLFxuICAgIGZhbHNlXG4gICk7XG4gIGNvbnN0IGlzU2Nyb2xsaW5nQnkgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgIHBpcGUobWVyZ2UocGlwZShzY3JvbGxCeSwgbWFwVG8odHJ1ZSkpLCBwaXBlKHNjcm9sbEJ5LCBtYXBUbyhmYWxzZSksIGRlYm91bmNlVGltZSgyMDApKSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLFxuICAgIGZhbHNlXG4gICk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGNvbWJpbmVMYXRlc3QoZHVjKHNjcm9sbFRvcCksIGR1YyhhdFRvcFRocmVzaG9sZCkpLFxuICAgICAgbWFwKChbdG9wLCBhdFRvcFRocmVzaG9sZDJdKSA9PiB0b3AgPD0gYXRUb3BUaHJlc2hvbGQyKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApLFxuICAgIGlzQXRUb3BcbiAgKTtcbiAgY29ubmVjdChwaXBlKGlzQXRUb3AsIHRocm90dGxlVGltZSg1MCkpLCBhdFRvcFN0YXRlQ2hhbmdlKTtcbiAgY29uc3QgYXRCb3R0b21TdGF0ZSA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgIHBpcGUoXG4gICAgICBjb21iaW5lTGF0ZXN0KHNjcm9sbENvbnRhaW5lclN0YXRlLCBkdWModmlld3BvcnRIZWlnaHQpLCBkdWMoaGVhZGVySGVpZ2h0KSwgZHVjKGZvb3RlckhlaWdodCksIGR1YyhhdEJvdHRvbVRocmVzaG9sZCkpLFxuICAgICAgc2NhbigoY3VycmVudCwgW3sgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyLCBzY3JvbGxIZWlnaHQgfSwgdmlld3BvcnRIZWlnaHQyLCBfaGVhZGVySGVpZ2h0LCBfZm9vdGVySGVpZ2h0LCBhdEJvdHRvbVRocmVzaG9sZDJdKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzQXRCb3R0b20yID0gc2Nyb2xsVG9wMiArIHZpZXdwb3J0SGVpZ2h0MiAtIHNjcm9sbEhlaWdodCA+IC1hdEJvdHRvbVRocmVzaG9sZDI7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0OiB2aWV3cG9ydEhlaWdodDIsXG4gICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyLFxuICAgICAgICAgIHNjcm9sbEhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNBdEJvdHRvbTIpIHtcbiAgICAgICAgICBsZXQgYXRCb3R0b21CZWNhdXNlO1xuICAgICAgICAgIGxldCBzY3JvbGxUb3BEZWx0YTtcbiAgICAgICAgICBpZiAoc2Nyb2xsVG9wMiA+IGN1cnJlbnQuc3RhdGUuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBhdEJvdHRvbUJlY2F1c2UgPSBcIlNDUk9MTEVEX0RPV05cIjtcbiAgICAgICAgICAgIHNjcm9sbFRvcERlbHRhID0gY3VycmVudC5zdGF0ZS5zY3JvbGxUb3AgLSBzY3JvbGxUb3AyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdEJvdHRvbUJlY2F1c2UgPSBcIlNJWkVfREVDUkVBU0VEXCI7XG4gICAgICAgICAgICBzY3JvbGxUb3BEZWx0YSA9IGN1cnJlbnQuc3RhdGUuc2Nyb2xsVG9wIC0gc2Nyb2xsVG9wMiB8fCBjdXJyZW50LnNjcm9sbFRvcERlbHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXRCb3R0b206IHRydWUsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGF0Qm90dG9tQmVjYXVzZSxcbiAgICAgICAgICAgIHNjcm9sbFRvcERlbHRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm90QXRCb3R0b21CZWNhdXNlO1xuICAgICAgICBpZiAoc3RhdGUuc2Nyb2xsSGVpZ2h0ID4gY3VycmVudC5zdGF0ZS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgICBub3RBdEJvdHRvbUJlY2F1c2UgPSBcIlNJWkVfSU5DUkVBU0VEXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodmlld3BvcnRIZWlnaHQyIDwgY3VycmVudC5zdGF0ZS52aWV3cG9ydEhlaWdodCkge1xuICAgICAgICAgIG5vdEF0Qm90dG9tQmVjYXVzZSA9IFwiVklFV1BPUlRfSEVJR0hUX0RFQ1JFQVNJTkdcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AyIDwgY3VycmVudC5zdGF0ZS5zY3JvbGxUb3ApIHtcbiAgICAgICAgICBub3RBdEJvdHRvbUJlY2F1c2UgPSBcIlNDUk9MTElOR19VUFdBUkRTXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90QXRCb3R0b21CZWNhdXNlID0gXCJOT1RfRlVMTFlfU0NST0xMRURfVE9fTEFTVF9JVEVNX0JPVFRPTVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXRCb3R0b206IGZhbHNlLFxuICAgICAgICAgIG5vdEF0Qm90dG9tQmVjYXVzZSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICB9O1xuICAgICAgfSwgSU5JVElBTF9CT1RUT01fU1RBVEUpLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKHByZXYsIG5leHQpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXYgJiYgcHJldi5hdEJvdHRvbSA9PT0gbmV4dC5hdEJvdHRvbTtcbiAgICAgIH0pXG4gICAgKVxuICApO1xuICBjb25zdCBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZSA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgcGlwZShcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlLFxuICAgICAgc2NhbihcbiAgICAgICAgKGN1cnJlbnQsIHsgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyLCBzY3JvbGxIZWlnaHQsIHZpZXdwb3J0SGVpZ2h0OiB2aWV3cG9ydEhlaWdodDIgfSkgPT4ge1xuICAgICAgICAgIGlmICghYXBwcm94aW1hdGVseUVxdWFsKGN1cnJlbnQuc2Nyb2xsSGVpZ2h0LCBzY3JvbGxIZWlnaHQpKSB7XG4gICAgICAgICAgICBjb25zdCBhdEJvdHRvbSA9IHNjcm9sbEhlaWdodCAtIChzY3JvbGxUb3AyICsgdmlld3BvcnRIZWlnaHQyKSA8IDE7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5zY3JvbGxUb3AgIT09IHNjcm9sbFRvcDIgJiYgYXRCb3R0b20pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyLFxuICAgICAgICAgICAgICAgIGp1bXA6IGN1cnJlbnQuc2Nyb2xsVG9wIC0gc2Nyb2xsVG9wMixcbiAgICAgICAgICAgICAgICBjaGFuZ2VkOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcDIsXG4gICAgICAgICAgICAgICAganVtcDogMCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VkOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wMixcbiAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICBqdW1wOiAwLFxuICAgICAgICAgICAgICBjaGFuZ2VkOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgc2Nyb2xsSGVpZ2h0OiAwLCBqdW1wOiAwLCBzY3JvbGxUb3A6IDAsIGNoYW5nZWQ6IGZhbHNlIH1cbiAgICAgICksXG4gICAgICBmaWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZS5jaGFuZ2VkKSxcbiAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLmp1bXApXG4gICAgKSxcbiAgICAwXG4gICk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGF0Qm90dG9tU3RhdGUsXG4gICAgICBtYXAoKHN0YXRlKSA9PiBzdGF0ZS5hdEJvdHRvbSlcbiAgICApLFxuICAgIGlzQXRCb3R0b21cbiAgKTtcbiAgY29ubmVjdChwaXBlKGlzQXRCb3R0b20sIHRocm90dGxlVGltZSg1MCkpLCBhdEJvdHRvbVN0YXRlQ2hhbmdlKTtcbiAgY29uc3Qgc2Nyb2xsRGlyZWN0aW9uID0gc3RhdGVmdWxTdHJlYW0oRE9XTik7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlLFxuICAgICAgbWFwKCh7IHNjcm9sbFRvcDogc2Nyb2xsVG9wMiB9KSA9PiBzY3JvbGxUb3AyKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBzY2FuKFxuICAgICAgICAoYWNjLCBzY3JvbGxUb3AyKSA9PiB7XG4gICAgICAgICAgaWYgKGdldFZhbHVlKGlzU2Nyb2xsaW5nQnkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkaXJlY3Rpb246IGFjYy5kaXJlY3Rpb24sIHByZXZTY3JvbGxUb3A6IHNjcm9sbFRvcDIgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgZGlyZWN0aW9uOiBzY3JvbGxUb3AyIDwgYWNjLnByZXZTY3JvbGxUb3AgPyBVUCA6IERPV04sIHByZXZTY3JvbGxUb3A6IHNjcm9sbFRvcDIgfTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBkaXJlY3Rpb246IERPV04sIHByZXZTY3JvbGxUb3A6IDAgfVxuICAgICAgKSxcbiAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLmRpcmVjdGlvbilcbiAgICApLFxuICAgIHNjcm9sbERpcmVjdGlvblxuICApO1xuICBjb25uZWN0KHBpcGUoc2Nyb2xsQ29udGFpbmVyU3RhdGUsIHRocm90dGxlVGltZSg1MCksIG1hcFRvKE5PTkUkMSkpLCBzY3JvbGxEaXJlY3Rpb24pO1xuICBjb25zdCBzY3JvbGxWZWxvY2l0eSA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBpc1Njcm9sbGluZyxcbiAgICAgIGZpbHRlcigodmFsdWUpID0+ICF2YWx1ZSksXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgbWFwVG8oMClcbiAgICApLFxuICAgIHNjcm9sbFZlbG9jaXR5XG4gICk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIHNjcm9sbFRvcCxcbiAgICAgIHRocm90dGxlVGltZSgxMDApLFxuICAgICAgd2l0aExhdGVzdEZyb20oaXNTY3JvbGxpbmcpLFxuICAgICAgZmlsdGVyKChbXywgaXNTY3JvbGxpbmcyXSkgPT4gISFpc1Njcm9sbGluZzIpLFxuICAgICAgc2NhbigoW18sIHByZXZdLCBbbmV4dF0pID0+IFtwcmV2LCBuZXh0XSwgWzAsIDBdKSxcbiAgICAgIG1hcCgoW3ByZXYsIG5leHRdKSA9PiBuZXh0IC0gcHJldilcbiAgICApLFxuICAgIHNjcm9sbFZlbG9jaXR5XG4gICk7XG4gIHJldHVybiB7XG4gICAgaXNTY3JvbGxpbmcsXG4gICAgaXNBdFRvcCxcbiAgICBpc0F0Qm90dG9tLFxuICAgIGF0Qm90dG9tU3RhdGUsXG4gICAgYXRUb3BTdGF0ZUNoYW5nZSxcbiAgICBhdEJvdHRvbVN0YXRlQ2hhbmdlLFxuICAgIHNjcm9sbERpcmVjdGlvbixcbiAgICBhdEJvdHRvbVRocmVzaG9sZCxcbiAgICBhdFRvcFRocmVzaG9sZCxcbiAgICBzY3JvbGxWZWxvY2l0eSxcbiAgICBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZVxuICB9O1xufSwgdHVwKGRvbUlPU3lzdGVtKSk7XG5jb25zdCBwcm9wc1JlYWR5U3lzdGVtID0gc3lzdGVtKFxuICAoW3sgbG9nIH1dKSA9PiB7XG4gICAgY29uc3QgcHJvcHNSZWFkeSA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25zdCBkaWRNb3VudCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgcHJvcHNSZWFkeSxcbiAgICAgICAgZmlsdGVyKChyZWFkeSkgPT4gcmVhZHkpLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApXG4gICAgKTtcbiAgICBzdWJzY3JpYmUocHJvcHNSZWFkeSwgKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZSAmJiBnZXRWYWx1ZShsb2cpKFwicHJvcHMgdXBkYXRlZFwiLCB7fSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb3BzUmVhZHksIGRpZE1vdW50IH07XG4gIH0sXG4gIHR1cChsb2dnZXJTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuZnVuY3Rpb24gc2tpcEZyYW1lcyhmcmFtZUNvdW50LCBjYWxsYmFjaykge1xuICBpZiAoZnJhbWVDb3VudCA9PSAwKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc2tpcEZyYW1lcyhmcmFtZUNvdW50IC0gMSwgY2FsbGJhY2spKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhOdW1iZXIobG9jYXRpb24sIHRvdGFsQ291bnQpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gdG90YWxDb3VudCAtIDE7XG4gIGNvbnN0IGluZGV4ID0gdHlwZW9mIGxvY2F0aW9uID09PSBcIm51bWJlclwiID8gbG9jYXRpb24gOiBsb2NhdGlvbi5pbmRleCA9PT0gXCJMQVNUXCIgPyBsYXN0SW5kZXggOiBsb2NhdGlvbi5pbmRleDtcbiAgcmV0dXJuIGluZGV4O1xufVxuY29uc3QgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBzaXplcywgbGlzdFJlZnJlc2gsIGRlZmF1bHRJdGVtU2l6ZSB9LCB7IHNjcm9sbFRvcCB9LCB7IHNjcm9sbFRvSW5kZXggfSwgeyBkaWRNb3VudCB9XSkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbGVkVG9Jbml0aWFsSXRlbSA9IHN0YXRlZnVsU3RyZWFtKHRydWUpO1xuICAgIGNvbnN0IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgc2Nyb2xsU2NoZWR1bGVkID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBkaWRNb3VudCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgpLFxuICAgICAgICBmaWx0ZXIoKFtfLCBsb2NhdGlvbl0pID0+ICEhbG9jYXRpb24pLFxuICAgICAgICBtYXBUbyhmYWxzZSlcbiAgICAgICksXG4gICAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW1cbiAgICApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QobGlzdFJlZnJlc2gsIGRpZE1vdW50KSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCBzaXplcywgZGVmYXVsdEl0ZW1TaXplLCBzY3JvbGxTY2hlZHVsZWQpLFxuICAgICAgICBmaWx0ZXIoKFtbLCBkaWRNb3VudDJdLCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yLCB7IHNpemVUcmVlIH0sIGRlZmF1bHRJdGVtU2l6ZTIsIHNjcm9sbFNjaGVkdWxlZDJdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRpZE1vdW50MiAmJiAoIWVtcHR5KHNpemVUcmVlKSB8fCBpc0RlZmluZWQoZGVmYXVsdEl0ZW1TaXplMikpICYmICFzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yICYmICFzY3JvbGxTY2hlZHVsZWQyO1xuICAgICAgICB9KSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgpXG4gICAgICApLFxuICAgICAgKFssIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4Ml0pID0+IHtcbiAgICAgICAgcHVibGlzaChzY3JvbGxTY2hlZHVsZWQsIHRydWUpO1xuICAgICAgICBza2lwRnJhbWVzKDMsICgpID0+IHtcbiAgICAgICAgICBoYW5kbGVOZXh0KHNjcm9sbFRvcCwgKCkgPT4gcHVibGlzaChzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sIHRydWUpKTtcbiAgICAgICAgICBwdWJsaXNoKHNjcm9sbFRvSW5kZXgsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4Mik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSxcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4XG4gICAgfTtcbiAgfSxcbiAgdHVwKHNpemVTeXN0ZW0sIGRvbUlPU3lzdGVtLCBzY3JvbGxUb0luZGV4U3lzdGVtLCBwcm9wc1JlYWR5U3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUZvbGxvd091dHB1dChmb2xsb3cpIHtcbiAgaWYgKCFmb2xsb3cpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZvbGxvdyA9PT0gXCJzbW9vdGhcIiA/IFwic21vb3RoXCIgOiBcImF1dG9cIjtcbn1cbmNvbnN0IGJlaGF2aW9yRnJvbUZvbGxvd091dHB1dCA9IChmb2xsb3csIGlzQXRCb3R0b20pID0+IHtcbiAgaWYgKHR5cGVvZiBmb2xsb3cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBub3JtYWxpemVGb2xsb3dPdXRwdXQoZm9sbG93KGlzQXRCb3R0b20pKTtcbiAgfVxuICByZXR1cm4gaXNBdEJvdHRvbSAmJiBub3JtYWxpemVGb2xsb3dPdXRwdXQoZm9sbG93KTtcbn07XG5jb25zdCBmb2xsb3dPdXRwdXRTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgeyB0b3RhbENvdW50LCBsaXN0UmVmcmVzaCB9LFxuICAgIHsgaXNBdEJvdHRvbSwgYXRCb3R0b21TdGF0ZSB9LFxuICAgIHsgc2Nyb2xsVG9JbmRleCB9LFxuICAgIHsgc2Nyb2xsZWRUb0luaXRpYWxJdGVtIH0sXG4gICAgeyBwcm9wc1JlYWR5LCBkaWRNb3VudCB9LFxuICAgIHsgbG9nIH0sXG4gICAgeyBzY3JvbGxpbmdJblByb2dyZXNzIH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IGZvbGxvd091dHB1dCA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25zdCBhdXRvc2Nyb2xsVG9Cb3R0b20gPSBzdHJlYW0oKTtcbiAgICBsZXQgcGVuZGluZ1Njcm9sbEhhbmRsZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gc2Nyb2xsVG9Cb3R0b20oZm9sbG93T3V0cHV0QmVoYXZpb3IpIHtcbiAgICAgIHB1Ymxpc2goc2Nyb2xsVG9JbmRleCwge1xuICAgICAgICBpbmRleDogXCJMQVNUXCIsXG4gICAgICAgIGFsaWduOiBcImVuZFwiLFxuICAgICAgICBiZWhhdmlvcjogZm9sbG93T3V0cHV0QmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KHBpcGUoZHVjKHRvdGFsQ291bnQpLCBza2lwKDEpKSwgZGlkTW91bnQpLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShkdWMoZm9sbG93T3V0cHV0KSwgaXNBdEJvdHRvbSwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCBzY3JvbGxpbmdJblByb2dyZXNzKSxcbiAgICAgICAgbWFwKChbW3RvdGFsQ291bnQyLCBkaWRNb3VudDJdLCBmb2xsb3dPdXRwdXQyLCBpc0F0Qm90dG9tMiwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMiwgc2Nyb2xsaW5nSW5Qcm9ncmVzczJdKSA9PiB7XG4gICAgICAgICAgbGV0IHNob3VsZEZvbGxvdyA9IGRpZE1vdW50MiAmJiBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yO1xuICAgICAgICAgIGxldCBmb2xsb3dPdXRwdXRCZWhhdmlvciA9IFwiYXV0b1wiO1xuICAgICAgICAgIGlmIChzaG91bGRGb2xsb3cpIHtcbiAgICAgICAgICAgIGZvbGxvd091dHB1dEJlaGF2aW9yID0gYmVoYXZpb3JGcm9tRm9sbG93T3V0cHV0KGZvbGxvd091dHB1dDIsIGlzQXRCb3R0b20yIHx8IHNjcm9sbGluZ0luUHJvZ3Jlc3MyKTtcbiAgICAgICAgICAgIHNob3VsZEZvbGxvdyA9IHNob3VsZEZvbGxvdyAmJiAhIWZvbGxvd091dHB1dEJlaGF2aW9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyB0b3RhbENvdW50OiB0b3RhbENvdW50Miwgc2hvdWxkRm9sbG93LCBmb2xsb3dPdXRwdXRCZWhhdmlvciB9O1xuICAgICAgICB9KSxcbiAgICAgICAgZmlsdGVyKCh7IHNob3VsZEZvbGxvdyB9KSA9PiBzaG91bGRGb2xsb3cpXG4gICAgICApLFxuICAgICAgKHsgdG90YWxDb3VudDogdG90YWxDb3VudDIsIGZvbGxvd091dHB1dEJlaGF2aW9yIH0pID0+IHtcbiAgICAgICAgaWYgKHBlbmRpbmdTY3JvbGxIYW5kbGUpIHtcbiAgICAgICAgICBwZW5kaW5nU2Nyb2xsSGFuZGxlKCk7XG4gICAgICAgICAgcGVuZGluZ1Njcm9sbEhhbmRsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1Njcm9sbEhhbmRsZSA9IGhhbmRsZU5leHQobGlzdFJlZnJlc2gsICgpID0+IHtcbiAgICAgICAgICBnZXRWYWx1ZShsb2cpKFwiZm9sbG93aW5nIG91dHB1dCB0byBcIiwgeyB0b3RhbENvdW50OiB0b3RhbENvdW50MiB9LCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgICAgICAgc2Nyb2xsVG9Cb3R0b20oZm9sbG93T3V0cHV0QmVoYXZpb3IpO1xuICAgICAgICAgIHBlbmRpbmdTY3JvbGxIYW5kbGUgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIGZ1bmN0aW9uIHRyYXBOZXh0U2l6ZUluY3JlYXNlKGZvbGxvd091dHB1dDIpIHtcbiAgICAgIGNvbnN0IGNhbmNlbCA9IGhhbmRsZU5leHQoYXRCb3R0b21TdGF0ZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgIGlmIChmb2xsb3dPdXRwdXQyICYmICFzdGF0ZS5hdEJvdHRvbSAmJiBzdGF0ZS5ub3RBdEJvdHRvbUJlY2F1c2UgPT09IFwiU0laRV9JTkNSRUFTRURcIiAmJiAhcGVuZGluZ1Njcm9sbEhhbmRsZSkge1xuICAgICAgICAgIGdldFZhbHVlKGxvZykoXCJzY3JvbGxpbmcgdG8gYm90dG9tIGR1ZSB0byBpbmNyZWFzZWQgc2l6ZVwiLCB7fSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgICAgIHNjcm9sbFRvQm90dG9tKFwiYXV0b1wiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KGNhbmNlbCwgMTAwKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChkdWMoZm9sbG93T3V0cHV0KSwgdG90YWxDb3VudCwgcHJvcHNSZWFkeSksXG4gICAgICAgIGZpbHRlcigoW2ZvbGxvdywgLCByZWFkeV0pID0+IGZvbGxvdyAmJiByZWFkeSksXG4gICAgICAgIHNjYW4oXG4gICAgICAgICAgKHsgdmFsdWUgfSwgWywgbmV4dF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlZnJlc2hlZDogdmFsdWUgPT09IG5leHQsIHZhbHVlOiBuZXh0IH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IHJlZnJlc2hlZDogZmFsc2UsIHZhbHVlOiAwIH1cbiAgICAgICAgKSxcbiAgICAgICAgZmlsdGVyKCh7IHJlZnJlc2hlZCB9KSA9PiByZWZyZXNoZWQpLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShmb2xsb3dPdXRwdXQsIHRvdGFsQ291bnQpXG4gICAgICApLFxuICAgICAgKFssIGZvbGxvd091dHB1dDJdKSA9PiB7XG4gICAgICAgIHRyYXBOZXh0U2l6ZUluY3JlYXNlKGZvbGxvd091dHB1dDIgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHN1YnNjcmliZShhdXRvc2Nyb2xsVG9Cb3R0b20sICgpID0+IHtcbiAgICAgIHRyYXBOZXh0U2l6ZUluY3JlYXNlKGdldFZhbHVlKGZvbGxvd091dHB1dCkgIT09IGZhbHNlKTtcbiAgICB9KTtcbiAgICBzdWJzY3JpYmUoY29tYmluZUxhdGVzdChkdWMoZm9sbG93T3V0cHV0KSwgYXRCb3R0b21TdGF0ZSksIChbZm9sbG93T3V0cHV0Miwgc3RhdGVdKSA9PiB7XG4gICAgICBpZiAoZm9sbG93T3V0cHV0MiAmJiAhc3RhdGUuYXRCb3R0b20gJiYgc3RhdGUubm90QXRCb3R0b21CZWNhdXNlID09PSBcIlZJRVdQT1JUX0hFSUdIVF9ERUNSRUFTSU5HXCIpIHtcbiAgICAgICAgc2Nyb2xsVG9Cb3R0b20oXCJhdXRvXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IGZvbGxvd091dHB1dCwgYXV0b3Njcm9sbFRvQm90dG9tIH07XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBzdGF0ZUZsYWdzU3lzdGVtLCBzY3JvbGxUb0luZGV4U3lzdGVtLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFN5c3RlbSwgcHJvcHNSZWFkeVN5c3RlbSwgbG9nZ2VyU3lzdGVtLCBkb21JT1N5c3RlbSlcbik7XG5mdW5jdGlvbiBncm91cENvdW50c1RvSW5kaWNlc0FuZENvdW50KGNvdW50cykge1xuICByZXR1cm4gY291bnRzLnJlZHVjZShcbiAgICAoYWNjLCBncm91cENvdW50KSA9PiB7XG4gICAgICBhY2MuZ3JvdXBJbmRpY2VzLnB1c2goYWNjLnRvdGFsQ291bnQpO1xuICAgICAgYWNjLnRvdGFsQ291bnQgKz0gZ3JvdXBDb3VudCArIDE7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sXG4gICAge1xuICAgICAgdG90YWxDb3VudDogMCxcbiAgICAgIGdyb3VwSW5kaWNlczogW11cbiAgICB9XG4gICk7XG59XG5jb25zdCBncm91cGVkTGlzdFN5c3RlbSA9IHN5c3RlbSgoW3sgdG90YWxDb3VudCwgZ3JvdXBJbmRpY2VzLCBzaXplcyB9LCB7IHNjcm9sbFRvcCwgaGVhZGVySGVpZ2h0IH1dKSA9PiB7XG4gIGNvbnN0IGdyb3VwQ291bnRzID0gc3RyZWFtKCk7XG4gIGNvbnN0IHRvcEl0ZW1zSW5kZXhlcyA9IHN0cmVhbSgpO1xuICBjb25zdCBncm91cEluZGljZXNBbmRDb3VudCA9IHN0cmVhbUZyb21FbWl0dGVyKHBpcGUoZ3JvdXBDb3VudHMsIG1hcChncm91cENvdW50c1RvSW5kaWNlc0FuZENvdW50KSkpO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICBncm91cEluZGljZXNBbmRDb3VudCxcbiAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLnRvdGFsQ291bnQpXG4gICAgKSxcbiAgICB0b3RhbENvdW50XG4gICk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGdyb3VwSW5kaWNlc0FuZENvdW50LFxuICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUuZ3JvdXBJbmRpY2VzKVxuICAgICksXG4gICAgZ3JvdXBJbmRpY2VzXG4gICk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGNvbWJpbmVMYXRlc3Qoc2Nyb2xsVG9wLCBzaXplcywgaGVhZGVySGVpZ2h0KSxcbiAgICAgIGZpbHRlcigoW18sIHNpemVzMl0pID0+IGhhc0dyb3VwcyhzaXplczIpKSxcbiAgICAgIG1hcCgoW3Njcm9sbFRvcDIsIHN0YXRlLCBoZWFkZXJIZWlnaHQyXSkgPT4gZmluZE1heEtleVZhbHVlKHN0YXRlLmdyb3VwT2Zmc2V0VHJlZSwgTWF0aC5tYXgoc2Nyb2xsVG9wMiAtIGhlYWRlckhlaWdodDIsIDApLCBcInZcIilbMF0pLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIG1hcCgoaW5kZXgpID0+IFtpbmRleF0pXG4gICAgKSxcbiAgICB0b3BJdGVtc0luZGV4ZXNcbiAgKTtcbiAgcmV0dXJuIHsgZ3JvdXBDb3VudHMsIHRvcEl0ZW1zSW5kZXhlcyB9O1xufSwgdHVwKHNpemVTeXN0ZW0sIGRvbUlPU3lzdGVtKSk7XG5mdW5jdGlvbiB0dXBsZUNvbXBhcmF0b3IocHJldiwgY3VycmVudCkge1xuICByZXR1cm4gISEocHJldiAmJiBwcmV2WzBdID09PSBjdXJyZW50WzBdICYmIHByZXZbMV0gPT09IGN1cnJlbnRbMV0pO1xufVxuZnVuY3Rpb24gcmFuZ2VDb21wYXJhdG9yKHByZXYsIG5leHQpIHtcbiAgcmV0dXJuICEhKHByZXYgJiYgcHJldi5zdGFydEluZGV4ID09PSBuZXh0LnN0YXJ0SW5kZXggJiYgcHJldi5lbmRJbmRleCA9PT0gbmV4dC5lbmRJbmRleCk7XG59XG5jb25zdCBUT1AgPSBcInRvcFwiO1xuY29uc3QgQk9UVE9NID0gXCJib3R0b21cIjtcbmNvbnN0IE5PTkUgPSBcIm5vbmVcIjtcbmZ1bmN0aW9uIGdldE92ZXJzY2FuKG92ZXJzY2FuLCBlbmQsIGRpcmVjdGlvbikge1xuICBpZiAodHlwZW9mIG92ZXJzY2FuID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gVVAgJiYgZW5kID09PSBUT1AgfHwgZGlyZWN0aW9uID09PSBET1dOICYmIGVuZCA9PT0gQk9UVE9NID8gb3ZlcnNjYW4gOiAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFVQKSB7XG4gICAgICByZXR1cm4gZW5kID09PSBUT1AgPyBvdmVyc2Nhbi5tYWluIDogb3ZlcnNjYW4ucmV2ZXJzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVuZCA9PT0gQk9UVE9NID8gb3ZlcnNjYW4ubWFpbiA6IG92ZXJzY2FuLnJldmVyc2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRWaWV3cG9ydEluY3JlYXNlKHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbZW5kXSB8fCAwO1xufVxuY29uc3Qgc2l6ZVJhbmdlU3lzdGVtID0gc3lzdGVtKFxuICAoW3sgc2Nyb2xsVG9wLCB2aWV3cG9ydEhlaWdodCwgZGV2aWF0aW9uLCBoZWFkZXJIZWlnaHQsIGZpeGVkSGVhZGVySGVpZ2h0IH1dKSA9PiB7XG4gICAgY29uc3QgbGlzdEJvdW5kYXJ5ID0gc3RyZWFtKCk7XG4gICAgY29uc3QgdG9wTGlzdEhlaWdodCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGluY3JlYXNlVmlld3BvcnRCeSA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IG92ZXJzY2FuID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgdmlzaWJsZVJhbmdlID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QoXG4gICAgICAgICAgZHVjKHNjcm9sbFRvcCksXG4gICAgICAgICAgZHVjKHZpZXdwb3J0SGVpZ2h0KSxcbiAgICAgICAgICBkdWMoaGVhZGVySGVpZ2h0KSxcbiAgICAgICAgICBkdWMobGlzdEJvdW5kYXJ5LCB0dXBsZUNvbXBhcmF0b3IpLFxuICAgICAgICAgIGR1YyhvdmVyc2NhbiksXG4gICAgICAgICAgZHVjKHRvcExpc3RIZWlnaHQpLFxuICAgICAgICAgIGR1YyhmaXhlZEhlYWRlckhlaWdodCksXG4gICAgICAgICAgZHVjKGRldmlhdGlvbiksXG4gICAgICAgICAgZHVjKGluY3JlYXNlVmlld3BvcnRCeSlcbiAgICAgICAgKSxcbiAgICAgICAgbWFwKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICBzY3JvbGxUb3AyLFxuICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQyLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0MixcbiAgICAgICAgICAgIFtsaXN0VG9wLCBsaXN0Qm90dG9tXSxcbiAgICAgICAgICAgIG92ZXJzY2FuMixcbiAgICAgICAgICAgIHRvcExpc3RIZWlnaHQyLFxuICAgICAgICAgICAgZml4ZWRIZWFkZXJIZWlnaHQyLFxuICAgICAgICAgICAgZGV2aWF0aW9uMixcbiAgICAgICAgICAgIGluY3JlYXNlVmlld3BvcnRCeTJcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBzY3JvbGxUb3AyIC0gZGV2aWF0aW9uMjtcbiAgICAgICAgICAgIGNvbnN0IHN0aWNreUhlYWRlckhlaWdodCA9IHRvcExpc3RIZWlnaHQyICsgZml4ZWRIZWFkZXJIZWlnaHQyO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyVmlzaWJsZSA9IE1hdGgubWF4KGhlYWRlckhlaWdodDIgLSB0b3AsIDApO1xuICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IE5PTkU7XG4gICAgICAgICAgICBjb25zdCB0b3BWaWV3cG9ydEFkZGl0aW9uID0gZ2V0Vmlld3BvcnRJbmNyZWFzZShpbmNyZWFzZVZpZXdwb3J0QnkyLCBUT1ApO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tVmlld3BvcnRBZGRpdGlvbiA9IGdldFZpZXdwb3J0SW5jcmVhc2UoaW5jcmVhc2VWaWV3cG9ydEJ5MiwgQk9UVE9NKTtcbiAgICAgICAgICAgIGxpc3RUb3AgLT0gZGV2aWF0aW9uMjtcbiAgICAgICAgICAgIGxpc3RUb3AgKz0gaGVhZGVySGVpZ2h0MiArIGZpeGVkSGVhZGVySGVpZ2h0MjtcbiAgICAgICAgICAgIGxpc3RCb3R0b20gKz0gaGVhZGVySGVpZ2h0MiArIGZpeGVkSGVhZGVySGVpZ2h0MjtcbiAgICAgICAgICAgIGxpc3RCb3R0b20gLT0gZGV2aWF0aW9uMjtcbiAgICAgICAgICAgIGlmIChsaXN0VG9wID4gc2Nyb2xsVG9wMiArIHN0aWNreUhlYWRlckhlaWdodCAtIHRvcFZpZXdwb3J0QWRkaXRpb24pIHtcbiAgICAgICAgICAgICAgZGlyZWN0aW9uID0gVVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlzdEJvdHRvbSA8IHNjcm9sbFRvcDIgLSBoZWFkZXJWaXNpYmxlICsgdmlld3BvcnRIZWlnaHQyICsgYm90dG9tVmlld3BvcnRBZGRpdGlvbikge1xuICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBET1dOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gTk9ORSkge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIE1hdGgubWF4KHRvcCAtIGhlYWRlckhlaWdodDIgLSBnZXRPdmVyc2NhbihvdmVyc2NhbjIsIFRPUCwgZGlyZWN0aW9uKSAtIHRvcFZpZXdwb3J0QWRkaXRpb24sIDApLFxuICAgICAgICAgICAgICAgIHRvcCAtIGhlYWRlclZpc2libGUgLSBmaXhlZEhlYWRlckhlaWdodDIgKyB2aWV3cG9ydEhlaWdodDIgKyBnZXRPdmVyc2NhbihvdmVyc2NhbjIsIEJPVFRPTSwgZGlyZWN0aW9uKSArIGJvdHRvbVZpZXdwb3J0QWRkaXRpb25cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKHR1cGxlQ29tcGFyYXRvcilcbiAgICAgICksXG4gICAgICBbMCwgMF1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgbGlzdEJvdW5kYXJ5LFxuICAgICAgb3ZlcnNjYW4sXG4gICAgICB0b3BMaXN0SGVpZ2h0LFxuICAgICAgaW5jcmVhc2VWaWV3cG9ydEJ5LFxuICAgICAgLy8gb3V0cHV0XG4gICAgICB2aXNpYmxlUmFuZ2VcbiAgICB9O1xuICB9LFxuICB0dXAoZG9tSU9TeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuZnVuY3Rpb24gcHJvYmVJdGVtU2V0KGluZGV4LCBzaXplcywgZGF0YSkge1xuICBpZiAoaGFzR3JvdXBzKHNpemVzKSkge1xuICAgIGNvbnN0IGl0ZW1JbmRleCA9IG9yaWdpbmFsSW5kZXhGcm9tSXRlbUluZGV4KGluZGV4LCBzaXplcyk7XG4gICAgY29uc3QgZ3JvdXBJbmRleCA9IGZpbmRNYXhLZXlWYWx1ZShzaXplcy5ncm91cE9mZnNldFRyZWUsIGl0ZW1JbmRleClbMF07XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgaW5kZXg6IGdyb3VwSW5kZXgsIHNpemU6IDAsIG9mZnNldDogMCB9LFxuICAgICAgeyBpbmRleDogaXRlbUluZGV4LCBzaXplOiAwLCBvZmZzZXQ6IDAsIGRhdGE6IGRhdGEgJiYgZGF0YVswXSB9XG4gICAgXTtcbiAgfVxuICByZXR1cm4gW3sgaW5kZXgsIHNpemU6IDAsIG9mZnNldDogMCwgZGF0YTogZGF0YSAmJiBkYXRhWzBdIH1dO1xufVxuY29uc3QgRU1QVFlfTElTVF9TVEFURSA9IHtcbiAgaXRlbXM6IFtdLFxuICB0b3BJdGVtczogW10sXG4gIG9mZnNldFRvcDogMCxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICB0b3A6IDAsXG4gIGJvdHRvbTogMCxcbiAgdG9wTGlzdEhlaWdodDogMCxcbiAgdG90YWxDb3VudDogMCxcbiAgZmlyc3RJdGVtSW5kZXg6IDBcbn07XG5mdW5jdGlvbiB0cmFuc3Bvc2VJdGVtcyhpdGVtcywgc2l6ZXMsIGZpcnN0SXRlbUluZGV4KSB7XG4gIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFoYXNHcm91cHMoc2l6ZXMpKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4gKHsgLi4uaXRlbSwgaW5kZXg6IGl0ZW0uaW5kZXggKyBmaXJzdEl0ZW1JbmRleCwgb3JpZ2luYWxJbmRleDogaXRlbS5pbmRleCB9KSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRJbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICBjb25zdCBlbmRJbmRleCA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLmluZGV4O1xuICBjb25zdCB0cmFuc3Bvc2VkSXRlbXMgPSBbXTtcbiAgY29uc3QgZ3JvdXBSYW5nZXMgPSByYW5nZXNXaXRoaW4oc2l6ZXMuZ3JvdXBPZmZzZXRUcmVlLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIGxldCBjdXJyZW50UmFuZ2UgPSB2b2lkIDA7XG4gIGxldCBjdXJyZW50R3JvdXBJbmRleCA9IDA7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgIGlmICghY3VycmVudFJhbmdlIHx8IGN1cnJlbnRSYW5nZS5lbmQgPCBpdGVtLmluZGV4KSB7XG4gICAgICBjdXJyZW50UmFuZ2UgPSBncm91cFJhbmdlcy5zaGlmdCgpO1xuICAgICAgY3VycmVudEdyb3VwSW5kZXggPSBzaXplcy5ncm91cEluZGljZXMuaW5kZXhPZihjdXJyZW50UmFuZ2Uuc3RhcnQpO1xuICAgIH1cbiAgICBsZXQgdHJhbnNwb3NlZEl0ZW07XG4gICAgaWYgKGl0ZW0uaW5kZXggPT09IGN1cnJlbnRSYW5nZS5zdGFydCkge1xuICAgICAgdHJhbnNwb3NlZEl0ZW0gPSB7XG4gICAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgICAgaW5kZXg6IGN1cnJlbnRHcm91cEluZGV4XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc3Bvc2VkSXRlbSA9IHtcbiAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXggLSAoY3VycmVudEdyb3VwSW5kZXggKyAxKSArIGZpcnN0SXRlbUluZGV4LFxuICAgICAgICBncm91cEluZGV4OiBjdXJyZW50R3JvdXBJbmRleFxuICAgICAgfTtcbiAgICB9XG4gICAgdHJhbnNwb3NlZEl0ZW1zLnB1c2goe1xuICAgICAgLi4udHJhbnNwb3NlZEl0ZW0sXG4gICAgICBzaXplOiBpdGVtLnNpemUsXG4gICAgICBvZmZzZXQ6IGl0ZW0ub2Zmc2V0LFxuICAgICAgb3JpZ2luYWxJbmRleDogaXRlbS5pbmRleCxcbiAgICAgIGRhdGE6IGl0ZW0uZGF0YVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0cmFuc3Bvc2VkSXRlbXM7XG59XG5mdW5jdGlvbiBidWlsZExpc3RTdGF0ZShpdGVtcywgdG9wSXRlbXMsIHRvdGFsQ291bnQsIGdhcCwgc2l6ZXMsIGZpcnN0SXRlbUluZGV4KSB7XG4gIGNvbnN0IHsgbGFzdFNpemUsIGxhc3RPZmZzZXQsIGxhc3RJbmRleCB9ID0gc2l6ZXM7XG4gIGxldCBvZmZzZXRUb3AgPSAwO1xuICBsZXQgYm90dG9tID0gMDtcbiAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICBvZmZzZXRUb3AgPSBpdGVtc1swXS5vZmZzZXQ7XG4gICAgY29uc3QgbGFzdEl0ZW0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICBib3R0b20gPSBsYXN0SXRlbS5vZmZzZXQgKyBsYXN0SXRlbS5zaXplO1xuICB9XG4gIGNvbnN0IGl0ZW1Db3VudCA9IHRvdGFsQ291bnQgLSBsYXN0SW5kZXg7XG4gIGNvbnN0IHRvdGFsID0gbGFzdE9mZnNldCArIGl0ZW1Db3VudCAqIGxhc3RTaXplICsgKGl0ZW1Db3VudCAtIDEpICogZ2FwO1xuICBjb25zdCB0b3AgPSBvZmZzZXRUb3A7XG4gIGNvbnN0IG9mZnNldEJvdHRvbSA9IHRvdGFsIC0gYm90dG9tO1xuICByZXR1cm4ge1xuICAgIGl0ZW1zOiB0cmFuc3Bvc2VJdGVtcyhpdGVtcywgc2l6ZXMsIGZpcnN0SXRlbUluZGV4KSxcbiAgICB0b3BJdGVtczogdHJhbnNwb3NlSXRlbXModG9wSXRlbXMsIHNpemVzLCBmaXJzdEl0ZW1JbmRleCksXG4gICAgdG9wTGlzdEhlaWdodDogdG9wSXRlbXMucmVkdWNlKChoZWlnaHQsIGl0ZW0pID0+IGl0ZW0uc2l6ZSArIGhlaWdodCwgMCksXG4gICAgb2Zmc2V0VG9wLFxuICAgIG9mZnNldEJvdHRvbSxcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIHRvdGFsQ291bnQsXG4gICAgZmlyc3RJdGVtSW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTGlzdFN0YXRlRnJvbUl0ZW1Db3VudChpdGVtQ291bnQsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LCBzaXplcywgZmlyc3RJdGVtSW5kZXgsIGdhcCwgZGF0YSkge1xuICBsZXQgaW5jbHVkZWRHcm91cHNDb3VudCA9IDA7XG4gIGlmIChzaXplcy5ncm91cEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3QgaW5kZXggb2Ygc2l6ZXMuZ3JvdXBJbmRpY2VzKSB7XG4gICAgICBpZiAoaW5kZXggLSBpbmNsdWRlZEdyb3Vwc0NvdW50ID49IGl0ZW1Db3VudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluY2x1ZGVkR3JvdXBzQ291bnQrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWRDb3VudCA9IGl0ZW1Db3VudCArIGluY2x1ZGVkR3JvdXBzQ291bnQ7XG4gIGNvbnN0IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyID0gZ2V0SW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhOdW1iZXIoaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgsIGFkanVzdGVkQ291bnQpO1xuICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGFkanVzdGVkQ291bnQgfSkubWFwKChfLCBpbmRleCkgPT4gKHtcbiAgICBpbmRleDogaW5kZXggKyBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleE51bWJlcixcbiAgICBzaXplOiAwLFxuICAgIG9mZnNldDogMCxcbiAgICBkYXRhOiBkYXRhW2luZGV4ICsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhOdW1iZXJdXG4gIH0pKTtcbiAgcmV0dXJuIGJ1aWxkTGlzdFN0YXRlKGl0ZW1zLCBbXSwgYWRqdXN0ZWRDb3VudCwgZ2FwLCBzaXplcywgZmlyc3RJdGVtSW5kZXgpO1xufVxuY29uc3QgbGlzdFN0YXRlU3lzdGVtID0gc3lzdGVtKFxuICAoW1xuICAgIHsgc2l6ZXMsIHRvdGFsQ291bnQsIGRhdGEsIGZpcnN0SXRlbUluZGV4LCBnYXAgfSxcbiAgICBncm91cGVkTGlzdFN5c3RlbTIsXG4gICAgeyB2aXNpYmxlUmFuZ2UsIGxpc3RCb3VuZGFyeSwgdG9wTGlzdEhlaWdodDogcmFuZ2VUb3BMaXN0SGVpZ2h0IH0sXG4gICAgeyBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4IH0sXG4gICAgeyB0b3BMaXN0SGVpZ2h0IH0sXG4gICAgc3RhdGVGbGFncyxcbiAgICB7IGRpZE1vdW50IH0sXG4gICAgeyByZWNhbGNJblByb2dyZXNzIH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IHRvcEl0ZW1zSW5kZXhlcyA9IHN0YXRlZnVsU3RyZWFtKFtdKTtcbiAgICBjb25zdCBpbml0aWFsSXRlbUNvdW50ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgaXRlbXNSZW5kZXJlZCA9IHN0cmVhbSgpO1xuICAgIGNvbm5lY3QoZ3JvdXBlZExpc3RTeXN0ZW0yLnRvcEl0ZW1zSW5kZXhlcywgdG9wSXRlbXNJbmRleGVzKTtcbiAgICBjb25zdCBsaXN0U3RhdGUgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChcbiAgICAgICAgICBkaWRNb3VudCxcbiAgICAgICAgICByZWNhbGNJblByb2dyZXNzLFxuICAgICAgICAgIGR1Yyh2aXNpYmxlUmFuZ2UsIHR1cGxlQ29tcGFyYXRvciksXG4gICAgICAgICAgZHVjKHRvdGFsQ291bnQpLFxuICAgICAgICAgIGR1YyhzaXplcyksXG4gICAgICAgICAgZHVjKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4KSxcbiAgICAgICAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sXG4gICAgICAgICAgZHVjKHRvcEl0ZW1zSW5kZXhlcyksXG4gICAgICAgICAgZHVjKGZpcnN0SXRlbUluZGV4KSxcbiAgICAgICAgICBkdWMoZ2FwKSxcbiAgICAgICAgICBkYXRhXG4gICAgICAgICksXG4gICAgICAgIGZpbHRlcigoW21vdW50LCByZWNhbGNJblByb2dyZXNzMiwgLCB0b3RhbENvdW50MiwgLCAsICwgLCAsICwgZGF0YTJdKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YUNoYW5nZUluUHJvZ3Jlc3MgPSBkYXRhMiAmJiBkYXRhMi5sZW5ndGggIT09IHRvdGFsQ291bnQyO1xuICAgICAgICAgIHJldHVybiBtb3VudCAmJiAhcmVjYWxjSW5Qcm9ncmVzczIgJiYgIWRhdGFDaGFuZ2VJblByb2dyZXNzO1xuICAgICAgICB9KSxcbiAgICAgICAgbWFwKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBbc3RhcnRPZmZzZXQsIGVuZE9mZnNldF0sXG4gICAgICAgICAgICB0b3RhbENvdW50MixcbiAgICAgICAgICAgIHNpemVzMixcbiAgICAgICAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4MixcbiAgICAgICAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbTIsXG4gICAgICAgICAgICB0b3BJdGVtc0luZGV4ZXMyLFxuICAgICAgICAgICAgZmlyc3RJdGVtSW5kZXgyLFxuICAgICAgICAgICAgZ2FwMixcbiAgICAgICAgICAgIGRhdGEyXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZXNWYWx1ZSA9IHNpemVzMjtcbiAgICAgICAgICAgIGNvbnN0IHsgc2l6ZVRyZWUsIG9mZnNldFRyZWUgfSA9IHNpemVzVmFsdWU7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSXRlbUNvdW50VmFsdWUgPSBnZXRWYWx1ZShpbml0aWFsSXRlbUNvdW50KTtcbiAgICAgICAgICAgIGlmICh0b3RhbENvdW50MiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5FTVBUWV9MSVNUX1NUQVRFLCB0b3RhbENvdW50OiB0b3RhbENvdW50MiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAoaW5pdGlhbEl0ZW1Db3VudFZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uRU1QVFlfTElTVF9TVEFURSwgdG90YWxDb3VudDogdG90YWxDb3VudDIgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRMaXN0U3RhdGVGcm9tSXRlbUNvdW50KGluaXRpYWxJdGVtQ291bnRWYWx1ZSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyLCBzaXplczIsIGZpcnN0SXRlbUluZGV4MiwgZ2FwMiwgZGF0YTIgfHwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1wdHkoc2l6ZVRyZWUpKSB7XG4gICAgICAgICAgICAgIGlmIChpbml0aWFsSXRlbUNvdW50VmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBidWlsZExpc3RTdGF0ZShcbiAgICAgICAgICAgICAgICBwcm9iZUl0ZW1TZXQoZ2V0SW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhOdW1iZXIoaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyLCB0b3RhbENvdW50MiksIHNpemVzVmFsdWUsIGRhdGEyKSxcbiAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICB0b3RhbENvdW50MixcbiAgICAgICAgICAgICAgICBnYXAyLFxuICAgICAgICAgICAgICAgIHNpemVzVmFsdWUsXG4gICAgICAgICAgICAgICAgZmlyc3RJdGVtSW5kZXgyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvcEl0ZW1zID0gW107XG4gICAgICAgICAgICBpZiAodG9wSXRlbXNJbmRleGVzMi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSB0b3BJdGVtc0luZGV4ZXMyWzBdO1xuICAgICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRvcEl0ZW1zSW5kZXhlczJbdG9wSXRlbXNJbmRleGVzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcmFuZ2VzV2l0aGluKHNpemVUcmVlLCBzdGFydEluZGV4LCBlbmRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gcmFuZ2UudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VTdGFydEluZGV4ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlRW5kSW5kZXggPSBNYXRoLm1pbihyYW5nZS5lbmQsIGVuZEluZGV4KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VTdGFydEluZGV4OyBpIDw9IHJhbmdlRW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdG9wSXRlbXMucHVzaCh7IGluZGV4OiBpLCBzaXplLCBvZmZzZXQsIGRhdGE6IGRhdGEyICYmIGRhdGEyW2ldIH0pO1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNjcm9sbGVkVG9Jbml0aWFsSXRlbTIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkTGlzdFN0YXRlKFtdLCB0b3BJdGVtcywgdG90YWxDb3VudDIsIGdhcDIsIHNpemVzVmFsdWUsIGZpcnN0SXRlbUluZGV4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5TdGFydEluZGV4ID0gdG9wSXRlbXNJbmRleGVzMi5sZW5ndGggPiAwID8gdG9wSXRlbXNJbmRleGVzMlt0b3BJdGVtc0luZGV4ZXMyLmxlbmd0aCAtIDFdICsgMSA6IDA7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRQb2ludFJhbmdlcyA9IHJhbmdlc1dpdGhpbk9mZnNldHMob2Zmc2V0VHJlZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgbWluU3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAob2Zmc2V0UG9pbnRSYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWF4SW5kZXggPSB0b3RhbENvdW50MiAtIDE7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHRhcChbXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIG9mZnNldFBvaW50UmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSByYW5nZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGxldCByYW5nZVN0YXJ0SW5kZXggPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gcG9pbnQuc2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQub2Zmc2V0IDwgc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgIHJhbmdlU3RhcnRJbmRleCArPSBNYXRoLmZsb29yKChzdGFydE9mZnNldCAtIHBvaW50Lm9mZnNldCArIGdhcDIpIC8gKHNpemUgKyBnYXAyKSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpdGVtQ291bnQgPSByYW5nZVN0YXJ0SW5kZXggLSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBpdGVtQ291bnQgKiBzaXplICsgaXRlbUNvdW50ICogZ2FwMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnRJbmRleCA8IG1pblN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAobWluU3RhcnRJbmRleCAtIHJhbmdlU3RhcnRJbmRleCkgKiBzaXplO1xuICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFydEluZGV4ID0gbWluU3RhcnRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBNYXRoLm1pbihyYW5nZS5lbmQsIG1heEluZGV4KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VTdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBpbmRleDogaSwgc2l6ZSwgb2Zmc2V0LCBkYXRhOiBkYXRhMiAmJiBkYXRhMltpXSB9KTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBzaXplICsgZ2FwMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkTGlzdFN0YXRlKGl0ZW1zLCB0b3BJdGVtcywgdG90YWxDb3VudDIsIGdhcDIsIHNpemVzVmFsdWUsIGZpcnN0SXRlbUluZGV4Mik7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3IgZmlsdGVyIG5lZWRzIHRvIGJlIGZpeGVkXG4gICAgICAgIGZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSBudWxsKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKSxcbiAgICAgIEVNUFRZX0xJU1RfU1RBVEVcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBkYXRhLFxuICAgICAgICBmaWx0ZXIoaXNEZWZpbmVkKSxcbiAgICAgICAgbWFwKChkYXRhMikgPT4gZGF0YTIgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEyLmxlbmd0aClcbiAgICAgICksXG4gICAgICB0b3RhbENvdW50XG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgbGlzdFN0YXRlLFxuICAgICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS50b3BMaXN0SGVpZ2h0KVxuICAgICAgKSxcbiAgICAgIHRvcExpc3RIZWlnaHRcbiAgICApO1xuICAgIGNvbm5lY3QodG9wTGlzdEhlaWdodCwgcmFuZ2VUb3BMaXN0SGVpZ2h0KTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgbGlzdFN0YXRlLFxuICAgICAgICBtYXAoKHN0YXRlKSA9PiBbc3RhdGUudG9wLCBzdGF0ZS5ib3R0b21dKVxuICAgICAgKSxcbiAgICAgIGxpc3RCb3VuZGFyeVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgbWFwKChzdGF0ZSkgPT4gc3RhdGUuaXRlbXMpXG4gICAgICApLFxuICAgICAgaXRlbXNSZW5kZXJlZFxuICAgICk7XG4gICAgY29uc3QgZW5kUmVhY2hlZCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgbGlzdFN0YXRlLFxuICAgICAgICBmaWx0ZXIoKHsgaXRlbXMgfSkgPT4gaXRlbXMubGVuZ3RoID4gMCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHRvdGFsQ291bnQsIGRhdGEpLFxuICAgICAgICBmaWx0ZXIoKFt7IGl0ZW1zIH0sIHRvdGFsQ291bnQyXSkgPT4gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0ub3JpZ2luYWxJbmRleCA9PT0gdG90YWxDb3VudDIgLSAxKSxcbiAgICAgICAgbWFwKChbLCB0b3RhbENvdW50MiwgZGF0YTJdKSA9PiBbdG90YWxDb3VudDIgLSAxLCBkYXRhMl0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCh0dXBsZUNvbXBhcmF0b3IpLFxuICAgICAgICBtYXAoKFtjb3VudF0pID0+IGNvdW50KVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3Qgc3RhcnRSZWFjaGVkID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIHRocm90dGxlVGltZSgyMDApLFxuICAgICAgICBmaWx0ZXIoKHsgaXRlbXMsIHRvcEl0ZW1zIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gaXRlbXMubGVuZ3RoID4gMCAmJiBpdGVtc1swXS5vcmlnaW5hbEluZGV4ID09PSB0b3BJdGVtcy5sZW5ndGg7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKHsgaXRlbXMgfSkgPT4gaXRlbXNbMF0uaW5kZXgpLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCByYW5nZUNoYW5nZWQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgZmlsdGVyKCh7IGl0ZW1zIH0pID0+IGl0ZW1zLmxlbmd0aCA+IDApLFxuICAgICAgICBtYXAoKHsgaXRlbXMgfSkgPT4ge1xuICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICBsZXQgZW5kSW5kZXggPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChpdGVtc1tzdGFydEluZGV4XS50eXBlID09PSBcImdyb3VwXCIgJiYgc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChpdGVtc1tlbmRJbmRleF0udHlwZSA9PT0gXCJncm91cFwiICYmIGVuZEluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgZW5kSW5kZXgtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IGl0ZW1zW3N0YXJ0SW5kZXhdLmluZGV4LFxuICAgICAgICAgICAgZW5kSW5kZXg6IGl0ZW1zW2VuZEluZGV4XS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZChyYW5nZUNvbXBhcmF0b3IpXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4geyBsaXN0U3RhdGUsIHRvcEl0ZW1zSW5kZXhlcywgZW5kUmVhY2hlZCwgc3RhcnRSZWFjaGVkLCByYW5nZUNoYW5nZWQsIGl0ZW1zUmVuZGVyZWQsIGluaXRpYWxJdGVtQ291bnQsIC4uLnN0YXRlRmxhZ3MgfTtcbiAgfSxcbiAgdHVwKFxuICAgIHNpemVTeXN0ZW0sXG4gICAgZ3JvdXBlZExpc3RTeXN0ZW0sXG4gICAgc2l6ZVJhbmdlU3lzdGVtLFxuICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4U3lzdGVtLFxuICAgIHNjcm9sbFRvSW5kZXhTeXN0ZW0sXG4gICAgc3RhdGVGbGFnc1N5c3RlbSxcbiAgICBwcm9wc1JlYWR5U3lzdGVtLFxuICAgIHJlY2FsY1N5c3RlbVxuICApLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3QgaW5pdGlhbEl0ZW1Db3VudFN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IHNpemVzLCBmaXJzdEl0ZW1JbmRleCwgZGF0YSwgZ2FwIH0sIHsgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXggfSwgeyBpbml0aWFsSXRlbUNvdW50LCBsaXN0U3RhdGUgfSwgeyBkaWRNb3VudCB9XSkgPT4ge1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBkaWRNb3VudCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oaW5pdGlhbEl0ZW1Db3VudCksXG4gICAgICAgIGZpbHRlcigoWywgY291bnRdKSA9PiBjb3VudCAhPT0gMCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LCBzaXplcywgZmlyc3RJdGVtSW5kZXgsIGdhcCwgZGF0YSksXG4gICAgICAgIG1hcCgoW1ssIGNvdW50XSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhWYWx1ZSwgc2l6ZXMyLCBmaXJzdEl0ZW1JbmRleDIsIGdhcDIsIGRhdGEyID0gW11dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkTGlzdFN0YXRlRnJvbUl0ZW1Db3VudChjb3VudCwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhWYWx1ZSwgc2l6ZXMyLCBmaXJzdEl0ZW1JbmRleDIsIGdhcDIsIGRhdGEyKTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBsaXN0U3RhdGVcbiAgICApO1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgdHVwKHNpemVTeXN0ZW0sIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4U3lzdGVtLCBsaXN0U3RhdGVTeXN0ZW0sIHByb3BzUmVhZHlTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3Qgc2Nyb2xsU2Vla1N5c3RlbSA9IHN5c3RlbShcbiAgKFt7IHNjcm9sbFZlbG9jaXR5IH1dKSA9PiB7XG4gICAgY29uc3QgaXNTZWVraW5nID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbnN0IHJhbmdlQ2hhbmdlZCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHNjcm9sbFNlZWtDb25maWd1cmF0aW9uID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBzY3JvbGxWZWxvY2l0eSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb24sIGlzU2Vla2luZywgcmFuZ2VDaGFuZ2VkKSxcbiAgICAgICAgZmlsdGVyKChbXywgY29uZmlnXSkgPT4gISFjb25maWcpLFxuICAgICAgICBtYXAoKFtzcGVlZCwgY29uZmlnLCBpc1NlZWtpbmcyLCByYW5nZV0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGV4aXQsIGVudGVyIH0gPSBjb25maWc7XG4gICAgICAgICAgaWYgKGlzU2Vla2luZzIpIHtcbiAgICAgICAgICAgIGlmIChleGl0KHNwZWVkLCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZW50ZXIoc3BlZWQsIHJhbmdlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzU2Vla2luZzI7XG4gICAgICAgIH0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApLFxuICAgICAgaXNTZWVraW5nXG4gICAgKTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKGNvbWJpbmVMYXRlc3QoaXNTZWVraW5nLCBzY3JvbGxWZWxvY2l0eSwgcmFuZ2VDaGFuZ2VkKSwgd2l0aExhdGVzdEZyb20oc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb24pKSxcbiAgICAgIChbW2lzU2Vla2luZzIsIHZlbG9jaXR5LCByYW5nZV0sIGNvbmZpZ10pID0+IGlzU2Vla2luZzIgJiYgY29uZmlnICYmIGNvbmZpZy5jaGFuZ2UgJiYgY29uZmlnLmNoYW5nZSh2ZWxvY2l0eSwgcmFuZ2UpXG4gICAgKTtcbiAgICByZXR1cm4geyBpc1NlZWtpbmcsIHNjcm9sbFNlZWtDb25maWd1cmF0aW9uLCBzY3JvbGxWZWxvY2l0eSwgc2Nyb2xsU2Vla1JhbmdlQ2hhbmdlZDogcmFuZ2VDaGFuZ2VkIH07XG4gIH0sXG4gIHR1cChzdGF0ZUZsYWdzU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmNvbnN0IHRvcEl0ZW1Db3VudFN5c3RlbSA9IHN5c3RlbSgoW3sgdG9wSXRlbXNJbmRleGVzIH1dKSA9PiB7XG4gIGNvbnN0IHRvcEl0ZW1Db3VudCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICBjb25uZWN0KFxuICAgIHBpcGUoXG4gICAgICB0b3BJdGVtQ291bnQsXG4gICAgICBmaWx0ZXIoKGxlbmd0aCkgPT4gbGVuZ3RoID4gMCksXG4gICAgICBtYXAoKGxlbmd0aCkgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5tYXAoKF8sIGluZGV4KSA9PiBpbmRleCkpXG4gICAgKSxcbiAgICB0b3BJdGVtc0luZGV4ZXNcbiAgKTtcbiAgcmV0dXJuIHsgdG9wSXRlbUNvdW50IH07XG59LCB0dXAobGlzdFN0YXRlU3lzdGVtKSk7XG5jb25zdCB0b3RhbExpc3RIZWlnaHRTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBmb290ZXJIZWlnaHQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0IH0sIHsgbGlzdFN0YXRlIH1dKSA9PiB7XG4gICAgY29uc3QgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHRvdGFsTGlzdEhlaWdodCA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KGZvb3RlckhlaWdodCwgZml4ZWRGb290ZXJIZWlnaHQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGxpc3RTdGF0ZSksXG4gICAgICAgIG1hcCgoW2Zvb3RlckhlaWdodDIsIGZpeGVkRm9vdGVySGVpZ2h0MiwgaGVhZGVySGVpZ2h0MiwgZml4ZWRIZWFkZXJIZWlnaHQyLCBsaXN0U3RhdGUyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBmb290ZXJIZWlnaHQyICsgZml4ZWRGb290ZXJIZWlnaHQyICsgaGVhZGVySGVpZ2h0MiArIGZpeGVkSGVhZGVySGVpZ2h0MiArIGxpc3RTdGF0ZTIub2Zmc2V0Qm90dG9tICsgbGlzdFN0YXRlMi5ib3R0b207XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgMFxuICAgICk7XG4gICAgY29ubmVjdChkdWModG90YWxMaXN0SGVpZ2h0KSwgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZCk7XG4gICAgcmV0dXJuIHsgdG90YWxMaXN0SGVpZ2h0LCB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkIH07XG4gIH0sXG4gIHR1cChkb21JT1N5c3RlbSwgbGlzdFN0YXRlU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHNpbXBsZU1lbW9pemUoZnVuYykge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIGxldCByZXN1bHQ7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICByZXN1bHQgPSBmdW5jKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5jb25zdCBpc01vYmlsZVNhZmFyaSA9IHNpbXBsZU1lbW9pemUoKCkgPT4ge1xuICByZXR1cm4gL2lQKGFkfG9kfGhvbmUpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvV2ViS2l0L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn0pO1xuY29uc3QgdXB3YXJkU2Nyb2xsRml4U3lzdGVtID0gc3lzdGVtKFxuICAoW1xuICAgIHsgc2Nyb2xsQnksIHNjcm9sbFRvcCwgZGV2aWF0aW9uLCBzY3JvbGxpbmdJblByb2dyZXNzIH0sXG4gICAgeyBpc1Njcm9sbGluZywgaXNBdEJvdHRvbSwgc2Nyb2xsRGlyZWN0aW9uLCBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZSB9LFxuICAgIHsgbGlzdFN0YXRlIH0sXG4gICAgeyBiZWZvcmVVbnNoaWZ0V2l0aCwgc2hpZnRXaXRoT2Zmc2V0LCBzaXplcywgZ2FwIH0sXG4gICAgeyBsb2cgfSxcbiAgICB7IHJlY2FsY0luUHJvZ3Jlc3MgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgZGV2aWF0aW9uT2Zmc2V0ID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGxhc3RKdW1wRHVlVG9JdGVtUmVzaXplKSxcbiAgICAgICAgc2NhbihcbiAgICAgICAgICAoWywgcHJldkl0ZW1zLCBwcmV2VG90YWxDb3VudCwgcHJldlRvdGFsSGVpZ2h0XSwgW3sgaXRlbXMsIHRvdGFsQ291bnQsIGJvdHRvbSwgb2Zmc2V0Qm90dG9tIH0sIGxhc3RKdW1wRHVlVG9JdGVtUmVzaXplMl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gYm90dG9tICsgb2Zmc2V0Qm90dG9tO1xuICAgICAgICAgICAgbGV0IG5ld0RldiA9IDA7XG4gICAgICAgICAgICBpZiAocHJldlRvdGFsQ291bnQgPT09IHRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZJdGVtcy5sZW5ndGggPiAwICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdFN0YXJ0ID0gaXRlbXNbMF0ub3JpZ2luYWxJbmRleCA9PT0gMCAmJiBwcmV2SXRlbXNbMF0ub3JpZ2luYWxJbmRleCA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWF0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0RldiA9IHRvdGFsSGVpZ2h0IC0gcHJldlRvdGFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgaWYgKG5ld0RldiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEZXYgKz0gbGFzdEp1bXBEdWVUb0l0ZW1SZXNpemUyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtuZXdEZXYsIGl0ZW1zLCB0b3RhbENvdW50LCB0b3RhbEhlaWdodF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbMCwgW10sIDAsIDBdXG4gICAgICAgICksXG4gICAgICAgIGZpbHRlcigoW2Ftb3VudF0pID0+IGFtb3VudCAhPT0gMCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNjcm9sbFRvcCwgc2Nyb2xsRGlyZWN0aW9uLCBzY3JvbGxpbmdJblByb2dyZXNzLCBpc0F0Qm90dG9tLCBsb2csIHJlY2FsY0luUHJvZ3Jlc3MpLFxuICAgICAgICBmaWx0ZXIoKFssIHNjcm9sbFRvcDIsIHNjcm9sbERpcmVjdGlvbjIsIHNjcm9sbGluZ0luUHJvZ3Jlc3MyLCAsICwgcmVjYWxjSW5Qcm9ncmVzczJdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICFyZWNhbGNJblByb2dyZXNzMiAmJiAhc2Nyb2xsaW5nSW5Qcm9ncmVzczIgJiYgc2Nyb2xsVG9wMiAhPT0gMCAmJiBzY3JvbGxEaXJlY3Rpb24yID09PSBVUDtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcCgoW1thbW91bnRdLCAsICwgLCAsIGxvZzJdKSA9PiB7XG4gICAgICAgICAgbG9nMihcIlVwd2FyZCBzY3JvbGxpbmcgY29tcGVuc2F0aW9uXCIsIHsgYW1vdW50IH0sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gICAgZnVuY3Rpb24gc2Nyb2xsQnlXaXRoKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgcHVibGlzaChzY3JvbGxCeSwgeyB0b3A6IC1vZmZzZXQsIGJlaGF2aW9yOiBcImF1dG9cIiB9KTtcbiAgICAgICAgcHVibGlzaChkZXZpYXRpb24sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGlzaChkZXZpYXRpb24sIDApO1xuICAgICAgICBwdWJsaXNoKHNjcm9sbEJ5LCB7IHRvcDogLW9mZnNldCwgYmVoYXZpb3I6IFwiYXV0b1wiIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUocGlwZShkZXZpYXRpb25PZmZzZXQsIHdpdGhMYXRlc3RGcm9tKGRldmlhdGlvbiwgaXNTY3JvbGxpbmcpKSwgKFtvZmZzZXQsIGRldmlhdGlvbkFtb3VudCwgaXNTY3JvbGxpbmcyXSkgPT4ge1xuICAgICAgaWYgKGlzU2Nyb2xsaW5nMiAmJiBpc01vYmlsZVNhZmFyaSgpKSB7XG4gICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCBkZXZpYXRpb25BbW91bnQgLSBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsQnlXaXRoKC1vZmZzZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3Qoc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihpc1Njcm9sbGluZywgZmFsc2UpLCBkZXZpYXRpb24sIHJlY2FsY0luUHJvZ3Jlc3MpLFxuICAgICAgICBmaWx0ZXIoKFtpcywgZGV2aWF0aW9uMiwgcmVjYWxjXSkgPT4gIWlzICYmICFyZWNhbGMgJiYgZGV2aWF0aW9uMiAhPT0gMCksXG4gICAgICAgIG1hcCgoW18sIGRldmlhdGlvbjJdKSA9PiBkZXZpYXRpb24yKSxcbiAgICAgICAgdGhyb3R0bGVUaW1lKDEpXG4gICAgICApLFxuICAgICAgc2Nyb2xsQnlXaXRoXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2hpZnRXaXRoT2Zmc2V0LFxuICAgICAgICBtYXAoKG9mZnNldCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7IHRvcDogLW9mZnNldCB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNjcm9sbEJ5XG4gICAgKTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBiZWZvcmVVbnNoaWZ0V2l0aCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMsIGdhcCksXG4gICAgICAgIG1hcCgoW29mZnNldCwgeyBsYXN0U2l6ZTogZGVmYXVsdEl0ZW1TaXplLCBncm91cEluZGljZXMsIHNpemVUcmVlIH0sIGdhcDJdKSA9PiB7XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0SXRlbU9mZnNldChpdGVtQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtQ291bnQgKiAoZGVmYXVsdEl0ZW1TaXplICsgZ2FwMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChncm91cEluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SXRlbU9mZnNldChvZmZzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRHcm91cFNpemUgPSBmaW5kKHNpemVUcmVlLCAwKTtcbiAgICAgICAgICAgIGxldCByZWNvZ25pemVkT2Zmc2V0SXRlbXMgPSAwO1xuICAgICAgICAgICAgbGV0IGdyb3VwSW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlY29nbml6ZWRPZmZzZXRJdGVtcyA8IG9mZnNldCkge1xuICAgICAgICAgICAgICByZWNvZ25pemVkT2Zmc2V0SXRlbXMrKztcbiAgICAgICAgICAgICAgYW1vdW50ICs9IGRlZmF1bHRHcm91cFNpemU7XG4gICAgICAgICAgICAgIGxldCBncm91cEl0ZW1Db3VudCA9IGdyb3VwSW5kaWNlcy5sZW5ndGggPT09IGdyb3VwSW5kZXggKyAxID8gSW5maW5pdHkgOiBncm91cEluZGljZXNbZ3JvdXBJbmRleCArIDFdIC0gZ3JvdXBJbmRpY2VzW2dyb3VwSW5kZXhdIC0gMTtcbiAgICAgICAgICAgICAgaWYgKHJlY29nbml6ZWRPZmZzZXRJdGVtcyArIGdyb3VwSXRlbUNvdW50ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYW1vdW50IC09IGRlZmF1bHRHcm91cFNpemU7XG4gICAgICAgICAgICAgICAgZ3JvdXBJdGVtQ291bnQgPSBvZmZzZXQgLSByZWNvZ25pemVkT2Zmc2V0SXRlbXMgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlY29nbml6ZWRPZmZzZXRJdGVtcyArPSBncm91cEl0ZW1Db3VudDtcbiAgICAgICAgICAgICAgYW1vdW50ICs9IGdldEl0ZW1PZmZzZXQoZ3JvdXBJdGVtQ291bnQpO1xuICAgICAgICAgICAgICBncm91cEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICAob2Zmc2V0KSA9PiB7XG4gICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCBvZmZzZXQpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsQnksIHsgdG9wOiBvZmZzZXQgfSk7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCAwKTtcbiAgICAgICAgICAgIHB1Ymxpc2gocmVjYWxjSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7IGRldmlhdGlvbiB9O1xuICB9LFxuICB0dXAoZG9tSU9TeXN0ZW0sIHN0YXRlRmxhZ3NTeXN0ZW0sIGxpc3RTdGF0ZVN5c3RlbSwgc2l6ZVN5c3RlbSwgbG9nZ2VyU3lzdGVtLCByZWNhbGNTeXN0ZW0pXG4pO1xuY29uc3QgaW5pdGlhbFNjcm9sbFRvcFN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IGRpZE1vdW50IH0sIHsgc2Nyb2xsVG8gfSwgeyBsaXN0U3RhdGUgfV0pID0+IHtcbiAgICBjb25zdCBpbml0aWFsU2Nyb2xsVG9wID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgZGlkTW91bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGluaXRpYWxTY3JvbGxUb3ApLFxuICAgICAgICBmaWx0ZXIoKFssIG9mZnNldF0pID0+IG9mZnNldCAhPT0gMCksXG4gICAgICAgIG1hcCgoWywgb2Zmc2V0XSkgPT4gKHsgdG9wOiBvZmZzZXQgfSkpXG4gICAgICApLFxuICAgICAgKGxvY2F0aW9uKSA9PiB7XG4gICAgICAgIGhhbmRsZU5leHQoXG4gICAgICAgICAgcGlwZShcbiAgICAgICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgICAgIHNraXAoMSksXG4gICAgICAgICAgICBmaWx0ZXIoKHN0YXRlKSA9PiBzdGF0ZS5pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICksXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgcHVibGlzaChzY3JvbGxUbywgbG9jYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRpYWxTY3JvbGxUb3BcbiAgICB9O1xuICB9LFxuICB0dXAocHJvcHNSZWFkeVN5c3RlbSwgZG9tSU9TeXN0ZW0sIGxpc3RTdGF0ZVN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCBhbGlnblRvQm90dG9tU3lzdGVtID0gc3lzdGVtKFxuICAoW3sgdmlld3BvcnRIZWlnaHQgfSwgeyB0b3RhbExpc3RIZWlnaHQgfV0pID0+IHtcbiAgICBjb25zdCBhbGlnblRvQm90dG9tID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbnN0IHBhZGRpbmdUb3BBZGRpdGlvbiA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KGFsaWduVG9Cb3R0b20sIHZpZXdwb3J0SGVpZ2h0LCB0b3RhbExpc3RIZWlnaHQpLFxuICAgICAgICBmaWx0ZXIoKFtlbmFibGVkXSkgPT4gZW5hYmxlZCksXG4gICAgICAgIG1hcCgoWywgdmlld3BvcnRIZWlnaHQyLCB0b3RhbExpc3RIZWlnaHQyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB2aWV3cG9ydEhlaWdodDIgLSB0b3RhbExpc3RIZWlnaHQyKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRocm90dGxlVGltZSgwKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiB7IGFsaWduVG9Cb3R0b20sIHBhZGRpbmdUb3BBZGRpdGlvbiB9O1xuICB9LFxuICB0dXAoZG9tSU9TeXN0ZW0sIHRvdGFsTGlzdEhlaWdodFN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCB3aW5kb3dTY3JvbGxlclN5c3RlbSA9IHN5c3RlbSgoW3sgc2Nyb2xsVG8sIHNjcm9sbENvbnRhaW5lclN0YXRlIH1dKSA9PiB7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlID0gc3RyZWFtKCk7XG4gIGNvbnN0IHdpbmRvd1ZpZXdwb3J0UmVjdCA9IHN0cmVhbSgpO1xuICBjb25zdCB3aW5kb3dTY3JvbGxUbyA9IHN0cmVhbSgpO1xuICBjb25zdCB1c2VXaW5kb3dTY3JvbGwgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gIGNvbnN0IGN1c3RvbVNjcm9sbFBhcmVudCA9IHN0YXRlZnVsU3RyZWFtKHZvaWQgMCk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGNvbWJpbmVMYXRlc3Qod2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUsIHdpbmRvd1ZpZXdwb3J0UmVjdCksXG4gICAgICBtYXAoKFt7IHZpZXdwb3J0SGVpZ2h0LCBzY3JvbGxUb3A6IHdpbmRvd1Njcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0IH0sIHsgb2Zmc2V0VG9wIH1dKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heCgwLCB3aW5kb3dTY3JvbGxUb3AgLSBvZmZzZXRUb3ApLFxuICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApLFxuICAgIHNjcm9sbENvbnRhaW5lclN0YXRlXG4gICk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIHNjcm9sbFRvLFxuICAgICAgd2l0aExhdGVzdEZyb20od2luZG93Vmlld3BvcnRSZWN0KSxcbiAgICAgIG1hcCgoW3Njcm9sbFRvMiwgeyBvZmZzZXRUb3AgfV0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zY3JvbGxUbzIsXG4gICAgICAgICAgdG9wOiBzY3JvbGxUbzIudG9wICsgb2Zmc2V0VG9wXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICksXG4gICAgd2luZG93U2Nyb2xsVG9cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBjb25maWdcbiAgICB1c2VXaW5kb3dTY3JvbGwsXG4gICAgY3VzdG9tU2Nyb2xsUGFyZW50LFxuICAgIC8vIGlucHV0XG4gICAgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgd2luZG93Vmlld3BvcnRSZWN0LFxuICAgIC8vIHNpZ25hbHNcbiAgICB3aW5kb3dTY3JvbGxUb1xuICB9O1xufSwgdHVwKGRvbUlPU3lzdGVtKSk7XG5jb25zdCBkZWZhdWx0Q2FsY3VsYXRlVmlld0xvY2F0aW9uID0gKHtcbiAgaXRlbVRvcDogaXRlbVRvcDIsXG4gIGl0ZW1Cb3R0b20sXG4gIHZpZXdwb3J0VG9wLFxuICB2aWV3cG9ydEJvdHRvbSxcbiAgbG9jYXRpb25QYXJhbXM6IHsgYmVoYXZpb3IsIGFsaWduLCAuLi5yZXN0IH1cbn0pID0+IHtcbiAgaWYgKGl0ZW1Ub3AyIDwgdmlld3BvcnRUb3ApIHtcbiAgICByZXR1cm4geyAuLi5yZXN0LCBiZWhhdmlvciwgYWxpZ246IGFsaWduICE9IG51bGwgPyBhbGlnbiA6IFwic3RhcnRcIiB9O1xuICB9XG4gIGlmIChpdGVtQm90dG9tID4gdmlld3BvcnRCb3R0b20pIHtcbiAgICByZXR1cm4geyAuLi5yZXN0LCBiZWhhdmlvciwgYWxpZ246IGFsaWduICE9IG51bGwgPyBhbGlnbiA6IFwiZW5kXCIgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBzY3JvbGxJbnRvVmlld1N5c3RlbSA9IHN5c3RlbShcbiAgKFtcbiAgICB7IHNpemVzLCB0b3RhbENvdW50LCBnYXAgfSxcbiAgICB7IHNjcm9sbFRvcCwgdmlld3BvcnRIZWlnaHQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0LCBzY3JvbGxpbmdJblByb2dyZXNzIH0sXG4gICAgeyBzY3JvbGxUb0luZGV4IH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbEludG9WaWV3ID0gc3RyZWFtKCk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbEludG9WaWV3LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgdmlld3BvcnRIZWlnaHQsIHRvdGFsQ291bnQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0LCBzY3JvbGxUb3ApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShnYXApLFxuICAgICAgICBtYXAoKFtbdmlld0xvY2F0aW9uLCBzaXplczIsIHZpZXdwb3J0SGVpZ2h0MiwgdG90YWxDb3VudDIsIGhlYWRlckhlaWdodDIsIGZpeGVkSGVhZGVySGVpZ2h0MiwgZml4ZWRGb290ZXJIZWlnaHQyLCBzY3JvbGxUb3AyXSwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIGJlaGF2aW9yLCBhbGlnbiwgY2FsY3VsYXRlVmlld0xvY2F0aW9uID0gZGVmYXVsdENhbGN1bGF0ZVZpZXdMb2NhdGlvbiwgLi4ucmVzdCB9ID0gdmlld0xvY2F0aW9uO1xuICAgICAgICAgIGNvbnN0IGFjdHVhbEluZGV4ID0gb3JpZ2luYWxJbmRleEZyb21Mb2NhdGlvbih2aWV3TG9jYXRpb24sIHNpemVzMiwgdG90YWxDb3VudDIgLSAxKTtcbiAgICAgICAgICBjb25zdCBpdGVtVG9wMiA9IG9mZnNldE9mKGFjdHVhbEluZGV4LCBzaXplczIub2Zmc2V0VHJlZSwgZ2FwMikgKyBoZWFkZXJIZWlnaHQyICsgZml4ZWRIZWFkZXJIZWlnaHQyO1xuICAgICAgICAgIGNvbnN0IGl0ZW1Cb3R0b20gPSBpdGVtVG9wMiArIGZpbmRNYXhLZXlWYWx1ZShzaXplczIuc2l6ZVRyZWUsIGFjdHVhbEluZGV4KVsxXTtcbiAgICAgICAgICBjb25zdCB2aWV3cG9ydFRvcCA9IHNjcm9sbFRvcDIgKyBmaXhlZEhlYWRlckhlaWdodDI7XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSBzY3JvbGxUb3AyICsgdmlld3BvcnRIZWlnaHQyIC0gZml4ZWRGb290ZXJIZWlnaHQyO1xuICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gY2FsY3VsYXRlVmlld0xvY2F0aW9uKHtcbiAgICAgICAgICAgIGl0ZW1Ub3A6IGl0ZW1Ub3AyLFxuICAgICAgICAgICAgaXRlbUJvdHRvbSxcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wLFxuICAgICAgICAgICAgdmlld3BvcnRCb3R0b20sXG4gICAgICAgICAgICBsb2NhdGlvblBhcmFtczogeyBiZWhhdmlvciwgYWxpZ24sIC4uLnJlc3QgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgZG9uZSAmJiBoYW5kbGVOZXh0KFxuICAgICAgICAgICAgICBwaXBlKFxuICAgICAgICAgICAgICAgIHNjcm9sbGluZ0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPT09IGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvLyBza2lwcyB0aGUgaW5pdGlhbCBwdWJsaXNoIG9mIGZhbHNlLCBhbmQgdGhlIGNsZWFudXAgY2FsbC5cbiAgICAgICAgICAgICAgICAvLyBidXQgaWYgc2Nyb2xsaW5nSW5Qcm9ncmVzcyBpcyB0cnVlLCB3ZSBza2lwIHRoZSBpbml0aWFsIHB1Ymxpc2guXG4gICAgICAgICAgICAgICAgc2tpcChnZXRWYWx1ZShzY3JvbGxpbmdJblByb2dyZXNzKSA/IDEgOiAyKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBkb25lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgICB9KSxcbiAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwpXG4gICAgICApLFxuICAgICAgc2Nyb2xsVG9JbmRleFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbEludG9WaWV3XG4gICAgfTtcbiAgfSxcbiAgdHVwKHNpemVTeXN0ZW0sIGRvbUlPU3lzdGVtLCBzY3JvbGxUb0luZGV4U3lzdGVtLCBsaXN0U3RhdGVTeXN0ZW0sIGxvZ2dlclN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCBzdGF0ZUxvYWRTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgeyBzaXplcywgc2l6ZVJhbmdlcyB9LFxuICAgIHsgc2Nyb2xsVG9wIH0sXG4gICAgeyBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCB9LFxuICAgIHsgZGlkTW91bnQgfSxcbiAgICB7IHVzZVdpbmRvd1Njcm9sbCwgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUsIHdpbmRvd1ZpZXdwb3J0UmVjdCB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBnZXRTdGF0ZSA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHJlc3RvcmVTdGF0ZUZyb20gPSBzdGF0ZWZ1bFN0cmVhbSh2b2lkIDApO1xuICAgIGNvbnN0IHN0YXRlZnVsV2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgICBjb25zdCBzdGF0ZWZ1bFdpbmRvd1ZpZXdwb3J0UmVjdCA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICAgIGNvbm5lY3Qod2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUsIHN0YXRlZnVsV2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUpO1xuICAgIGNvbm5lY3Qod2luZG93Vmlld3BvcnRSZWN0LCBzdGF0ZWZ1bFdpbmRvd1ZpZXdwb3J0UmVjdCk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShnZXRTdGF0ZSwgd2l0aExhdGVzdEZyb20oc2l6ZXMsIHNjcm9sbFRvcCwgdXNlV2luZG93U2Nyb2xsLCBzdGF0ZWZ1bFdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLCBzdGF0ZWZ1bFdpbmRvd1ZpZXdwb3J0UmVjdCkpLFxuICAgICAgKFtjYWxsYmFjaywgc2l6ZXMyLCBzY3JvbGxUb3AyLCB1c2VXaW5kb3dTY3JvbGwyLCB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZTIsIHdpbmRvd1ZpZXdwb3J0UmVjdDJdKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IHNpemVUcmVlVG9SYW5nZXMoc2l6ZXMyLnNpemVUcmVlKTtcbiAgICAgICAgaWYgKHVzZVdpbmRvd1Njcm9sbDIgJiYgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUyICE9PSBudWxsICYmIHdpbmRvd1ZpZXdwb3J0UmVjdDIgIT09IG51bGwpIHtcbiAgICAgICAgICBzY3JvbGxUb3AyID0gd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUyLnNjcm9sbFRvcCAtIHdpbmRvd1ZpZXdwb3J0UmVjdDIub2Zmc2V0VG9wO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKHsgcmFuZ2VzLCBzY3JvbGxUb3A6IHNjcm9sbFRvcDIgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25uZWN0KHBpcGUocmVzdG9yZVN0YXRlRnJvbSwgZmlsdGVyKGlzRGVmaW5lZCksIG1hcChsb2NhdGlvbkZyb21TbmFwc2hvdCkpLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShyZXN0b3JlU3RhdGVGcm9tKSxcbiAgICAgICAgZmlsdGVyKChbLCBzdGF0ZV0pID0+IHN0YXRlICE9PSB2b2lkIDApLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgICBtYXAoKFssIHNuYXBzaG90XSkgPT4ge1xuICAgICAgICAgIHJldHVybiBzbmFwc2hvdC5yYW5nZXM7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2l6ZVJhbmdlc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFN0YXRlLFxuICAgICAgcmVzdG9yZVN0YXRlRnJvbVxuICAgIH07XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBkb21JT1N5c3RlbSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0sIHByb3BzUmVhZHlTeXN0ZW0sIHdpbmRvd1Njcm9sbGVyU3lzdGVtKVxuKTtcbmZ1bmN0aW9uIGxvY2F0aW9uRnJvbVNuYXBzaG90KHNuYXBzaG90KSB7XG4gIHJldHVybiB7IG9mZnNldDogc25hcHNob3Quc2Nyb2xsVG9wLCBpbmRleDogMCwgYWxpZ246IFwic3RhcnRcIiB9O1xufVxuY29uc3QgZmVhdHVyZUdyb3VwMVN5c3RlbSA9IHN5c3RlbShcbiAgKFtcbiAgICBzaXplUmFuZ2UsXG4gICAgaW5pdGlhbEl0ZW1Db3VudCxcbiAgICBwcm9wc1JlYWR5LFxuICAgIHNjcm9sbFNlZWssXG4gICAgdG90YWxMaXN0SGVpZ2h0LFxuICAgIGluaXRpYWxTY3JvbGxUb3BTeXN0ZW0yLFxuICAgIGFsaWduVG9Cb3R0b20sXG4gICAgd2luZG93U2Nyb2xsZXIsXG4gICAgc2Nyb2xsSW50b1ZpZXcsXG4gICAgbG9nZ2VyXG4gIF0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2l6ZVJhbmdlLFxuICAgICAgLi4uaW5pdGlhbEl0ZW1Db3VudCxcbiAgICAgIC4uLnByb3BzUmVhZHksXG4gICAgICAuLi5zY3JvbGxTZWVrLFxuICAgICAgLi4udG90YWxMaXN0SGVpZ2h0LFxuICAgICAgLi4uaW5pdGlhbFNjcm9sbFRvcFN5c3RlbTIsXG4gICAgICAuLi5hbGlnblRvQm90dG9tLFxuICAgICAgLi4ud2luZG93U2Nyb2xsZXIsXG4gICAgICAuLi5zY3JvbGxJbnRvVmlldyxcbiAgICAgIC4uLmxvZ2dlclxuICAgIH07XG4gIH0sXG4gIHR1cChcbiAgICBzaXplUmFuZ2VTeXN0ZW0sXG4gICAgaW5pdGlhbEl0ZW1Db3VudFN5c3RlbSxcbiAgICBwcm9wc1JlYWR5U3lzdGVtLFxuICAgIHNjcm9sbFNlZWtTeXN0ZW0sXG4gICAgdG90YWxMaXN0SGVpZ2h0U3lzdGVtLFxuICAgIGluaXRpYWxTY3JvbGxUb3BTeXN0ZW0sXG4gICAgYWxpZ25Ub0JvdHRvbVN5c3RlbSxcbiAgICB3aW5kb3dTY3JvbGxlclN5c3RlbSxcbiAgICBzY3JvbGxJbnRvVmlld1N5c3RlbSxcbiAgICBsb2dnZXJTeXN0ZW1cbiAgKVxuKTtcbmNvbnN0IGxpc3RTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAge1xuICAgICAgdG90YWxDb3VudCxcbiAgICAgIHNpemVSYW5nZXMsXG4gICAgICBmaXhlZEl0ZW1TaXplLFxuICAgICAgZGVmYXVsdEl0ZW1TaXplLFxuICAgICAgdHJhY2tJdGVtU2l6ZXMsXG4gICAgICBpdGVtU2l6ZSxcbiAgICAgIGRhdGEsXG4gICAgICBmaXJzdEl0ZW1JbmRleCxcbiAgICAgIGdyb3VwSW5kaWNlcyxcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudCxcbiAgICAgIGdhcCxcbiAgICAgIHNpemVzXG4gICAgfSxcbiAgICB7IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0gfSxcbiAgICBkb21JTyxcbiAgICBzdGF0ZUxvYWQsXG4gICAgZm9sbG93T3V0cHV0LFxuICAgIHsgbGlzdFN0YXRlLCB0b3BJdGVtc0luZGV4ZXMsIC4uLmZsYWdzIH0sXG4gICAgeyBzY3JvbGxUb0luZGV4IH0sXG4gICAgXyxcbiAgICB7IHRvcEl0ZW1Db3VudCB9LFxuICAgIHsgZ3JvdXBDb3VudHMgfSxcbiAgICBmZWF0dXJlR3JvdXAxXG4gIF0pID0+IHtcbiAgICBjb25uZWN0KGZsYWdzLnJhbmdlQ2hhbmdlZCwgZmVhdHVyZUdyb3VwMS5zY3JvbGxTZWVrUmFuZ2VDaGFuZ2VkKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgZmVhdHVyZUdyb3VwMS53aW5kb3dWaWV3cG9ydFJlY3QsXG4gICAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLnZpc2libGVIZWlnaHQpXG4gICAgICApLFxuICAgICAgZG9tSU8udmlld3BvcnRIZWlnaHRcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgdG90YWxDb3VudCxcbiAgICAgIGRhdGEsXG4gICAgICBmaXJzdEl0ZW1JbmRleCxcbiAgICAgIHNpemVSYW5nZXMsXG4gICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCxcbiAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSxcbiAgICAgIHRvcEl0ZW1zSW5kZXhlcyxcbiAgICAgIHRvcEl0ZW1Db3VudCxcbiAgICAgIGdyb3VwQ291bnRzLFxuICAgICAgZml4ZWRJdGVtSGVpZ2h0OiBmaXhlZEl0ZW1TaXplLFxuICAgICAgZGVmYXVsdEl0ZW1IZWlnaHQ6IGRlZmF1bHRJdGVtU2l6ZSxcbiAgICAgIGdhcCxcbiAgICAgIC4uLmZvbGxvd091dHB1dCxcbiAgICAgIC8vIG91dHB1dFxuICAgICAgc3RhdGVmdWxUb3RhbENvdW50LFxuICAgICAgbGlzdFN0YXRlLFxuICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgIHRyYWNrSXRlbVNpemVzLFxuICAgICAgaXRlbVNpemUsXG4gICAgICBncm91cEluZGljZXMsXG4gICAgICAvLyBleHBvcnRlZCBmcm9tIHN0YXRlRmxhZ3NTeXN0ZW1cbiAgICAgIC4uLmZsYWdzLFxuICAgICAgLy8gdGhlIGJhZyBvZiBJTyBmcm9tIGZlYXR1cmVHcm91cDFTeXN0ZW1cbiAgICAgIC4uLmZlYXR1cmVHcm91cDEsXG4gICAgICAuLi5kb21JTyxcbiAgICAgIHNpemVzLFxuICAgICAgLi4uc3RhdGVMb2FkXG4gICAgfTtcbiAgfSxcbiAgdHVwKFxuICAgIHNpemVTeXN0ZW0sXG4gICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0sXG4gICAgZG9tSU9TeXN0ZW0sXG4gICAgc3RhdGVMb2FkU3lzdGVtLFxuICAgIGZvbGxvd091dHB1dFN5c3RlbSxcbiAgICBsaXN0U3RhdGVTeXN0ZW0sXG4gICAgc2Nyb2xsVG9JbmRleFN5c3RlbSxcbiAgICB1cHdhcmRTY3JvbGxGaXhTeXN0ZW0sXG4gICAgdG9wSXRlbUNvdW50U3lzdGVtLFxuICAgIGdyb3VwZWRMaXN0U3lzdGVtLFxuICAgIGZlYXR1cmVHcm91cDFTeXN0ZW1cbiAgKVxuKTtcbmNvbnN0IFdFQktJVF9TVElDS1kgPSBcIi13ZWJraXQtc3RpY2t5XCI7XG5jb25zdCBTVElDS1kgPSBcInN0aWNreVwiO1xuY29uc3QgcG9zaXRpb25TdGlja3lDc3NWYWx1ZSA9IHNpbXBsZU1lbW9pemUoKCkgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFNUSUNLWTtcbiAgfVxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFdFQktJVF9TVElDS1k7XG4gIHJldHVybiBub2RlLnN0eWxlLnBvc2l0aW9uID09PSBXRUJLSVRfU1RJQ0tZID8gV0VCS0lUX1NUSUNLWSA6IFNUSUNLWTtcbn0pO1xuZnVuY3Rpb24gdXNlV2luZG93Vmlld3BvcnRSZWN0UmVmKGNhbGxiYWNrLCBjdXN0b21TY3JvbGxQYXJlbnQpIHtcbiAgY29uc3Qgdmlld3BvcnRJbmZvID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBjYWxjdWxhdGVJbmZvID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50ID09PSBudWxsIHx8ICFlbGVtZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHZpc2libGVXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICBsZXQgdmlzaWJsZUhlaWdodCwgb2Zmc2V0VG9wO1xuICAgICAgaWYgKGN1c3RvbVNjcm9sbFBhcmVudCkge1xuICAgICAgICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnRSZWN0ID0gY3VzdG9tU2Nyb2xsUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBkZWx0YVRvcCA9IHJlY3QudG9wIC0gY3VzdG9tU2Nyb2xsUGFyZW50UmVjdC50b3A7XG4gICAgICAgIHZpc2libGVIZWlnaHQgPSBjdXN0b21TY3JvbGxQYXJlbnRSZWN0LmhlaWdodCAtIE1hdGgubWF4KDAsIGRlbHRhVG9wKTtcbiAgICAgICAgb2Zmc2V0VG9wID0gZGVsdGFUb3AgKyBjdXN0b21TY3JvbGxQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaWJsZUhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIE1hdGgubWF4KDAsIHJlY3QudG9wKTtcbiAgICAgICAgb2Zmc2V0VG9wID0gcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICB9XG4gICAgICB2aWV3cG9ydEluZm8uY3VycmVudCA9IHtcbiAgICAgICAgb2Zmc2V0VG9wLFxuICAgICAgICB2aXNpYmxlSGVpZ2h0LFxuICAgICAgICB2aXNpYmxlV2lkdGhcbiAgICAgIH07XG4gICAgICBjYWxsYmFjayh2aWV3cG9ydEluZm8uY3VycmVudCk7XG4gICAgfSxcbiAgICBbY2FsbGJhY2ssIGN1c3RvbVNjcm9sbFBhcmVudF1cbiAgKTtcbiAgY29uc3QgeyBjYWxsYmFja1JlZiwgcmVmIH0gPSB1c2VTaXplV2l0aEVsUmVmKGNhbGN1bGF0ZUluZm8pO1xuICBjb25zdCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY2FsY3VsYXRlSW5mbyhyZWYuY3VycmVudCk7XG4gIH0sIFtjYWxjdWxhdGVJbmZvLCByZWZdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3VzdG9tU2Nyb2xsUGFyZW50KSB7XG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoY3VzdG9tU2Nyb2xsUGFyZW50KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1c3RvbVNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEFuZFJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShjdXN0b21TY3JvbGxQYXJlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHNjcm9sbEFuZFJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIsIGN1c3RvbVNjcm9sbFBhcmVudF0pO1xuICByZXR1cm4gY2FsbGJhY2tSZWY7XG59XG5jb25zdCBWaXJ0dW9zb01vY2tDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuY29uc3QgVmlydHVvc29HcmlkTW9ja0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBsaXN0Q29tcG9uZW50UHJvcHNTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKCgpID0+IHtcbiAgY29uc3QgaXRlbUNvbnRlbnQgPSBzdGF0ZWZ1bFN0cmVhbSgoaW5kZXgpID0+IGBJdGVtICR7aW5kZXh9YCk7XG4gIGNvbnN0IGNvbnRleHQgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgY29uc3QgZ3JvdXBDb250ZW50ID0gc3RhdGVmdWxTdHJlYW0oKGluZGV4KSA9PiBgR3JvdXAgJHtpbmRleH1gKTtcbiAgY29uc3QgY29tcG9uZW50cyA9IHN0YXRlZnVsU3RyZWFtKHt9KTtcbiAgY29uc3QgY29tcHV0ZUl0ZW1LZXkgPSBzdGF0ZWZ1bFN0cmVhbShpZGVudGl0eSk7XG4gIGNvbnN0IGhlYWRlckZvb3RlclRhZyA9IHN0YXRlZnVsU3RyZWFtKFwiZGl2XCIpO1xuICBjb25zdCBzY3JvbGxlclJlZiA9IHN0YXRlZnVsU3RyZWFtKG5vb3ApO1xuICBjb25zdCBkaXN0aW5jdFByb3AgPSAocHJvcE5hbWUsIGRlZmF1bHRWYWx1ZSA9IG51bGwpID0+IHtcbiAgICByZXR1cm4gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgIG1hcCgoY29tcG9uZW50czIpID0+IGNvbXBvbmVudHMyW3Byb3BOYW1lXSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICksXG4gICAgICBkZWZhdWx0VmFsdWVcbiAgICApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQsXG4gICAgaXRlbUNvbnRlbnQsXG4gICAgZ3JvdXBDb250ZW50LFxuICAgIGNvbXBvbmVudHMsXG4gICAgY29tcHV0ZUl0ZW1LZXksXG4gICAgaGVhZGVyRm9vdGVyVGFnLFxuICAgIHNjcm9sbGVyUmVmLFxuICAgIEZvb3RlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiRm9vdGVyXCIpLFxuICAgIEhlYWRlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiSGVhZGVyXCIpLFxuICAgIFRvcEl0ZW1MaXN0Q29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJUb3BJdGVtTGlzdFwiKSxcbiAgICBMaXN0Q29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJMaXN0XCIsIFwiZGl2XCIpLFxuICAgIEl0ZW1Db21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkl0ZW1cIiwgXCJkaXZcIiksXG4gICAgR3JvdXBDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkdyb3VwXCIsIFwiZGl2XCIpLFxuICAgIFNjcm9sbGVyQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJTY3JvbGxlclwiLCBcImRpdlwiKSxcbiAgICBFbXB0eVBsYWNlaG9sZGVyOiBkaXN0aW5jdFByb3AoXCJFbXB0eVBsYWNlaG9sZGVyXCIpLFxuICAgIFNjcm9sbFNlZWtQbGFjZWhvbGRlcjogZGlzdGluY3RQcm9wKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIpXG4gIH07XG59KTtcbmNvbnN0IGNvbWJpbmVkU3lzdGVtJDIgPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKChbbGlzdFN5c3RlbTIsIHByb3BzU3lzdGVtXSkgPT4ge1xuICByZXR1cm4geyAuLi5saXN0U3lzdGVtMiwgLi4ucHJvcHNTeXN0ZW0gfTtcbn0sIHR1cChsaXN0U3lzdGVtLCBsaXN0Q29tcG9uZW50UHJvcHNTeXN0ZW0pKTtcbmNvbnN0IERlZmF1bHRTY3JvbGxTZWVrUGxhY2Vob2xkZXIkMSA9ICh7IGhlaWdodCB9KSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IGhlaWdodCB9IH0pO1xuY29uc3QgR1JPVVBfU1RZTEUgPSB7IHBvc2l0aW9uOiBwb3NpdGlvblN0aWNreUNzc1ZhbHVlKCksIHpJbmRleDogMSwgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH07XG5jb25zdCBJVEVNX1NUWUxFJDEgPSB7IG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiB9O1xuY29uc3QgSXRlbXMkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvSXRlbXMoeyBzaG93VG9wTGlzdCA9IGZhbHNlIH0pIHtcbiAgY29uc3QgbGlzdFN0YXRlID0gdXNlRW1pdHRlclZhbHVlJDIoXCJsaXN0U3RhdGVcIik7XG4gIGNvbnN0IHNpemVSYW5nZXMgPSB1c2VQdWJsaXNoZXIkMihcInNpemVSYW5nZXNcIik7XG4gIGNvbnN0IHVzZVdpbmRvd1Njcm9sbCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwidXNlV2luZG93U2Nyb2xsXCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImN1c3RvbVNjcm9sbFBhcmVudFwiKTtcbiAgY29uc3Qgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA9IHVzZVB1Ymxpc2hlciQyKFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gIGNvbnN0IF9zY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyJDIoXCJzY3JvbGxDb250YWluZXJTdGF0ZVwiKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrIDogX3Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2s7XG4gIGNvbnN0IGl0ZW1Db250ZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJpdGVtQ29udGVudFwiKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiY29udGV4dFwiKTtcbiAgY29uc3QgZ3JvdXBDb250ZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJncm91cENvbnRlbnRcIik7XG4gIGNvbnN0IHRyYWNrSXRlbVNpemVzID0gdXNlRW1pdHRlclZhbHVlJDIoXCJ0cmFja0l0ZW1TaXplc1wiKTtcbiAgY29uc3QgaXRlbVNpemUgPSB1c2VFbWl0dGVyVmFsdWUkMihcIml0ZW1TaXplXCIpO1xuICBjb25zdCBsb2cgPSB1c2VFbWl0dGVyVmFsdWUkMihcImxvZ1wiKTtcbiAgY29uc3QgbGlzdEdhcCA9IHVzZVB1Ymxpc2hlciQyKFwiZ2FwXCIpO1xuICBjb25zdCB7IGNhbGxiYWNrUmVmIH0gPSB1c2VDaGFuZ2VkTGlzdENvbnRlbnRzU2l6ZXMoXG4gICAgc2l6ZVJhbmdlcyxcbiAgICBpdGVtU2l6ZSxcbiAgICB0cmFja0l0ZW1TaXplcyxcbiAgICBzaG93VG9wTGlzdCA/IG5vb3AgOiBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLFxuICAgIGxvZyxcbiAgICBsaXN0R2FwLFxuICAgIGN1c3RvbVNjcm9sbFBhcmVudFxuICApO1xuICBjb25zdCBbZGV2aWF0aW9uLCBzZXREZXZpYXRpb25dID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIHVzZUVtaXR0ZXIkMihcImRldmlhdGlvblwiLCAodmFsdWUpID0+IHtcbiAgICBpZiAoZGV2aWF0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgc2V0RGV2aWF0aW9uKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBFbXB0eVBsYWNlaG9sZGVyID0gdXNlRW1pdHRlclZhbHVlJDIoXCJFbXB0eVBsYWNlaG9sZGVyXCIpO1xuICBjb25zdCBTY3JvbGxTZWVrUGxhY2Vob2xkZXIgPSB1c2VFbWl0dGVyVmFsdWUkMihcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKSB8fCBEZWZhdWx0U2Nyb2xsU2Vla1BsYWNlaG9sZGVyJDE7XG4gIGNvbnN0IExpc3RDb21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUkMihcIkxpc3RDb21wb25lbnRcIik7XG4gIGNvbnN0IEl0ZW1Db21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUkMihcIkl0ZW1Db21wb25lbnRcIik7XG4gIGNvbnN0IEdyb3VwQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJHcm91cENvbXBvbmVudFwiKTtcbiAgY29uc3QgY29tcHV0ZUl0ZW1LZXkgPSB1c2VFbWl0dGVyVmFsdWUkMihcImNvbXB1dGVJdGVtS2V5XCIpO1xuICBjb25zdCBpc1NlZWtpbmcgPSB1c2VFbWl0dGVyVmFsdWUkMihcImlzU2Vla2luZ1wiKTtcbiAgY29uc3QgaGFzR3JvdXBzMiA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiZ3JvdXBJbmRpY2VzXCIpLmxlbmd0aCA+IDA7XG4gIGNvbnN0IHBhZGRpbmdUb3BBZGRpdGlvbiA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwicGFkZGluZ1RvcEFkZGl0aW9uXCIpO1xuICBjb25zdCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0gPSB1c2VFbWl0dGVyVmFsdWUkMihcInNjcm9sbGVkVG9Jbml0aWFsSXRlbVwiKTtcbiAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBzaG93VG9wTGlzdCA/IHt9IDoge1xuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgcGFkZGluZ1RvcDogbGlzdFN0YXRlLm9mZnNldFRvcCArIHBhZGRpbmdUb3BBZGRpdGlvbixcbiAgICBwYWRkaW5nQm90dG9tOiBsaXN0U3RhdGUub2Zmc2V0Qm90dG9tLFxuICAgIG1hcmdpblRvcDogZGV2aWF0aW9uLFxuICAgIC4uLnNjcm9sbGVkVG9Jbml0aWFsSXRlbSA/IHt9IDogeyB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH1cbiAgfTtcbiAgaWYgKCFzaG93VG9wTGlzdCAmJiBsaXN0U3RhdGUudG90YWxDb3VudCA9PT0gMCAmJiBFbXB0eVBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRW1wdHlQbGFjZWhvbGRlciwgY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoRW1wdHlQbGFjZWhvbGRlciwgY29udGV4dCkpO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIExpc3RDb21wb25lbnQsXG4gICAge1xuICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoTGlzdENvbXBvbmVudCwgY29udGV4dCksXG4gICAgICByZWY6IGNhbGxiYWNrUmVmLFxuICAgICAgc3R5bGU6IGNvbnRhaW5lclN0eWxlLFxuICAgICAgXCJkYXRhLXRlc3QtaWRcIjogc2hvd1RvcExpc3QgPyBcInZpcnR1b3NvLXRvcC1pdGVtLWxpc3RcIiA6IFwidmlydHVvc28taXRlbS1saXN0XCJcbiAgICB9LFxuICAgIChzaG93VG9wTGlzdCA/IGxpc3RTdGF0ZS50b3BJdGVtcyA6IGxpc3RTdGF0ZS5pdGVtcykubWFwKChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGl0ZW0ub3JpZ2luYWxJbmRleDtcbiAgICAgIGNvbnN0IGtleSA9IGNvbXB1dGVJdGVtS2V5KGluZGV4ICsgbGlzdFN0YXRlLmZpcnN0SXRlbUluZGV4LCBpdGVtLmRhdGEsIGNvbnRleHQpO1xuICAgICAgaWYgKGlzU2Vla2luZykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTY3JvbGxTZWVrUGxhY2Vob2xkZXIsIHtcbiAgICAgICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChTY3JvbGxTZWVrUGxhY2Vob2xkZXIsIGNvbnRleHQpLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBpbmRleDogaXRlbS5pbmRleCxcbiAgICAgICAgICBoZWlnaHQ6IGl0ZW0uc2l6ZSxcbiAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUgfHwgXCJpdGVtXCIsXG4gICAgICAgICAgLi4uaXRlbS50eXBlID09PSBcImdyb3VwXCIgPyB7fSA6IHsgZ3JvdXBJbmRleDogaXRlbS5ncm91cEluZGV4IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgR3JvdXBDb21wb25lbnQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoR3JvdXBDb21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgXCJkYXRhLWluZGV4XCI6IGluZGV4LFxuICAgICAgICAgICAgXCJkYXRhLWtub3duLXNpemVcIjogaXRlbS5zaXplLFxuICAgICAgICAgICAgXCJkYXRhLWl0ZW0taW5kZXhcIjogaXRlbS5pbmRleCxcbiAgICAgICAgICAgIHN0eWxlOiBHUk9VUF9TVFlMRVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ3JvdXBDb250ZW50KGl0ZW0uaW5kZXgsIGNvbnRleHQpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBJdGVtQ29tcG9uZW50LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEl0ZW1Db21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgICAgICAgLi4uaXRlbVByb3BJZk5vdERvbUVsZW1lbnQoSXRlbUNvbXBvbmVudCwgaXRlbS5kYXRhKSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleCxcbiAgICAgICAgICAgIFwiZGF0YS1rbm93bi1zaXplXCI6IGl0ZW0uc2l6ZSxcbiAgICAgICAgICAgIFwiZGF0YS1pdGVtLWluZGV4XCI6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICBcImRhdGEtaXRlbS1ncm91cC1pbmRleFwiOiBpdGVtLmdyb3VwSW5kZXgsXG4gICAgICAgICAgICBzdHlsZTogSVRFTV9TVFlMRSQxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXNHcm91cHMyID8gaXRlbUNvbnRlbnQoaXRlbS5pbmRleCwgaXRlbS5ncm91cEluZGV4LCBpdGVtLmRhdGEsIGNvbnRleHQpIDogaXRlbUNvbnRlbnQoaXRlbS5pbmRleCwgaXRlbS5kYXRhLCBjb250ZXh0KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59KTtcbmNvbnN0IHNjcm9sbGVyU3R5bGUgPSB7XG4gIGhlaWdodDogXCIxMDAlXCIsXG4gIG91dGxpbmU6IFwibm9uZVwiLFxuICBvdmVyZmxvd1k6IFwiYXV0b1wiLFxuICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogXCJ0b3VjaFwiXG59O1xuY29uc3Qgdmlld3BvcnRTdHlsZSA9IHtcbiAgd2lkdGg6IFwiMTAwJVwiLFxuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB0b3A6IDBcbn07XG5jb25zdCB0b3BJdGVtTGlzdFN0eWxlID0ge1xuICB3aWR0aDogXCIxMDAlXCIsXG4gIHBvc2l0aW9uOiBwb3NpdGlvblN0aWNreUNzc1ZhbHVlKCksXG4gIHRvcDogMCxcbiAgekluZGV4OiAxXG59O1xuZnVuY3Rpb24gY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoZWxlbWVudCwgY29udGV4dCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7IGNvbnRleHQgfTtcbn1cbmZ1bmN0aW9uIGl0ZW1Qcm9wSWZOb3REb21FbGVtZW50KGVsZW1lbnQsIGl0ZW0pIHtcbiAgcmV0dXJuIHsgaXRlbTogdHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIgPyB2b2lkIDAgOiBpdGVtIH07XG59XG5jb25zdCBIZWFkZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvSGVhZGVyKCkge1xuICBjb25zdCBIZWFkZXIyID0gdXNlRW1pdHRlclZhbHVlJDIoXCJIZWFkZXJDb21wb25lbnRcIik7XG4gIGNvbnN0IGhlYWRlckhlaWdodCA9IHVzZVB1Ymxpc2hlciQyKFwiaGVhZGVySGVpZ2h0XCIpO1xuICBjb25zdCBoZWFkZXJGb290ZXJUYWcgPSB1c2VFbWl0dGVyVmFsdWUkMihcImhlYWRlckZvb3RlclRhZ1wiKTtcbiAgY29uc3QgcmVmID0gdXNlU2l6ZSgoZWwpID0+IGhlYWRlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImNvbnRleHRcIik7XG4gIHJldHVybiBIZWFkZXIyID8gUmVhY3QuY3JlYXRlRWxlbWVudChoZWFkZXJGb290ZXJUYWcsIHsgcmVmIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGVyMiwgY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoSGVhZGVyMiwgY29udGV4dCkpKSA6IG51bGw7XG59KTtcbmNvbnN0IEZvb3RlciQxID0gLyogQF9fUFVSRV9fICovIFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29Gb290ZXIoKSB7XG4gIGNvbnN0IEZvb3RlcjIgPSB1c2VFbWl0dGVyVmFsdWUkMihcIkZvb3RlckNvbXBvbmVudFwiKTtcbiAgY29uc3QgZm9vdGVySGVpZ2h0ID0gdXNlUHVibGlzaGVyJDIoXCJmb290ZXJIZWlnaHRcIik7XG4gIGNvbnN0IGhlYWRlckZvb3RlclRhZyA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiaGVhZGVyRm9vdGVyVGFnXCIpO1xuICBjb25zdCByZWYgPSB1c2VTaXplKChlbCkgPT4gZm9vdGVySGVpZ2h0KGNvcnJlY3RJdGVtU2l6ZShlbCwgXCJoZWlnaHRcIikpKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIEZvb3RlcjIgPyBSZWFjdC5jcmVhdGVFbGVtZW50KGhlYWRlckZvb3RlclRhZywgeyByZWYgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChGb290ZXIyLCBjb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChGb290ZXIyLCBjb250ZXh0KSkpIDogbnVsbDtcbn0pO1xuZnVuY3Rpb24gYnVpbGRTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyMiwgdXNlRW1pdHRlcjogdXNlRW1pdHRlcjIsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlMiB9KSB7XG4gIGNvbnN0IFNjcm9sbGVyMiA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29TY3JvbGxlcih7IHN0eWxlLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSB1c2VQdWJsaXNoZXIyKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gICAgY29uc3QgU2Nyb2xsZXJDb21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUyKFwiU2Nyb2xsZXJDb21wb25lbnRcIik7XG4gICAgY29uc3Qgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCA9IHVzZVB1Ymxpc2hlcjIoXCJzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkXCIpO1xuICAgIGNvbnN0IHNjcm9sbGVyUmVmQ2FsbGJhY2sgPSB1c2VFbWl0dGVyVmFsdWUyKFwic2Nyb2xsZXJSZWZcIik7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZTIoXCJjb250ZXh0XCIpO1xuICAgIGNvbnN0IHsgc2Nyb2xsZXJSZWYsIHNjcm9sbEJ5Q2FsbGJhY2ssIHNjcm9sbFRvQ2FsbGJhY2sgfSA9IHVzZVNjcm9sbFRvcChcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2ssXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkLFxuICAgICAgU2Nyb2xsZXJDb21wb25lbnQsXG4gICAgICBzY3JvbGxlclJlZkNhbGxiYWNrXG4gICAgKTtcbiAgICB1c2VFbWl0dGVyMihcInNjcm9sbFRvXCIsIHNjcm9sbFRvQ2FsbGJhY2spO1xuICAgIHVzZUVtaXR0ZXIyKFwic2Nyb2xsQnlcIiwgc2Nyb2xsQnlDYWxsYmFjayk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTY3JvbGxlckNvbXBvbmVudCxcbiAgICAgIHtcbiAgICAgICAgcmVmOiBzY3JvbGxlclJlZixcbiAgICAgICAgc3R5bGU6IHsgLi4uc2Nyb2xsZXJTdHlsZSwgLi4uc3R5bGUgfSxcbiAgICAgICAgXCJkYXRhLXRlc3QtaWRcIjogXCJ2aXJ0dW9zby1zY3JvbGxlclwiLFxuICAgICAgICBcImRhdGEtdmlydHVvc28tc2Nyb2xsZXJcIjogdHJ1ZSxcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChTY3JvbGxlckNvbXBvbmVudCwgY29udGV4dClcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gU2Nyb2xsZXIyO1xufVxuZnVuY3Rpb24gYnVpbGRXaW5kb3dTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyMiwgdXNlRW1pdHRlcjogdXNlRW1pdHRlcjIsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlMiB9KSB7XG4gIGNvbnN0IFNjcm9sbGVyMiA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29XaW5kb3dTY3JvbGxlcih7IHN0eWxlLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSB1c2VQdWJsaXNoZXIyKFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gICAgY29uc3QgU2Nyb2xsZXJDb21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUyKFwiU2Nyb2xsZXJDb21wb25lbnRcIik7XG4gICAgY29uc3Qgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCA9IHVzZVB1Ymxpc2hlcjIoXCJzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkXCIpO1xuICAgIGNvbnN0IHRvdGFsTGlzdEhlaWdodCA9IHVzZUVtaXR0ZXJWYWx1ZTIoXCJ0b3RhbExpc3RIZWlnaHRcIik7XG4gICAgY29uc3QgZGV2aWF0aW9uID0gdXNlRW1pdHRlclZhbHVlMihcImRldmlhdGlvblwiKTtcbiAgICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUyKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUyKFwiY29udGV4dFwiKTtcbiAgICBjb25zdCB7IHNjcm9sbGVyUmVmLCBzY3JvbGxCeUNhbGxiYWNrLCBzY3JvbGxUb0NhbGxiYWNrIH0gPSB1c2VTY3JvbGxUb3AoXG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCxcbiAgICAgIFNjcm9sbGVyQ29tcG9uZW50LFxuICAgICAgbm9vcCxcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudFxuICAgICk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCQxKCgpID0+IHtcbiAgICAgIHNjcm9sbGVyUmVmLmN1cnJlbnQgPSBjdXN0b21TY3JvbGxQYXJlbnQgPyBjdXN0b21TY3JvbGxQYXJlbnQgOiB3aW5kb3c7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzY3JvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSwgW3Njcm9sbGVyUmVmLCBjdXN0b21TY3JvbGxQYXJlbnRdKTtcbiAgICB1c2VFbWl0dGVyMihcIndpbmRvd1Njcm9sbFRvXCIsIHNjcm9sbFRvQ2FsbGJhY2spO1xuICAgIHVzZUVtaXR0ZXIyKFwic2Nyb2xsQnlcIiwgc2Nyb2xsQnlDYWxsYmFjayk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTY3JvbGxlckNvbXBvbmVudCxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiwgLi4uc3R5bGUsIC4uLnRvdGFsTGlzdEhlaWdodCAhPT0gMCA/IHsgaGVpZ2h0OiB0b3RhbExpc3RIZWlnaHQgKyBkZXZpYXRpb24gfSA6IHt9IH0sXG4gICAgICAgIFwiZGF0YS12aXJ0dW9zby1zY3JvbGxlclwiOiB0cnVlLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoU2Nyb2xsZXJDb21wb25lbnQsIGNvbnRleHQpXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIFNjcm9sbGVyMjtcbn1cbmNvbnN0IFZpZXdwb3J0JDIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVmlydHVvc29Nb2NrQ29udGV4dCk7XG4gIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gdXNlUHVibGlzaGVyJDIoXCJ2aWV3cG9ydEhlaWdodFwiKTtcbiAgY29uc3QgZml4ZWRJdGVtSGVpZ2h0ID0gdXNlUHVibGlzaGVyJDIoXCJmaXhlZEl0ZW1IZWlnaHRcIik7XG4gIGNvbnN0IHZpZXdwb3J0UmVmID0gdXNlU2l6ZShjb21wb3NlKHZpZXdwb3J0SGVpZ2h0LCAoZWwpID0+IGNvcnJlY3RJdGVtU2l6ZShlbCwgXCJoZWlnaHRcIikpKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3R4KSB7XG4gICAgICB2aWV3cG9ydEhlaWdodChjdHgudmlld3BvcnRIZWlnaHQpO1xuICAgICAgZml4ZWRJdGVtSGVpZ2h0KGN0eC5pdGVtSGVpZ2h0KTtcbiAgICB9XG4gIH0sIFtjdHgsIHZpZXdwb3J0SGVpZ2h0LCBmaXhlZEl0ZW1IZWlnaHRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHZpZXdwb3J0U3R5bGUsIHJlZjogdmlld3BvcnRSZWYsIFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwiZWxlbWVudFwiIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBXaW5kb3dWaWV3cG9ydCQyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFZpcnR1b3NvTW9ja0NvbnRleHQpO1xuICBjb25zdCB3aW5kb3dWaWV3cG9ydFJlY3QgPSB1c2VQdWJsaXNoZXIkMihcIndpbmRvd1ZpZXdwb3J0UmVjdFwiKTtcbiAgY29uc3QgZml4ZWRJdGVtSGVpZ2h0ID0gdXNlUHVibGlzaGVyJDIoXCJmaXhlZEl0ZW1IZWlnaHRcIik7XG4gIGNvbnN0IGN1c3RvbVNjcm9sbFBhcmVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICBjb25zdCB2aWV3cG9ydFJlZiA9IHVzZVdpbmRvd1ZpZXdwb3J0UmVjdFJlZih3aW5kb3dWaWV3cG9ydFJlY3QsIGN1c3RvbVNjcm9sbFBhcmVudCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgZml4ZWRJdGVtSGVpZ2h0KGN0eC5pdGVtSGVpZ2h0KTtcbiAgICAgIHdpbmRvd1ZpZXdwb3J0UmVjdCh7IG9mZnNldFRvcDogMCwgdmlzaWJsZUhlaWdodDogY3R4LnZpZXdwb3J0SGVpZ2h0LCB2aXNpYmxlV2lkdGg6IDEwMCB9KTtcbiAgICB9XG4gIH0sIFtjdHgsIHdpbmRvd1ZpZXdwb3J0UmVjdCwgZml4ZWRJdGVtSGVpZ2h0XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdmlld3BvcnRSZWYsIHN0eWxlOiB2aWV3cG9ydFN0eWxlLCBcImRhdGEtdmlld3BvcnQtdHlwZVwiOiBcIndpbmRvd1wiIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBUb3BJdGVtTGlzdENvbnRhaW5lciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgVG9wSXRlbUxpc3QgPSB1c2VFbWl0dGVyVmFsdWUkMihcIlRvcEl0ZW1MaXN0Q29tcG9uZW50XCIpO1xuICBjb25zdCBoZWFkZXJIZWlnaHQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImhlYWRlckhlaWdodFwiKTtcbiAgY29uc3Qgc3R5bGUgPSB7IC4uLnRvcEl0ZW1MaXN0U3R5bGUsIG1hcmdpblRvcDogYCR7aGVhZGVySGVpZ2h0fXB4YCB9O1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjb250ZXh0XCIpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUb3BJdGVtTGlzdCB8fCBcImRpdlwiLCB7IHN0eWxlLCBjb250ZXh0IH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBMaXN0Um9vdCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvUm9vdChwcm9wcykge1xuICBjb25zdCB1c2VXaW5kb3dTY3JvbGwgPSB1c2VFbWl0dGVyVmFsdWUkMihcInVzZVdpbmRvd1Njcm9sbFwiKTtcbiAgY29uc3Qgc2hvd1RvcExpc3QgPSB1c2VFbWl0dGVyVmFsdWUkMihcInRvcEl0ZW1zSW5kZXhlc1wiKS5sZW5ndGggPiAwO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImN1c3RvbVNjcm9sbFBhcmVudFwiKTtcbiAgY29uc3QgVGhlU2Nyb2xsZXIgPSBjdXN0b21TY3JvbGxQYXJlbnQgfHwgdXNlV2luZG93U2Nyb2xsID8gV2luZG93U2Nyb2xsZXIkMiA6IFNjcm9sbGVyJDI7XG4gIGNvbnN0IFRoZVZpZXdwb3J0ID0gY3VzdG9tU2Nyb2xsUGFyZW50IHx8IHVzZVdpbmRvd1Njcm9sbCA/IFdpbmRvd1ZpZXdwb3J0JDIgOiBWaWV3cG9ydCQyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGhlU2Nyb2xsZXIsIHsgLi4ucHJvcHMgfSwgc2hvd1RvcExpc3QgJiYgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9wSXRlbUxpc3RDb250YWluZXIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEl0ZW1zJDEsIHsgc2hvd1RvcExpc3Q6IHRydWUgfSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUaGVWaWV3cG9ydCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGVyJDEsIG51bGwpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChJdGVtcyQxLCBudWxsKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vdGVyJDEsIG51bGwpKSk7XG59KTtcbmNvbnN0IHtcbiAgQ29tcG9uZW50OiBMaXN0LFxuICB1c2VQdWJsaXNoZXI6IHVzZVB1Ymxpc2hlciQyLFxuICB1c2VFbWl0dGVyVmFsdWU6IHVzZUVtaXR0ZXJWYWx1ZSQyLFxuICB1c2VFbWl0dGVyOiB1c2VFbWl0dGVyJDJcbn0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtVG9Db21wb25lbnQoXG4gIGNvbWJpbmVkU3lzdGVtJDIsXG4gIHtcbiAgICByZXF1aXJlZDoge30sXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHJlc3RvcmVTdGF0ZUZyb206IFwicmVzdG9yZVN0YXRlRnJvbVwiLFxuICAgICAgY29udGV4dDogXCJjb250ZXh0XCIsXG4gICAgICBmb2xsb3dPdXRwdXQ6IFwiZm9sbG93T3V0cHV0XCIsXG4gICAgICBpdGVtQ29udGVudDogXCJpdGVtQ29udGVudFwiLFxuICAgICAgZ3JvdXBDb250ZW50OiBcImdyb3VwQ29udGVudFwiLFxuICAgICAgb3ZlcnNjYW46IFwib3ZlcnNjYW5cIixcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogXCJpbmNyZWFzZVZpZXdwb3J0QnlcIixcbiAgICAgIHRvdGFsQ291bnQ6IFwidG90YWxDb3VudFwiLFxuICAgICAgZ3JvdXBDb3VudHM6IFwiZ3JvdXBDb3VudHNcIixcbiAgICAgIHRvcEl0ZW1Db3VudDogXCJ0b3BJdGVtQ291bnRcIixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBcImZpcnN0SXRlbUluZGV4XCIsXG4gICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDogXCJpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFwiLFxuICAgICAgY29tcG9uZW50czogXCJjb21wb25lbnRzXCIsXG4gICAgICBhdEJvdHRvbVRocmVzaG9sZDogXCJhdEJvdHRvbVRocmVzaG9sZFwiLFxuICAgICAgYXRUb3BUaHJlc2hvbGQ6IFwiYXRUb3BUaHJlc2hvbGRcIixcbiAgICAgIGNvbXB1dGVJdGVtS2V5OiBcImNvbXB1dGVJdGVtS2V5XCIsXG4gICAgICBkZWZhdWx0SXRlbUhlaWdodDogXCJkZWZhdWx0SXRlbUhlaWdodFwiLFxuICAgICAgZml4ZWRJdGVtSGVpZ2h0OiBcImZpeGVkSXRlbUhlaWdodFwiLFxuICAgICAgaXRlbVNpemU6IFwiaXRlbVNpemVcIixcbiAgICAgIHNjcm9sbFNlZWtDb25maWd1cmF0aW9uOiBcInNjcm9sbFNlZWtDb25maWd1cmF0aW9uXCIsXG4gICAgICBoZWFkZXJGb290ZXJUYWc6IFwiaGVhZGVyRm9vdGVyVGFnXCIsXG4gICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgIGluaXRpYWxJdGVtQ291bnQ6IFwiaW5pdGlhbEl0ZW1Db3VudFwiLFxuICAgICAgaW5pdGlhbFNjcm9sbFRvcDogXCJpbml0aWFsU2Nyb2xsVG9wXCIsXG4gICAgICBhbGlnblRvQm90dG9tOiBcImFsaWduVG9Cb3R0b21cIixcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogXCJ1c2VXaW5kb3dTY3JvbGxcIixcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudDogXCJjdXN0b21TY3JvbGxQYXJlbnRcIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBsb2dMZXZlbDogXCJsb2dMZXZlbFwiXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzY3JvbGxUb0luZGV4OiBcInNjcm9sbFRvSW5kZXhcIixcbiAgICAgIHNjcm9sbEludG9WaWV3OiBcInNjcm9sbEludG9WaWV3XCIsXG4gICAgICBzY3JvbGxUbzogXCJzY3JvbGxUb1wiLFxuICAgICAgc2Nyb2xsQnk6IFwic2Nyb2xsQnlcIixcbiAgICAgIGF1dG9zY3JvbGxUb0JvdHRvbTogXCJhdXRvc2Nyb2xsVG9Cb3R0b21cIixcbiAgICAgIGdldFN0YXRlOiBcImdldFN0YXRlXCJcbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgaXNTY3JvbGxpbmc6IFwiaXNTY3JvbGxpbmdcIixcbiAgICAgIGVuZFJlYWNoZWQ6IFwiZW5kUmVhY2hlZFwiLFxuICAgICAgc3RhcnRSZWFjaGVkOiBcInN0YXJ0UmVhY2hlZFwiLFxuICAgICAgcmFuZ2VDaGFuZ2VkOiBcInJhbmdlQ2hhbmdlZFwiLFxuICAgICAgYXRCb3R0b21TdGF0ZUNoYW5nZTogXCJhdEJvdHRvbVN0YXRlQ2hhbmdlXCIsXG4gICAgICBhdFRvcFN0YXRlQ2hhbmdlOiBcImF0VG9wU3RhdGVDaGFuZ2VcIixcbiAgICAgIHRvdGFsTGlzdEhlaWdodENoYW5nZWQ6IFwidG90YWxMaXN0SGVpZ2h0Q2hhbmdlZFwiLFxuICAgICAgaXRlbXNSZW5kZXJlZDogXCJpdGVtc1JlbmRlcmVkXCIsXG4gICAgICBncm91cEluZGljZXM6IFwiZ3JvdXBJbmRpY2VzXCJcbiAgICB9XG4gIH0sXG4gIExpc3RSb290XG4pO1xuY29uc3QgU2Nyb2xsZXIkMiA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZFNjcm9sbGVyKHsgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMiwgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMiwgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQyIH0pO1xuY29uc3QgV2luZG93U2Nyb2xsZXIkMiA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZFdpbmRvd1Njcm9sbGVyKHsgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMiwgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMiwgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQyIH0pO1xuY29uc3QgVmlydHVvc28gPSBMaXN0O1xuY29uc3QgR3JvdXBlZFZpcnR1b3NvID0gTGlzdDtcbmNvbnN0IElOSVRJQUxfR1JJRF9TVEFURSA9IHtcbiAgaXRlbXM6IFtdLFxuICBvZmZzZXRCb3R0b206IDAsXG4gIG9mZnNldFRvcDogMCxcbiAgdG9wOiAwLFxuICBib3R0b206IDAsXG4gIGl0ZW1IZWlnaHQ6IDAsXG4gIGl0ZW1XaWR0aDogMFxufTtcbmNvbnN0IFBST0JFX0dSSURfU1RBVEUgPSB7XG4gIGl0ZW1zOiBbeyBpbmRleDogMCB9XSxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICBpdGVtSGVpZ2h0OiAwLFxuICBpdGVtV2lkdGg6IDBcbn07XG5jb25zdCB7IHJvdW5kLCBjZWlsLCBmbG9vciwgbWluLCBtYXggfSA9IE1hdGg7XG5mdW5jdGlvbiBidWlsZFByb2JlR3JpZFN0YXRlKGl0ZW1zKSB7XG4gIHJldHVybiB7XG4gICAgLi4uUFJPQkVfR1JJRF9TVEFURSxcbiAgICBpdGVtc1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRJdGVtcyhzdGFydEluZGV4LCBlbmRJbmRleCwgZGF0YSkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogZW5kSW5kZXggLSBzdGFydEluZGV4ICsgMSB9KS5tYXAoKF8sIGkpID0+IHtcbiAgICBjb25zdCBkYXRhSXRlbSA9IGRhdGEgPT09IG51bGwgPyBudWxsIDogZGF0YVtpICsgc3RhcnRJbmRleF07XG4gICAgcmV0dXJuIHsgaW5kZXg6IGkgKyBzdGFydEluZGV4LCBkYXRhOiBkYXRhSXRlbSB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdhcENvbXBhcmF0b3IocHJldiwgbmV4dCkge1xuICByZXR1cm4gcHJldiAmJiBwcmV2LmNvbHVtbiA9PT0gbmV4dC5jb2x1bW4gJiYgcHJldi5yb3cgPT09IG5leHQucm93O1xufVxuZnVuY3Rpb24gZGltZW5zaW9uQ29tcGFyYXRvcihwcmV2LCBuZXh0KSB7XG4gIHJldHVybiBwcmV2ICYmIHByZXYud2lkdGggPT09IG5leHQud2lkdGggJiYgcHJldi5oZWlnaHQgPT09IG5leHQuaGVpZ2h0O1xufVxuY29uc3QgZ3JpZFN5c3RlbSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW0oXG4gIChbXG4gICAgeyBvdmVyc2NhbiwgdmlzaWJsZVJhbmdlLCBsaXN0Qm91bmRhcnkgfSxcbiAgICB7IHNjcm9sbFRvcCwgdmlld3BvcnRIZWlnaHQsIHNjcm9sbEJ5LCBzY3JvbGxUbywgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCwgc2Nyb2xsQ29udGFpbmVyU3RhdGUsIGZvb3RlckhlaWdodCwgaGVhZGVySGVpZ2h0IH0sXG4gICAgc3RhdGVGbGFncyxcbiAgICBzY3JvbGxTZWVrLFxuICAgIHsgcHJvcHNSZWFkeSwgZGlkTW91bnQgfSxcbiAgICB7IHdpbmRvd1ZpZXdwb3J0UmVjdCwgdXNlV2luZG93U2Nyb2xsLCBjdXN0b21TY3JvbGxQYXJlbnQsIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLCB3aW5kb3dTY3JvbGxUbyB9LFxuICAgIGxvZ1xuICBdKSA9PiB7XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGluaXRpYWxJdGVtQ291bnQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBncmlkU3RhdGUgPSBzdGF0ZWZ1bFN0cmVhbShJTklUSUFMX0dSSURfU1RBVEUpO1xuICAgIGNvbnN0IHZpZXdwb3J0RGltZW5zaW9ucyA9IHN0YXRlZnVsU3RyZWFtKHsgaGVpZ2h0OiAwLCB3aWR0aDogMCB9KTtcbiAgICBjb25zdCBpdGVtRGltZW5zaW9ucyA9IHN0YXRlZnVsU3RyZWFtKHsgaGVpZ2h0OiAwLCB3aWR0aDogMCB9KTtcbiAgICBjb25zdCBzY3JvbGxUb0luZGV4ID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gc3RyZWFtKCk7XG4gICAgY29uc3QgZGV2aWF0aW9uID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgZGF0YSA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICAgIGNvbnN0IGdhcCA9IHN0YXRlZnVsU3RyZWFtKHsgcm93OiAwLCBjb2x1bW46IDAgfSk7XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VkID0gc3RyZWFtKCk7XG4gICAgY29uc3QgcmVzdG9yZVN0YXRlRnJvbSA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXggPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0gPSBzdGF0ZWZ1bFN0cmVhbSh0cnVlKTtcbiAgICBjb25zdCBzY3JvbGxTY2hlZHVsZWQgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgZGlkTW91bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4KSxcbiAgICAgICAgZmlsdGVyKChbXywgbG9jYXRpb25dKSA9PiAhIWxvY2F0aW9uKVxuICAgICAgKSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgcHVibGlzaChzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sIGZhbHNlKTtcbiAgICAgICAgcHVibGlzaChpbml0aWFsSXRlbUNvdW50LCAwKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QoZGlkTW91bnQsIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSwgaXRlbURpbWVuc2lvbnMsIHZpZXdwb3J0RGltZW5zaW9ucywgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgsIHNjcm9sbFNjaGVkdWxlZCksXG4gICAgICAgIGZpbHRlcigoW2RpZE1vdW50Miwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMiwgaXRlbURpbWVuc2lvbnMyLCB2aWV3cG9ydERpbWVuc2lvbnMyLCAsIHNjcm9sbFNjaGVkdWxlZDJdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRpZE1vdW50MiAmJiAhc2Nyb2xsZWRUb0luaXRpYWxJdGVtMiAmJiBpdGVtRGltZW5zaW9uczIuaGVpZ2h0ICE9PSAwICYmIHZpZXdwb3J0RGltZW5zaW9uczIuaGVpZ2h0ICE9PSAwICYmICFzY3JvbGxTY2hlZHVsZWQyO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIChbLCAsICwgLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDJdKSA9PiB7XG4gICAgICAgIHB1Ymxpc2goc2Nyb2xsU2NoZWR1bGVkLCB0cnVlKTtcbiAgICAgICAgc2tpcEZyYW1lcygxLCAoKSA9PiB7XG4gICAgICAgICAgcHVibGlzaChzY3JvbGxUb0luZGV4LCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlTmV4dChwaXBlKHNjcm9sbFRvcCksICgpID0+IHtcbiAgICAgICAgICBwdWJsaXNoKGxpc3RCb3VuZGFyeSwgWzAsIDBdKTtcbiAgICAgICAgICBwdWJsaXNoKHNjcm9sbGVkVG9Jbml0aWFsSXRlbSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHJlc3RvcmVTdGF0ZUZyb20sXG4gICAgICAgIGZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuc2Nyb2xsVG9wID4gMCksXG4gICAgICAgIG1hcFRvKDApXG4gICAgICApLFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudFxuICAgICk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgZGlkTW91bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHJlc3RvcmVTdGF0ZUZyb20pLFxuICAgICAgICBmaWx0ZXIoKFssIHNuYXBzaG90XSkgPT4gc25hcHNob3QgIT09IHZvaWQgMCAmJiBzbmFwc2hvdCAhPT0gbnVsbClcbiAgICAgICksXG4gICAgICAoWywgc25hcHNob3RdKSA9PiB7XG4gICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHVibGlzaCh2aWV3cG9ydERpbWVuc2lvbnMsIHNuYXBzaG90LnZpZXdwb3J0KSwgcHVibGlzaChpdGVtRGltZW5zaW9ucywgc25hcHNob3QgPT0gbnVsbCA/IHZvaWQgMCA6IHNuYXBzaG90Lml0ZW0pO1xuICAgICAgICBwdWJsaXNoKGdhcCwgc25hcHNob3QuZ2FwKTtcbiAgICAgICAgaWYgKHNuYXBzaG90LnNjcm9sbFRvcCA+IDApIHtcbiAgICAgICAgICBwdWJsaXNoKHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MsIHRydWUpO1xuICAgICAgICAgIGhhbmRsZU5leHQocGlwZShzY3JvbGxUb3AsIHNraXAoMSkpLCAoX3ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBwdWJsaXNoKHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwdWJsaXNoKHNjcm9sbFRvLCB7IHRvcDogc25hcHNob3Quc2Nyb2xsVG9wIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgdmlld3BvcnREaW1lbnNpb25zLFxuICAgICAgICBtYXAoKHsgaGVpZ2h0IH0pID0+IGhlaWdodClcbiAgICAgICksXG4gICAgICB2aWV3cG9ydEhlaWdodFxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QoXG4gICAgICAgICAgZHVjKHZpZXdwb3J0RGltZW5zaW9ucywgZGltZW5zaW9uQ29tcGFyYXRvciksXG4gICAgICAgICAgZHVjKGl0ZW1EaW1lbnNpb25zLCBkaW1lbnNpb25Db21wYXJhdG9yKSxcbiAgICAgICAgICBkdWMoZ2FwLCAocHJldiwgbmV4dCkgPT4gcHJldiAmJiBwcmV2LmNvbHVtbiA9PT0gbmV4dC5jb2x1bW4gJiYgcHJldi5yb3cgPT09IG5leHQucm93KSxcbiAgICAgICAgICBkdWMoc2Nyb2xsVG9wKVxuICAgICAgICApLFxuICAgICAgICBtYXAoKFt2aWV3cG9ydCwgaXRlbSwgZ2FwMiwgc2Nyb2xsVG9wMl0pID0+ICh7XG4gICAgICAgICAgdmlld3BvcnQsXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBnYXA6IGdhcDIsXG4gICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyXG4gICAgICAgIH0pKVxuICAgICAgKSxcbiAgICAgIHN0YXRlQ2hhbmdlZFxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QoXG4gICAgICAgICAgZHVjKHRvdGFsQ291bnQpLFxuICAgICAgICAgIHZpc2libGVSYW5nZSxcbiAgICAgICAgICBkdWMoZ2FwLCBnYXBDb21wYXJhdG9yKSxcbiAgICAgICAgICBkdWMoaXRlbURpbWVuc2lvbnMsIGRpbWVuc2lvbkNvbXBhcmF0b3IpLFxuICAgICAgICAgIGR1Yyh2aWV3cG9ydERpbWVuc2lvbnMsIGRpbWVuc2lvbkNvbXBhcmF0b3IpLFxuICAgICAgICAgIGR1YyhkYXRhKSxcbiAgICAgICAgICBkdWMoaW5pdGlhbEl0ZW1Db3VudCksXG4gICAgICAgICAgZHVjKHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MpLFxuICAgICAgICAgIGR1YyhzY3JvbGxlZFRvSW5pdGlhbEl0ZW0pLFxuICAgICAgICAgIGR1Yyhpbml0aWFsVG9wTW9zdEl0ZW1JbmRleClcbiAgICAgICAgKSxcbiAgICAgICAgZmlsdGVyKChbLCAsICwgLCAsICwgLCBzdGF0ZVJlc3RvcmVJblByb2dyZXNzMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gIXN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MyO1xuICAgICAgICB9KSxcbiAgICAgICAgbWFwKFxuICAgICAgICAgIChbXG4gICAgICAgICAgICB0b3RhbENvdW50MixcbiAgICAgICAgICAgIFtzdGFydE9mZnNldCwgZW5kT2Zmc2V0XSxcbiAgICAgICAgICAgIGdhcDIsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgdmlld3BvcnQsXG4gICAgICAgICAgICBkYXRhMixcbiAgICAgICAgICAgIGluaXRpYWxJdGVtQ291bnQyLFxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMixcbiAgICAgICAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4MlxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcm93OiByb3dHYXAsIGNvbHVtbjogY29sdW1uR2FwIH0gPSBnYXAyO1xuICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQ6IGl0ZW1IZWlnaHQsIHdpZHRoOiBpdGVtV2lkdGggfSA9IGl0ZW07XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoOiB2aWV3cG9ydFdpZHRoIH0gPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIGlmIChpbml0aWFsSXRlbUNvdW50MiA9PT0gMCAmJiAodG90YWxDb3VudDIgPT09IDAgfHwgdmlld3BvcnRXaWR0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIElOSVRJQUxfR1JJRF9TVEFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleDIgPSBnZXRJbml0aWFsVG9wTW9zdEl0ZW1JbmRleE51bWJlcihpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDIsIHRvdGFsQ291bnQyKTtcbiAgICAgICAgICAgICAgY29uc3QgZW5kSW5kZXgyID0gc3RhcnRJbmRleDIgPT09IDAgPyBNYXRoLm1heChpbml0aWFsSXRlbUNvdW50MiAtIDEsIDApIDogc3RhcnRJbmRleDI7XG4gICAgICAgICAgICAgIHJldHVybiBidWlsZFByb2JlR3JpZFN0YXRlKGJ1aWxkSXRlbXMoc3RhcnRJbmRleDIsIGVuZEluZGV4MiwgZGF0YTIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlclJvdyA9IGl0ZW1zUGVyUm93KHZpZXdwb3J0V2lkdGgsIGl0ZW1XaWR0aCwgY29sdW1uR2FwKTtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4O1xuICAgICAgICAgICAgbGV0IGVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKCFzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yKSB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBlbmRJbmRleCA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IDAgJiYgaW5pdGlhbEl0ZW1Db3VudDIgPiAwKSB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBlbmRJbmRleCA9IGluaXRpYWxJdGVtQ291bnQyIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBwZXJSb3cgKiBmbG9vcigoc3RhcnRPZmZzZXQgKyByb3dHYXApIC8gKGl0ZW1IZWlnaHQgKyByb3dHYXApKTtcbiAgICAgICAgICAgICAgZW5kSW5kZXggPSBwZXJSb3cgKiBjZWlsKChlbmRPZmZzZXQgKyByb3dHYXApIC8gKGl0ZW1IZWlnaHQgKyByb3dHYXApKSAtIDE7XG4gICAgICAgICAgICAgIGVuZEluZGV4ID0gbWluKHRvdGFsQ291bnQyIC0gMSwgbWF4KGVuZEluZGV4LCBwZXJSb3cgLSAxKSk7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaW4oZW5kSW5kZXgsIG1heCgwLCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGJ1aWxkSXRlbXMoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRhdGEyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9wLCBib3R0b20gfSA9IGdyaWRMYXlvdXQodmlld3BvcnQsIGdhcDIsIGl0ZW0sIGl0ZW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd0NvdW50ID0gY2VpbCh0b3RhbENvdW50MiAvIHBlclJvdyk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IHJvd0NvdW50ICogaXRlbUhlaWdodCArIChyb3dDb3VudCAtIDEpICogcm93R2FwO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0Qm90dG9tID0gdG90YWxIZWlnaHQgLSBib3R0b207XG4gICAgICAgICAgICByZXR1cm4geyBpdGVtcywgb2Zmc2V0VG9wOiB0b3AsIG9mZnNldEJvdHRvbSwgdG9wLCBib3R0b20sIGl0ZW1IZWlnaHQsIGl0ZW1XaWR0aCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGdyaWRTdGF0ZVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGZpbHRlcigoZGF0YTIpID0+IGRhdGEyICE9PSBudWxsKSxcbiAgICAgICAgbWFwKChkYXRhMikgPT4gZGF0YTIubGVuZ3RoKVxuICAgICAgKSxcbiAgICAgIHRvdGFsQ291bnRcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KHZpZXdwb3J0RGltZW5zaW9ucywgaXRlbURpbWVuc2lvbnMsIGdyaWRTdGF0ZSwgZ2FwKSxcbiAgICAgICAgZmlsdGVyKChbdmlld3BvcnREaW1lbnNpb25zMiwgaXRlbURpbWVuc2lvbnMyLCB7IGl0ZW1zIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCA+IDAgJiYgaXRlbURpbWVuc2lvbnMyLmhlaWdodCAhPT0gMCAmJiB2aWV3cG9ydERpbWVuc2lvbnMyLmhlaWdodCAhPT0gMDtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcCgoW3ZpZXdwb3J0RGltZW5zaW9uczIsIGl0ZW1EaW1lbnNpb25zMiwgeyBpdGVtcyB9LCBnYXAyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdG9wLCBib3R0b20gfSA9IGdyaWRMYXlvdXQodmlld3BvcnREaW1lbnNpb25zMiwgZ2FwMiwgaXRlbURpbWVuc2lvbnMyLCBpdGVtcyk7XG4gICAgICAgICAgcmV0dXJuIFt0b3AsIGJvdHRvbV07XG4gICAgICAgIH0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCh0dXBsZUNvbXBhcmF0b3IpXG4gICAgICApLFxuICAgICAgbGlzdEJvdW5kYXJ5XG4gICAgKTtcbiAgICBjb25zdCBoYXNTY3JvbGxlZCA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2Nyb2xsVG9wLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShoYXNTY3JvbGxlZCksXG4gICAgICAgIG1hcCgoW3Njcm9sbFRvcDIsIGhhc1Njcm9sbGVkMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gaGFzU2Nyb2xsZWQyIHx8IHNjcm9sbFRvcDIgIT09IDA7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgaGFzU2Nyb2xsZWRcbiAgICApO1xuICAgIGNvbnN0IGVuZFJlYWNoZWQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGR1YyhncmlkU3RhdGUpLFxuICAgICAgICBmaWx0ZXIoKHsgaXRlbXMgfSkgPT4gaXRlbXMubGVuZ3RoID4gMCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHRvdGFsQ291bnQsIGhhc1Njcm9sbGVkKSxcbiAgICAgICAgZmlsdGVyKChbeyBpdGVtcyB9LCB0b3RhbENvdW50MiwgaGFzU2Nyb2xsZWQyXSkgPT4gaGFzU2Nyb2xsZWQyICYmIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLmluZGV4ID09PSB0b3RhbENvdW50MiAtIDEpLFxuICAgICAgICBtYXAoKFssIHRvdGFsQ291bnQyXSkgPT4gdG90YWxDb3VudDIgLSAxKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3Qgc3RhcnRSZWFjaGVkID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBkdWMoZ3JpZFN0YXRlKSxcbiAgICAgICAgZmlsdGVyKCh7IGl0ZW1zIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gaXRlbXMubGVuZ3RoID4gMCAmJiBpdGVtc1swXS5pbmRleCA9PT0gMDtcbiAgICAgICAgfSksXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIG1hcFRvKDApLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCByYW5nZUNoYW5nZWQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGR1YyhncmlkU3RhdGUpLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzdGF0ZVJlc3RvcmVJblByb2dyZXNzKSxcbiAgICAgICAgZmlsdGVyKChbeyBpdGVtcyB9LCBzdGF0ZVJlc3RvcmVJblByb2dyZXNzMl0pID0+IGl0ZW1zLmxlbmd0aCA+IDAgJiYgIXN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MyKSxcbiAgICAgICAgbWFwKChbeyBpdGVtcyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydEluZGV4OiBpdGVtc1swXS5pbmRleCxcbiAgICAgICAgICAgIGVuZEluZGV4OiBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZChyYW5nZUNvbXBhcmF0b3IpLFxuICAgICAgICB0aHJvdHRsZVRpbWUoMClcbiAgICAgIClcbiAgICApO1xuICAgIGNvbm5lY3QocmFuZ2VDaGFuZ2VkLCBzY3JvbGxTZWVrLnNjcm9sbFNlZWtSYW5nZUNoYW5nZWQpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBzY3JvbGxUb0luZGV4LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbSh2aWV3cG9ydERpbWVuc2lvbnMsIGl0ZW1EaW1lbnNpb25zLCB0b3RhbENvdW50LCBnYXApLFxuICAgICAgICBtYXAoKFtsb2NhdGlvbiwgdmlld3BvcnREaW1lbnNpb25zMiwgaXRlbURpbWVuc2lvbnMyLCB0b3RhbENvdW50MiwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBub3JtYWxMb2NhdGlvbiA9IG5vcm1hbGl6ZUluZGV4TG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHsgYWxpZ24sIGJlaGF2aW9yLCBvZmZzZXQgfSA9IG5vcm1hbExvY2F0aW9uO1xuICAgICAgICAgIGxldCBpbmRleCA9IG5vcm1hbExvY2F0aW9uLmluZGV4O1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gXCJMQVNUXCIpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdG90YWxDb3VudDIgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleCA9IG1heCgwLCBpbmRleCwgbWluKHRvdGFsQ291bnQyIC0gMSwgaW5kZXgpKTtcbiAgICAgICAgICBsZXQgdG9wID0gaXRlbVRvcCh2aWV3cG9ydERpbWVuc2lvbnMyLCBnYXAyLCBpdGVtRGltZW5zaW9uczIsIGluZGV4KTtcbiAgICAgICAgICBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgIHRvcCA9IHJvdW5kKHRvcCAtIHZpZXdwb3J0RGltZW5zaW9uczIuaGVpZ2h0ICsgaXRlbURpbWVuc2lvbnMyLmhlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgdG9wID0gcm91bmQodG9wIC0gdmlld3BvcnREaW1lbnNpb25zMi5oZWlnaHQgLyAyICsgaXRlbURpbWVuc2lvbnMyLmhlaWdodCAvIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0b3AgKz0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyB0b3AsIGJlaGF2aW9yIH07XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2Nyb2xsVG9cbiAgICApO1xuICAgIGNvbnN0IHRvdGFsTGlzdEhlaWdodCA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBncmlkU3RhdGUsXG4gICAgICAgIG1hcCgoZ3JpZFN0YXRlMikgPT4ge1xuICAgICAgICAgIHJldHVybiBncmlkU3RhdGUyLm9mZnNldEJvdHRvbSArIGdyaWRTdGF0ZTIuYm90dG9tO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICB3aW5kb3dWaWV3cG9ydFJlY3QsXG4gICAgICAgIG1hcCgodmlld3BvcnRJbmZvKSA9PiAoeyB3aWR0aDogdmlld3BvcnRJbmZvLnZpc2libGVXaWR0aCwgaGVpZ2h0OiB2aWV3cG9ydEluZm8udmlzaWJsZUhlaWdodCB9KSlcbiAgICAgICksXG4gICAgICB2aWV3cG9ydERpbWVuc2lvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgZGF0YSxcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgICB2aWV3cG9ydERpbWVuc2lvbnMsXG4gICAgICBpdGVtRGltZW5zaW9ucyxcbiAgICAgIHNjcm9sbFRvcCxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIG92ZXJzY2FuLFxuICAgICAgc2Nyb2xsQnksXG4gICAgICBzY3JvbGxUbyxcbiAgICAgIHNjcm9sbFRvSW5kZXgsXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkLFxuICAgICAgd2luZG93Vmlld3BvcnRSZWN0LFxuICAgICAgd2luZG93U2Nyb2xsVG8sXG4gICAgICB1c2VXaW5kb3dTY3JvbGwsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnQsXG4gICAgICB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgIGRldmlhdGlvbixcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlLFxuICAgICAgZm9vdGVySGVpZ2h0LFxuICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudCxcbiAgICAgIGdhcCxcbiAgICAgIHJlc3RvcmVTdGF0ZUZyb20sXG4gICAgICAuLi5zY3JvbGxTZWVrLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgsXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIGdyaWRTdGF0ZSxcbiAgICAgIHRvdGFsTGlzdEhlaWdodCxcbiAgICAgIC4uLnN0YXRlRmxhZ3MsXG4gICAgICBzdGFydFJlYWNoZWQsXG4gICAgICBlbmRSZWFjaGVkLFxuICAgICAgcmFuZ2VDaGFuZ2VkLFxuICAgICAgc3RhdGVDaGFuZ2VkLFxuICAgICAgcHJvcHNSZWFkeSxcbiAgICAgIHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MsXG4gICAgICAuLi5sb2dcbiAgICB9O1xuICB9LFxuICB0dXAoc2l6ZVJhbmdlU3lzdGVtLCBkb21JT1N5c3RlbSwgc3RhdGVGbGFnc1N5c3RlbSwgc2Nyb2xsU2Vla1N5c3RlbSwgcHJvcHNSZWFkeVN5c3RlbSwgd2luZG93U2Nyb2xsZXJTeXN0ZW0sIGxvZ2dlclN5c3RlbSlcbik7XG5mdW5jdGlvbiBncmlkTGF5b3V0KHZpZXdwb3J0LCBnYXAsIGl0ZW0sIGl0ZW1zKSB7XG4gIGNvbnN0IHsgaGVpZ2h0OiBpdGVtSGVpZ2h0IH0gPSBpdGVtO1xuICBpZiAoaXRlbUhlaWdodCA9PT0gdm9pZCAwIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IHRvcDogMCwgYm90dG9tOiAwIH07XG4gIH1cbiAgY29uc3QgdG9wID0gaXRlbVRvcCh2aWV3cG9ydCwgZ2FwLCBpdGVtLCBpdGVtc1swXS5pbmRleCk7XG4gIGNvbnN0IGJvdHRvbSA9IGl0ZW1Ub3Aodmlld3BvcnQsIGdhcCwgaXRlbSwgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0uaW5kZXgpICsgaXRlbUhlaWdodDtcbiAgcmV0dXJuIHsgdG9wLCBib3R0b20gfTtcbn1cbmZ1bmN0aW9uIGl0ZW1Ub3Aodmlld3BvcnQsIGdhcCwgaXRlbSwgaW5kZXgpIHtcbiAgY29uc3QgcGVyUm93ID0gaXRlbXNQZXJSb3codmlld3BvcnQud2lkdGgsIGl0ZW0ud2lkdGgsIGdhcC5jb2x1bW4pO1xuICBjb25zdCByb3dDb3VudCA9IGZsb29yKGluZGV4IC8gcGVyUm93KTtcbiAgY29uc3QgdG9wID0gcm93Q291bnQgKiBpdGVtLmhlaWdodCArIG1heCgwLCByb3dDb3VudCAtIDEpICogZ2FwLnJvdztcbiAgcmV0dXJuIHRvcCA+IDAgPyB0b3AgKyBnYXAucm93IDogdG9wO1xufVxuZnVuY3Rpb24gaXRlbXNQZXJSb3codmlld3BvcnRXaWR0aCwgaXRlbVdpZHRoLCBnYXApIHtcbiAgcmV0dXJuIG1heCgxLCBmbG9vcigodmlld3BvcnRXaWR0aCArIGdhcCkgLyAoZmxvb3IoaXRlbVdpZHRoKSArIGdhcCkpKTtcbn1cbmNvbnN0IGdyaWRDb21wb25lbnRQcm9wc1N5c3RlbSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW0oKCkgPT4ge1xuICBjb25zdCBpdGVtQ29udGVudCA9IHN0YXRlZnVsU3RyZWFtKChpbmRleCkgPT4gYEl0ZW0gJHtpbmRleH1gKTtcbiAgY29uc3QgY29tcG9uZW50cyA9IHN0YXRlZnVsU3RyZWFtKHt9KTtcbiAgY29uc3QgY29udGV4dCA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICBjb25zdCBpdGVtQ2xhc3NOYW1lID0gc3RhdGVmdWxTdHJlYW0oXCJ2aXJ0dW9zby1ncmlkLWl0ZW1cIik7XG4gIGNvbnN0IGxpc3RDbGFzc05hbWUgPSBzdGF0ZWZ1bFN0cmVhbShcInZpcnR1b3NvLWdyaWQtbGlzdFwiKTtcbiAgY29uc3QgY29tcHV0ZUl0ZW1LZXkgPSBzdGF0ZWZ1bFN0cmVhbShpZGVudGl0eSk7XG4gIGNvbnN0IGhlYWRlckZvb3RlclRhZyA9IHN0YXRlZnVsU3RyZWFtKFwiZGl2XCIpO1xuICBjb25zdCBzY3JvbGxlclJlZiA9IHN0YXRlZnVsU3RyZWFtKG5vb3ApO1xuICBjb25zdCBkaXN0aW5jdFByb3AgPSAocHJvcE5hbWUsIGRlZmF1bHRWYWx1ZSA9IG51bGwpID0+IHtcbiAgICByZXR1cm4gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgIG1hcCgoY29tcG9uZW50czIpID0+IGNvbXBvbmVudHMyW3Byb3BOYW1lXSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICksXG4gICAgICBkZWZhdWx0VmFsdWVcbiAgICApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQsXG4gICAgaXRlbUNvbnRlbnQsXG4gICAgY29tcG9uZW50cyxcbiAgICBjb21wdXRlSXRlbUtleSxcbiAgICBpdGVtQ2xhc3NOYW1lLFxuICAgIGxpc3RDbGFzc05hbWUsXG4gICAgaGVhZGVyRm9vdGVyVGFnLFxuICAgIHNjcm9sbGVyUmVmLFxuICAgIEZvb3RlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiRm9vdGVyXCIpLFxuICAgIEhlYWRlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiSGVhZGVyXCIpLFxuICAgIExpc3RDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkxpc3RcIiwgXCJkaXZcIiksXG4gICAgSXRlbUNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiSXRlbVwiLCBcImRpdlwiKSxcbiAgICBTY3JvbGxlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyOiBkaXN0aW5jdFByb3AoXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIiwgXCJkaXZcIilcbiAgfTtcbn0pO1xuY29uc3QgY29tYmluZWRTeXN0ZW0kMSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW0oKFtncmlkU3lzdGVtMiwgZ3JpZENvbXBvbmVudFByb3BzU3lzdGVtMl0pID0+IHtcbiAgcmV0dXJuIHsgLi4uZ3JpZFN5c3RlbTIsIC4uLmdyaWRDb21wb25lbnRQcm9wc1N5c3RlbTIgfTtcbn0sIHR1cChncmlkU3lzdGVtLCBncmlkQ29tcG9uZW50UHJvcHNTeXN0ZW0pKTtcbmNvbnN0IEdyaWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5tZW1vKGZ1bmN0aW9uIEdyaWRJdGVtczIoKSB7XG4gIGNvbnN0IGdyaWRTdGF0ZSA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiZ3JpZFN0YXRlXCIpO1xuICBjb25zdCBsaXN0Q2xhc3NOYW1lID0gdXNlRW1pdHRlclZhbHVlJDEoXCJsaXN0Q2xhc3NOYW1lXCIpO1xuICBjb25zdCBpdGVtQ2xhc3NOYW1lID0gdXNlRW1pdHRlclZhbHVlJDEoXCJpdGVtQ2xhc3NOYW1lXCIpO1xuICBjb25zdCBpdGVtQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiaXRlbUNvbnRlbnRcIik7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJjb21wdXRlSXRlbUtleVwiKTtcbiAgY29uc3QgaXNTZWVraW5nID0gdXNlRW1pdHRlclZhbHVlJDEoXCJpc1NlZWtpbmdcIik7XG4gIGNvbnN0IHNjcm9sbEhlaWdodENhbGxiYWNrID0gdXNlUHVibGlzaGVyJDEoXCJzY3JvbGxIZWlnaHRcIik7XG4gIGNvbnN0IEl0ZW1Db21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUkMShcIkl0ZW1Db21wb25lbnRcIik7XG4gIGNvbnN0IExpc3RDb21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUkMShcIkxpc3RDb21wb25lbnRcIik7XG4gIGNvbnN0IFNjcm9sbFNlZWtQbGFjZWhvbGRlciA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJjb250ZXh0XCIpO1xuICBjb25zdCBpdGVtRGltZW5zaW9ucyA9IHVzZVB1Ymxpc2hlciQxKFwiaXRlbURpbWVuc2lvbnNcIik7XG4gIGNvbnN0IGdyaWRHYXAgPSB1c2VQdWJsaXNoZXIkMShcImdhcFwiKTtcbiAgY29uc3QgbG9nID0gdXNlRW1pdHRlclZhbHVlJDEoXCJsb2dcIik7XG4gIGNvbnN0IHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MgPSB1c2VFbWl0dGVyVmFsdWUkMShcInN0YXRlUmVzdG9yZUluUHJvZ3Jlc3NcIik7XG4gIGNvbnN0IGxpc3RSZWYgPSB1c2VTaXplKChlbCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IGVsLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgc2Nyb2xsSGVpZ2h0Q2FsbGJhY2soc2Nyb2xsSGVpZ2h0KTtcbiAgICBjb25zdCBmaXJzdEl0ZW0gPSBlbC5maXJzdENoaWxkO1xuICAgIGlmIChmaXJzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZmlyc3RJdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaXRlbURpbWVuc2lvbnMoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIH1cbiAgICBncmlkR2FwKHtcbiAgICAgIHJvdzogcmVzb2x2ZUdhcFZhbHVlKFwicm93LWdhcFwiLCBnZXRDb21wdXRlZFN0eWxlKGVsKS5yb3dHYXAsIGxvZyksXG4gICAgICBjb2x1bW46IHJlc29sdmVHYXBWYWx1ZShcImNvbHVtbi1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkuY29sdW1uR2FwLCBsb2cpXG4gICAgfSk7XG4gIH0pO1xuICBpZiAoc3RhdGVSZXN0b3JlSW5Qcm9ncmVzcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIExpc3RDb21wb25lbnQsXG4gICAge1xuICAgICAgcmVmOiBsaXN0UmVmLFxuICAgICAgY2xhc3NOYW1lOiBsaXN0Q2xhc3NOYW1lLFxuICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoTGlzdENvbXBvbmVudCwgY29udGV4dCksXG4gICAgICBzdHlsZTogeyBwYWRkaW5nVG9wOiBncmlkU3RhdGUub2Zmc2V0VG9wLCBwYWRkaW5nQm90dG9tOiBncmlkU3RhdGUub2Zmc2V0Qm90dG9tIH0sXG4gICAgICBcImRhdGEtdGVzdC1pZFwiOiBcInZpcnR1b3NvLWl0ZW0tbGlzdFwiXG4gICAgfSxcbiAgICBncmlkU3RhdGUuaXRlbXMubWFwKChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBjb21wdXRlSXRlbUtleShpdGVtLmluZGV4LCBpdGVtLmRhdGEsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGlzU2Vla2luZyA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Nyb2xsU2Vla1BsYWNlaG9sZGVyLCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoU2Nyb2xsU2Vla1BsYWNlaG9sZGVyLCBjb250ZXh0KSxcbiAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgIGhlaWdodDogZ3JpZFN0YXRlLml0ZW1IZWlnaHQsXG4gICAgICAgIHdpZHRoOiBncmlkU3RhdGUuaXRlbVdpZHRoXG4gICAgICB9KSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEl0ZW1Db21wb25lbnQsXG4gICAgICAgIHsgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoSXRlbUNvbXBvbmVudCwgY29udGV4dCksIGNsYXNzTmFtZTogaXRlbUNsYXNzTmFtZSwgXCJkYXRhLWluZGV4XCI6IGl0ZW0uaW5kZXgsIGtleSB9LFxuICAgICAgICBpdGVtQ29udGVudChpdGVtLmluZGV4LCBpdGVtLmRhdGEsIGNvbnRleHQpXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59KTtcbmNvbnN0IEhlYWRlciA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29IZWFkZXIyKCkge1xuICBjb25zdCBIZWFkZXIyID0gdXNlRW1pdHRlclZhbHVlJDEoXCJIZWFkZXJDb21wb25lbnRcIik7XG4gIGNvbnN0IGhlYWRlckhlaWdodCA9IHVzZVB1Ymxpc2hlciQxKFwiaGVhZGVySGVpZ2h0XCIpO1xuICBjb25zdCBoZWFkZXJGb290ZXJUYWcgPSB1c2VFbWl0dGVyVmFsdWUkMShcImhlYWRlckZvb3RlclRhZ1wiKTtcbiAgY29uc3QgcmVmID0gdXNlU2l6ZSgoZWwpID0+IGhlYWRlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMShcImNvbnRleHRcIik7XG4gIHJldHVybiBIZWFkZXIyID8gUmVhY3QuY3JlYXRlRWxlbWVudChoZWFkZXJGb290ZXJUYWcsIHsgcmVmIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGVyMiwgY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoSGVhZGVyMiwgY29udGV4dCkpKSA6IG51bGw7XG59KTtcbmNvbnN0IEZvb3RlciA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29HcmlkRm9vdGVyKCkge1xuICBjb25zdCBGb290ZXIyID0gdXNlRW1pdHRlclZhbHVlJDEoXCJGb290ZXJDb21wb25lbnRcIik7XG4gIGNvbnN0IGZvb3RlckhlaWdodCA9IHVzZVB1Ymxpc2hlciQxKFwiZm9vdGVySGVpZ2h0XCIpO1xuICBjb25zdCBoZWFkZXJGb290ZXJUYWcgPSB1c2VFbWl0dGVyVmFsdWUkMShcImhlYWRlckZvb3RlclRhZ1wiKTtcbiAgY29uc3QgcmVmID0gdXNlU2l6ZSgoZWwpID0+IGZvb3RlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMShcImNvbnRleHRcIik7XG4gIHJldHVybiBGb290ZXIyID8gUmVhY3QuY3JlYXRlRWxlbWVudChoZWFkZXJGb290ZXJUYWcsIHsgcmVmIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vdGVyMiwgY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoRm9vdGVyMiwgY29udGV4dCkpKSA6IG51bGw7XG59KTtcbmNvbnN0IFZpZXdwb3J0JDEgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVmlydHVvc29HcmlkTW9ja0NvbnRleHQpO1xuICBjb25zdCBpdGVtRGltZW5zaW9ucyA9IHVzZVB1Ymxpc2hlciQxKFwiaXRlbURpbWVuc2lvbnNcIik7XG4gIGNvbnN0IHZpZXdwb3J0RGltZW5zaW9ucyA9IHVzZVB1Ymxpc2hlciQxKFwidmlld3BvcnREaW1lbnNpb25zXCIpO1xuICBjb25zdCB2aWV3cG9ydFJlZiA9IHVzZVNpemUoKGVsKSA9PiB7XG4gICAgdmlld3BvcnREaW1lbnNpb25zKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgdmlld3BvcnREaW1lbnNpb25zKHsgaGVpZ2h0OiBjdHgudmlld3BvcnRIZWlnaHQsIHdpZHRoOiBjdHgudmlld3BvcnRXaWR0aCB9KTtcbiAgICAgIGl0ZW1EaW1lbnNpb25zKHsgaGVpZ2h0OiBjdHguaXRlbUhlaWdodCwgd2lkdGg6IGN0eC5pdGVtV2lkdGggfSk7XG4gICAgfVxuICB9LCBbY3R4LCB2aWV3cG9ydERpbWVuc2lvbnMsIGl0ZW1EaW1lbnNpb25zXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB2aWV3cG9ydFN0eWxlLCByZWY6IHZpZXdwb3J0UmVmIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBXaW5kb3dWaWV3cG9ydCQxID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFZpcnR1b3NvR3JpZE1vY2tDb250ZXh0KTtcbiAgY29uc3Qgd2luZG93Vmlld3BvcnRSZWN0ID0gdXNlUHVibGlzaGVyJDEoXCJ3aW5kb3dWaWV3cG9ydFJlY3RcIik7XG4gIGNvbnN0IGl0ZW1EaW1lbnNpb25zID0gdXNlUHVibGlzaGVyJDEoXCJpdGVtRGltZW5zaW9uc1wiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IHZpZXdwb3J0UmVmID0gdXNlV2luZG93Vmlld3BvcnRSZWN0UmVmKHdpbmRvd1ZpZXdwb3J0UmVjdCwgY3VzdG9tU2Nyb2xsUGFyZW50KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3R4KSB7XG4gICAgICBpdGVtRGltZW5zaW9ucyh7IGhlaWdodDogY3R4Lml0ZW1IZWlnaHQsIHdpZHRoOiBjdHguaXRlbVdpZHRoIH0pO1xuICAgICAgd2luZG93Vmlld3BvcnRSZWN0KHsgb2Zmc2V0VG9wOiAwLCB2aXNpYmxlSGVpZ2h0OiBjdHgudmlld3BvcnRIZWlnaHQsIHZpc2libGVXaWR0aDogY3R4LnZpZXdwb3J0V2lkdGggfSk7XG4gICAgfVxuICB9LCBbY3R4LCB3aW5kb3dWaWV3cG9ydFJlY3QsIGl0ZW1EaW1lbnNpb25zXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdmlld3BvcnRSZWYsIHN0eWxlOiB2aWV3cG9ydFN0eWxlIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBHcmlkUm9vdCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5tZW1vKGZ1bmN0aW9uIEdyaWRSb290Mih7IC4uLnByb3BzIH0pIHtcbiAgY29uc3QgdXNlV2luZG93U2Nyb2xsID0gdXNlRW1pdHRlclZhbHVlJDEoXCJ1c2VXaW5kb3dTY3JvbGxcIik7XG4gIGNvbnN0IGN1c3RvbVNjcm9sbFBhcmVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICBjb25zdCBUaGVTY3JvbGxlciA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dTY3JvbGxlciQxIDogU2Nyb2xsZXIkMTtcbiAgY29uc3QgVGhlVmlld3BvcnQgPSBjdXN0b21TY3JvbGxQYXJlbnQgfHwgdXNlV2luZG93U2Nyb2xsID8gV2luZG93Vmlld3BvcnQkMSA6IFZpZXdwb3J0JDE7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUaGVTY3JvbGxlciwgeyAuLi5wcm9wcyB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUaGVWaWV3cG9ydCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGVyLCBudWxsKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JpZEl0ZW1zLCBudWxsKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vdGVyLCBudWxsKSkpO1xufSk7XG5jb25zdCB7XG4gIENvbXBvbmVudDogR3JpZCxcbiAgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMSxcbiAgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMSxcbiAgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQxXG59ID0gLyogQF9fUFVSRV9fICovIHN5c3RlbVRvQ29tcG9uZW50KFxuICBjb21iaW5lZFN5c3RlbSQxLFxuICB7XG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIGNvbnRleHQ6IFwiY29udGV4dFwiLFxuICAgICAgdG90YWxDb3VudDogXCJ0b3RhbENvdW50XCIsXG4gICAgICBvdmVyc2NhbjogXCJvdmVyc2NhblwiLFxuICAgICAgaXRlbUNvbnRlbnQ6IFwiaXRlbUNvbnRlbnRcIixcbiAgICAgIGNvbXBvbmVudHM6IFwiY29tcG9uZW50c1wiLFxuICAgICAgY29tcHV0ZUl0ZW1LZXk6IFwiY29tcHV0ZUl0ZW1LZXlcIixcbiAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudDogXCJpbml0aWFsSXRlbUNvdW50XCIsXG4gICAgICBzY3JvbGxTZWVrQ29uZmlndXJhdGlvbjogXCJzY3JvbGxTZWVrQ29uZmlndXJhdGlvblwiLFxuICAgICAgaGVhZGVyRm9vdGVyVGFnOiBcImhlYWRlckZvb3RlclRhZ1wiLFxuICAgICAgbGlzdENsYXNzTmFtZTogXCJsaXN0Q2xhc3NOYW1lXCIsXG4gICAgICBpdGVtQ2xhc3NOYW1lOiBcIml0ZW1DbGFzc05hbWVcIixcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogXCJ1c2VXaW5kb3dTY3JvbGxcIixcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudDogXCJjdXN0b21TY3JvbGxQYXJlbnRcIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBsb2dMZXZlbDogXCJsb2dMZXZlbFwiLFxuICAgICAgcmVzdG9yZVN0YXRlRnJvbTogXCJyZXN0b3JlU3RhdGVGcm9tXCIsXG4gICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDogXCJpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFwiXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzY3JvbGxUbzogXCJzY3JvbGxUb1wiLFxuICAgICAgc2Nyb2xsQnk6IFwic2Nyb2xsQnlcIixcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFwic2Nyb2xsVG9JbmRleFwiXG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgIGlzU2Nyb2xsaW5nOiBcImlzU2Nyb2xsaW5nXCIsXG4gICAgICBlbmRSZWFjaGVkOiBcImVuZFJlYWNoZWRcIixcbiAgICAgIHN0YXJ0UmVhY2hlZDogXCJzdGFydFJlYWNoZWRcIixcbiAgICAgIHJhbmdlQ2hhbmdlZDogXCJyYW5nZUNoYW5nZWRcIixcbiAgICAgIGF0Qm90dG9tU3RhdGVDaGFuZ2U6IFwiYXRCb3R0b21TdGF0ZUNoYW5nZVwiLFxuICAgICAgYXRUb3BTdGF0ZUNoYW5nZTogXCJhdFRvcFN0YXRlQ2hhbmdlXCIsXG4gICAgICBzdGF0ZUNoYW5nZWQ6IFwic3RhdGVDaGFuZ2VkXCJcbiAgICB9XG4gIH0sXG4gIEdyaWRSb290XG4pO1xuY29uc3QgU2Nyb2xsZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZFNjcm9sbGVyKHsgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMSwgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMSwgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQxIH0pO1xuY29uc3QgV2luZG93U2Nyb2xsZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZFdpbmRvd1Njcm9sbGVyKHsgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMSwgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMSwgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQxIH0pO1xuZnVuY3Rpb24gcmVzb2x2ZUdhcFZhbHVlKHByb3BlcnR5LCB2YWx1ZSwgbG9nKSB7XG4gIGlmICh2YWx1ZSAhPT0gXCJub3JtYWxcIiAmJiAhKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5lbmRzV2l0aChcInB4XCIpKSkge1xuICAgIGxvZyhgJHtwcm9wZXJ0eX0gd2FzIG5vdCByZXNvbHZlZCB0byBwaXhlbCB2YWx1ZSBjb3JyZWN0bHlgLCB2YWx1ZSwgTG9nTGV2ZWwuV0FSTik7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiMFwiLCAxMCk7XG59XG5jb25zdCBWaXJ0dW9zb0dyaWQgPSBHcmlkO1xuY29uc3QgdGFibGVDb21wb25lbnRQcm9wc1N5c3RlbSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW0oKCkgPT4ge1xuICBjb25zdCBpdGVtQ29udGVudCA9IHN0YXRlZnVsU3RyZWFtKChpbmRleCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsLCBcIkl0ZW0gJFwiLCBpbmRleCkpO1xuICBjb25zdCBjb250ZXh0ID0gc3RhdGVmdWxTdHJlYW0obnVsbCk7XG4gIGNvbnN0IGZpeGVkSGVhZGVyQ29udGVudCA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICBjb25zdCBmaXhlZEZvb3RlckNvbnRlbnQgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgY29uc3QgY29tcG9uZW50cyA9IHN0YXRlZnVsU3RyZWFtKHt9KTtcbiAgY29uc3QgY29tcHV0ZUl0ZW1LZXkgPSBzdGF0ZWZ1bFN0cmVhbShpZGVudGl0eSk7XG4gIGNvbnN0IHNjcm9sbGVyUmVmID0gc3RhdGVmdWxTdHJlYW0obm9vcCk7XG4gIGNvbnN0IGRpc3RpbmN0UHJvcCA9IChwcm9wTmFtZSwgZGVmYXVsdFZhbHVlID0gbnVsbCkgPT4ge1xuICAgIHJldHVybiBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tcG9uZW50cyxcbiAgICAgICAgbWFwKChjb21wb25lbnRzMikgPT4gY29tcG9uZW50czJbcHJvcE5hbWVdKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKSxcbiAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29udGV4dCxcbiAgICBpdGVtQ29udGVudCxcbiAgICBmaXhlZEhlYWRlckNvbnRlbnQsXG4gICAgZml4ZWRGb290ZXJDb250ZW50LFxuICAgIGNvbXBvbmVudHMsXG4gICAgY29tcHV0ZUl0ZW1LZXksXG4gICAgc2Nyb2xsZXJSZWYsXG4gICAgVGFibGVDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlRhYmxlXCIsIFwidGFibGVcIiksXG4gICAgVGFibGVIZWFkQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJUYWJsZUhlYWRcIiwgXCJ0aGVhZFwiKSxcbiAgICBUYWJsZUZvb3RlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVGFibGVGb290XCIsIFwidGZvb3RcIiksXG4gICAgVGFibGVCb2R5Q29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJUYWJsZUJvZHlcIiwgXCJ0Ym9keVwiKSxcbiAgICBUYWJsZVJvd0NvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVGFibGVSb3dcIiwgXCJ0clwiKSxcbiAgICBTY3JvbGxlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgRW1wdHlQbGFjZWhvbGRlcjogZGlzdGluY3RQcm9wKFwiRW1wdHlQbGFjZWhvbGRlclwiKSxcbiAgICBTY3JvbGxTZWVrUGxhY2Vob2xkZXI6IGRpc3RpbmN0UHJvcChcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKSxcbiAgICBGaWxsZXJSb3c6IGRpc3RpbmN0UHJvcChcIkZpbGxlclJvd1wiKVxuICB9O1xufSk7XG5jb25zdCBjb21iaW5lZFN5c3RlbSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW0oKFtsaXN0U3lzdGVtMiwgcHJvcHNTeXN0ZW1dKSA9PiB7XG4gIHJldHVybiB7IC4uLmxpc3RTeXN0ZW0yLCAuLi5wcm9wc1N5c3RlbSB9O1xufSwgdHVwKGxpc3RTeXN0ZW0sIHRhYmxlQ29tcG9uZW50UHJvcHNTeXN0ZW0pKTtcbmNvbnN0IERlZmF1bHRTY3JvbGxTZWVrUGxhY2Vob2xkZXIgPSAoeyBoZWlnaHQgfSkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgc3R5bGU6IHsgaGVpZ2h0IH0gfSkpO1xuY29uc3QgRGVmYXVsdEZpbGxlclJvdyA9ICh7IGhlaWdodCB9KSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBzdHlsZTogeyBoZWlnaHQsIHBhZGRpbmc6IDAsIGJvcmRlcjogMCB9IH0pKTtcbmNvbnN0IElURU1fU1RZTEUgPSB7IG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiB9O1xuY29uc3QgSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb0l0ZW1zMigpIHtcbiAgY29uc3QgbGlzdFN0YXRlID0gdXNlRW1pdHRlclZhbHVlKFwibGlzdFN0YXRlXCIpO1xuICBjb25zdCBzaXplUmFuZ2VzID0gdXNlUHVibGlzaGVyKFwic2l6ZVJhbmdlc1wiKTtcbiAgY29uc3QgdXNlV2luZG93U2Nyb2xsID0gdXNlRW1pdHRlclZhbHVlKFwidXNlV2luZG93U2Nyb2xsXCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSB1c2VQdWJsaXNoZXIoXCJ3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZVwiKTtcbiAgY29uc3QgX3Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSB1c2VQdWJsaXNoZXIoXCJzY3JvbGxDb250YWluZXJTdGF0ZVwiKTtcbiAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrIDogX3Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2s7XG4gIGNvbnN0IGl0ZW1Db250ZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiaXRlbUNvbnRlbnRcIik7XG4gIGNvbnN0IHRyYWNrSXRlbVNpemVzID0gdXNlRW1pdHRlclZhbHVlKFwidHJhY2tJdGVtU2l6ZXNcIik7XG4gIGNvbnN0IGl0ZW1TaXplID0gdXNlRW1pdHRlclZhbHVlKFwiaXRlbVNpemVcIik7XG4gIGNvbnN0IGxvZyA9IHVzZUVtaXR0ZXJWYWx1ZShcImxvZ1wiKTtcbiAgY29uc3QgeyBjYWxsYmFja1JlZiwgcmVmIH0gPSB1c2VDaGFuZ2VkTGlzdENvbnRlbnRzU2l6ZXMoXG4gICAgc2l6ZVJhbmdlcyxcbiAgICBpdGVtU2l6ZSxcbiAgICB0cmFja0l0ZW1TaXplcyxcbiAgICBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLFxuICAgIGxvZyxcbiAgICB2b2lkIDAsXG4gICAgY3VzdG9tU2Nyb2xsUGFyZW50XG4gICk7XG4gIGNvbnN0IFtkZXZpYXRpb24sIHNldERldmlhdGlvbl0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgdXNlRW1pdHRlcihcImRldmlhdGlvblwiLCAodmFsdWUpID0+IHtcbiAgICBpZiAoZGV2aWF0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgcmVmLmN1cnJlbnQuc3R5bGUubWFyZ2luVG9wID0gYCR7dmFsdWV9cHhgO1xuICAgICAgc2V0RGV2aWF0aW9uKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBFbXB0eVBsYWNlaG9sZGVyID0gdXNlRW1pdHRlclZhbHVlKFwiRW1wdHlQbGFjZWhvbGRlclwiKTtcbiAgY29uc3QgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyID0gdXNlRW1pdHRlclZhbHVlKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIpIHx8IERlZmF1bHRTY3JvbGxTZWVrUGxhY2Vob2xkZXI7XG4gIGNvbnN0IEZpbGxlclJvdyA9IHVzZUVtaXR0ZXJWYWx1ZShcIkZpbGxlclJvd1wiKSB8fCBEZWZhdWx0RmlsbGVyUm93O1xuICBjb25zdCBUYWJsZUJvZHlDb21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJUYWJsZUJvZHlDb21wb25lbnRcIik7XG4gIGNvbnN0IFRhYmxlUm93Q29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiVGFibGVSb3dDb21wb25lbnRcIik7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gdXNlRW1pdHRlclZhbHVlKFwiY29tcHV0ZUl0ZW1LZXlcIik7XG4gIGNvbnN0IGlzU2Vla2luZyA9IHVzZUVtaXR0ZXJWYWx1ZShcImlzU2Vla2luZ1wiKTtcbiAgY29uc3QgcGFkZGluZ1RvcEFkZGl0aW9uID0gdXNlRW1pdHRlclZhbHVlKFwicGFkZGluZ1RvcEFkZGl0aW9uXCIpO1xuICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHVzZUVtaXR0ZXJWYWx1ZShcImZpcnN0SXRlbUluZGV4XCIpO1xuICBjb25zdCBzdGF0ZWZ1bFRvdGFsQ291bnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJzdGF0ZWZ1bFRvdGFsQ291bnRcIik7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUoXCJjb250ZXh0XCIpO1xuICBpZiAoc3RhdGVmdWxUb3RhbENvdW50ID09PSAwICYmIEVtcHR5UGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChFbXB0eVBsYWNlaG9sZGVyLCBjb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChFbXB0eVBsYWNlaG9sZGVyLCBjb250ZXh0KSk7XG4gIH1cbiAgY29uc3QgcGFkZGluZ1RvcCA9IGxpc3RTdGF0ZS5vZmZzZXRUb3AgKyBwYWRkaW5nVG9wQWRkaXRpb24gKyBkZXZpYXRpb247XG4gIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBsaXN0U3RhdGUub2Zmc2V0Qm90dG9tO1xuICBjb25zdCBwYWRkaW5nVG9wRWwgPSBwYWRkaW5nVG9wID4gMCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEZpbGxlclJvdywgeyBoZWlnaHQ6IHBhZGRpbmdUb3AsIGtleTogXCJwYWRkaW5nLXRvcFwiLCBjb250ZXh0IH0pIDogbnVsbDtcbiAgY29uc3QgcGFkZGluZ0JvdHRvbUVsID0gcGFkZGluZ0JvdHRvbSA+IDAgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChGaWxsZXJSb3csIHsgaGVpZ2h0OiBwYWRkaW5nQm90dG9tLCBrZXk6IFwicGFkZGluZy1ib3R0b21cIiwgY29udGV4dCB9KSA6IG51bGw7XG4gIGNvbnN0IGl0ZW1zID0gbGlzdFN0YXRlLml0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gaXRlbS5vcmlnaW5hbEluZGV4O1xuICAgIGNvbnN0IGtleSA9IGNvbXB1dGVJdGVtS2V5KGluZGV4ICsgZmlyc3RJdGVtSW5kZXgsIGl0ZW0uZGF0YSwgY29udGV4dCk7XG4gICAgaWYgKGlzU2Vla2luZykge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Nyb2xsU2Vla1BsYWNlaG9sZGVyLCB7XG4gICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFNjcm9sbFNlZWtQbGFjZWhvbGRlciwgY29udGV4dCksXG4gICAgICAgIGtleSxcbiAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgIGhlaWdodDogaXRlbS5zaXplLFxuICAgICAgICB0eXBlOiBpdGVtLnR5cGUgfHwgXCJpdGVtXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFRhYmxlUm93Q29tcG9uZW50LFxuICAgICAge1xuICAgICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChUYWJsZVJvd0NvbXBvbmVudCwgY29udGV4dCksXG4gICAgICAgIC4uLml0ZW1Qcm9wSWZOb3REb21FbGVtZW50KFRhYmxlUm93Q29tcG9uZW50LCBpdGVtLmRhdGEpLFxuICAgICAgICBrZXksXG4gICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleCxcbiAgICAgICAgXCJkYXRhLWtub3duLXNpemVcIjogaXRlbS5zaXplLFxuICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBpdGVtLmluZGV4LFxuICAgICAgICBzdHlsZTogSVRFTV9TVFlMRVxuICAgICAgfSxcbiAgICAgIGl0ZW1Db250ZW50KGl0ZW0uaW5kZXgsIGl0ZW0uZGF0YSwgY29udGV4dClcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgVGFibGVCb2R5Q29tcG9uZW50LFxuICAgIHsgcmVmOiBjYWxsYmFja1JlZiwgXCJkYXRhLXRlc3QtaWRcIjogXCJ2aXJ0dW9zby1pdGVtLWxpc3RcIiwgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoVGFibGVCb2R5Q29tcG9uZW50LCBjb250ZXh0KSB9LFxuICAgIFtwYWRkaW5nVG9wRWwsIC4uLml0ZW1zLCBwYWRkaW5nQm90dG9tRWxdXG4gICk7XG59KTtcbmNvbnN0IFZpZXdwb3J0ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFZpcnR1b3NvTW9ja0NvbnRleHQpO1xuICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHVzZVB1Ymxpc2hlcihcInZpZXdwb3J0SGVpZ2h0XCIpO1xuICBjb25zdCBmaXhlZEl0ZW1IZWlnaHQgPSB1c2VQdWJsaXNoZXIoXCJmaXhlZEl0ZW1IZWlnaHRcIik7XG4gIGNvbnN0IHZpZXdwb3J0UmVmID0gdXNlU2l6ZShjb21wb3NlKHZpZXdwb3J0SGVpZ2h0LCAoZWwpID0+IGNvcnJlY3RJdGVtU2l6ZShlbCwgXCJoZWlnaHRcIikpKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3R4KSB7XG4gICAgICB2aWV3cG9ydEhlaWdodChjdHgudmlld3BvcnRIZWlnaHQpO1xuICAgICAgZml4ZWRJdGVtSGVpZ2h0KGN0eC5pdGVtSGVpZ2h0KTtcbiAgICB9XG4gIH0sIFtjdHgsIHZpZXdwb3J0SGVpZ2h0LCBmaXhlZEl0ZW1IZWlnaHRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHZpZXdwb3J0U3R5bGUsIHJlZjogdmlld3BvcnRSZWYsIFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwiZWxlbWVudFwiIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBXaW5kb3dWaWV3cG9ydCA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgY3R4ID0gUmVhY3QudXNlQ29udGV4dChWaXJ0dW9zb01vY2tDb250ZXh0KTtcbiAgY29uc3Qgd2luZG93Vmlld3BvcnRSZWN0ID0gdXNlUHVibGlzaGVyKFwid2luZG93Vmlld3BvcnRSZWN0XCIpO1xuICBjb25zdCBmaXhlZEl0ZW1IZWlnaHQgPSB1c2VQdWJsaXNoZXIoXCJmaXhlZEl0ZW1IZWlnaHRcIik7XG4gIGNvbnN0IGN1c3RvbVNjcm9sbFBhcmVudCA9IHVzZUVtaXR0ZXJWYWx1ZShcImN1c3RvbVNjcm9sbFBhcmVudFwiKTtcbiAgY29uc3Qgdmlld3BvcnRSZWYgPSB1c2VXaW5kb3dWaWV3cG9ydFJlY3RSZWYod2luZG93Vmlld3BvcnRSZWN0LCBjdXN0b21TY3JvbGxQYXJlbnQpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGZpeGVkSXRlbUhlaWdodChjdHguaXRlbUhlaWdodCk7XG4gICAgICB3aW5kb3dWaWV3cG9ydFJlY3QoeyBvZmZzZXRUb3A6IDAsIHZpc2libGVIZWlnaHQ6IGN0eC52aWV3cG9ydEhlaWdodCwgdmlzaWJsZVdpZHRoOiAxMDAgfSk7XG4gICAgfVxuICB9LCBbY3R4LCB3aW5kb3dWaWV3cG9ydFJlY3QsIGZpeGVkSXRlbUhlaWdodF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHZpZXdwb3J0UmVmLCBzdHlsZTogdmlld3BvcnRTdHlsZSwgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJ3aW5kb3dcIiB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgVGFibGVSb290ID0gLyogQF9fUFVSRV9fICovIFJlYWN0Lm1lbW8oZnVuY3Rpb24gVGFibGVWaXJ0dW9zb1Jvb3QocHJvcHMpIHtcbiAgY29uc3QgdXNlV2luZG93U2Nyb2xsID0gdXNlRW1pdHRlclZhbHVlKFwidXNlV2luZG93U2Nyb2xsXCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IGZpeGVkSGVhZGVySGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwiZml4ZWRIZWFkZXJIZWlnaHRcIik7XG4gIGNvbnN0IGZpeGVkRm9vdGVySGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwiZml4ZWRGb290ZXJIZWlnaHRcIik7XG4gIGNvbnN0IGZpeGVkSGVhZGVyQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZShcImZpeGVkSGVhZGVyQ29udGVudFwiKTtcbiAgY29uc3QgZml4ZWRGb290ZXJDb250ZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiZml4ZWRGb290ZXJDb250ZW50XCIpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlKFwiY29udGV4dFwiKTtcbiAgY29uc3QgdGhlYWRSZWYgPSB1c2VTaXplKGNvbXBvc2UoZml4ZWRIZWFkZXJIZWlnaHQsIChlbCkgPT4gY29ycmVjdEl0ZW1TaXplKGVsLCBcImhlaWdodFwiKSkpO1xuICBjb25zdCB0Zm9vdFJlZiA9IHVzZVNpemUoY29tcG9zZShmaXhlZEZvb3RlckhlaWdodCwgKGVsKSA9PiBjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSk7XG4gIGNvbnN0IFRoZVNjcm9sbGVyID0gY3VzdG9tU2Nyb2xsUGFyZW50IHx8IHVzZVdpbmRvd1Njcm9sbCA/IFdpbmRvd1Njcm9sbGVyIDogU2Nyb2xsZXI7XG4gIGNvbnN0IFRoZVZpZXdwb3J0ID0gY3VzdG9tU2Nyb2xsUGFyZW50IHx8IHVzZVdpbmRvd1Njcm9sbCA/IFdpbmRvd1ZpZXdwb3J0IDogVmlld3BvcnQ7XG4gIGNvbnN0IFRoZVRhYmxlID0gdXNlRW1pdHRlclZhbHVlKFwiVGFibGVDb21wb25lbnRcIik7XG4gIGNvbnN0IFRoZVRIZWFkID0gdXNlRW1pdHRlclZhbHVlKFwiVGFibGVIZWFkQ29tcG9uZW50XCIpO1xuICBjb25zdCBUaGVURm9vdCA9IHVzZUVtaXR0ZXJWYWx1ZShcIlRhYmxlRm9vdGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCB0aGVIZWFkID0gZml4ZWRIZWFkZXJDb250ZW50ID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBUaGVUSGVhZCxcbiAgICB7XG4gICAgICBrZXk6IFwiVGFibGVIZWFkXCIsXG4gICAgICBzdHlsZTogeyB6SW5kZXg6IDIsIHBvc2l0aW9uOiBcInN0aWNreVwiLCB0b3A6IDAgfSxcbiAgICAgIHJlZjogdGhlYWRSZWYsXG4gICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChUaGVUSGVhZCwgY29udGV4dClcbiAgICB9LFxuICAgIGZpeGVkSGVhZGVyQ29udGVudCgpXG4gICkgOiBudWxsO1xuICBjb25zdCB0aGVGb290ID0gZml4ZWRGb290ZXJDb250ZW50ID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBUaGVURm9vdCxcbiAgICB7XG4gICAgICBrZXk6IFwiVGFibGVGb290XCIsXG4gICAgICBzdHlsZTogeyB6SW5kZXg6IDEsIHBvc2l0aW9uOiBcInN0aWNreVwiLCBib3R0b206IDAgfSxcbiAgICAgIHJlZjogdGZvb3RSZWYsXG4gICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChUaGVURm9vdCwgY29udGV4dClcbiAgICB9LFxuICAgIGZpeGVkRm9vdGVyQ29udGVudCgpXG4gICkgOiBudWxsO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGhlU2Nyb2xsZXIsIHsgLi4ucHJvcHMgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGhlVmlld3BvcnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgVGhlVGFibGUsXG4gICAgeyBzdHlsZTogeyBib3JkZXJTcGFjaW5nOiAwLCBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIgfSwgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoVGhlVGFibGUsIGNvbnRleHQpIH0sXG4gICAgW3RoZUhlYWQsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KEl0ZW1zLCB7IGtleTogXCJUYWJsZUJvZHlcIiB9KSwgdGhlRm9vdF1cbiAgKSkpO1xufSk7XG5jb25zdCB7XG4gIENvbXBvbmVudDogVGFibGUsXG4gIHVzZVB1Ymxpc2hlcixcbiAgdXNlRW1pdHRlclZhbHVlLFxuICB1c2VFbWl0dGVyXG59ID0gLyogQF9fUFVSRV9fICovIHN5c3RlbVRvQ29tcG9uZW50KFxuICBjb21iaW5lZFN5c3RlbSxcbiAge1xuICAgIHJlcXVpcmVkOiB7fSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgcmVzdG9yZVN0YXRlRnJvbTogXCJyZXN0b3JlU3RhdGVGcm9tXCIsXG4gICAgICBjb250ZXh0OiBcImNvbnRleHRcIixcbiAgICAgIGZvbGxvd091dHB1dDogXCJmb2xsb3dPdXRwdXRcIixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBcImZpcnN0SXRlbUluZGV4XCIsXG4gICAgICBpdGVtQ29udGVudDogXCJpdGVtQ29udGVudFwiLFxuICAgICAgZml4ZWRIZWFkZXJDb250ZW50OiBcImZpeGVkSGVhZGVyQ29udGVudFwiLFxuICAgICAgZml4ZWRGb290ZXJDb250ZW50OiBcImZpeGVkRm9vdGVyQ29udGVudFwiLFxuICAgICAgb3ZlcnNjYW46IFwib3ZlcnNjYW5cIixcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogXCJpbmNyZWFzZVZpZXdwb3J0QnlcIixcbiAgICAgIHRvdGFsQ291bnQ6IFwidG90YWxDb3VudFwiLFxuICAgICAgdG9wSXRlbUNvdW50OiBcInRvcEl0ZW1Db3VudFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGNvbXBvbmVudHM6IFwiY29tcG9uZW50c1wiLFxuICAgICAgZ3JvdXBDb3VudHM6IFwiZ3JvdXBDb3VudHNcIixcbiAgICAgIGF0Qm90dG9tVGhyZXNob2xkOiBcImF0Qm90dG9tVGhyZXNob2xkXCIsXG4gICAgICBhdFRvcFRocmVzaG9sZDogXCJhdFRvcFRocmVzaG9sZFwiLFxuICAgICAgY29tcHV0ZUl0ZW1LZXk6IFwiY29tcHV0ZUl0ZW1LZXlcIixcbiAgICAgIGRlZmF1bHRJdGVtSGVpZ2h0OiBcImRlZmF1bHRJdGVtSGVpZ2h0XCIsXG4gICAgICBmaXhlZEl0ZW1IZWlnaHQ6IFwiZml4ZWRJdGVtSGVpZ2h0XCIsXG4gICAgICBpdGVtU2l6ZTogXCJpdGVtU2l6ZVwiLFxuICAgICAgc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb246IFwic2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb25cIixcbiAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudDogXCJpbml0aWFsSXRlbUNvdW50XCIsXG4gICAgICBpbml0aWFsU2Nyb2xsVG9wOiBcImluaXRpYWxTY3JvbGxUb3BcIixcbiAgICAgIGFsaWduVG9Cb3R0b206IFwiYWxpZ25Ub0JvdHRvbVwiLFxuICAgICAgdXNlV2luZG93U2Nyb2xsOiBcInVzZVdpbmRvd1Njcm9sbFwiLFxuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50OiBcImN1c3RvbVNjcm9sbFBhcmVudFwiLFxuICAgICAgc2Nyb2xsZXJSZWY6IFwic2Nyb2xsZXJSZWZcIixcbiAgICAgIGxvZ0xldmVsOiBcImxvZ0xldmVsXCJcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFwic2Nyb2xsVG9JbmRleFwiLFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2Nyb2xsSW50b1ZpZXdcIixcbiAgICAgIHNjcm9sbFRvOiBcInNjcm9sbFRvXCIsXG4gICAgICBzY3JvbGxCeTogXCJzY3JvbGxCeVwiLFxuICAgICAgZ2V0U3RhdGU6IFwiZ2V0U3RhdGVcIlxuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICBpc1Njcm9sbGluZzogXCJpc1Njcm9sbGluZ1wiLFxuICAgICAgZW5kUmVhY2hlZDogXCJlbmRSZWFjaGVkXCIsXG4gICAgICBzdGFydFJlYWNoZWQ6IFwic3RhcnRSZWFjaGVkXCIsXG4gICAgICByYW5nZUNoYW5nZWQ6IFwicmFuZ2VDaGFuZ2VkXCIsXG4gICAgICBhdEJvdHRvbVN0YXRlQ2hhbmdlOiBcImF0Qm90dG9tU3RhdGVDaGFuZ2VcIixcbiAgICAgIGF0VG9wU3RhdGVDaGFuZ2U6IFwiYXRUb3BTdGF0ZUNoYW5nZVwiLFxuICAgICAgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZDogXCJ0b3RhbExpc3RIZWlnaHRDaGFuZ2VkXCIsXG4gICAgICBpdGVtc1JlbmRlcmVkOiBcIml0ZW1zUmVuZGVyZWRcIixcbiAgICAgIGdyb3VwSW5kaWNlczogXCJncm91cEluZGljZXNcIlxuICAgIH1cbiAgfSxcbiAgVGFibGVSb290XG4pO1xuY29uc3QgU2Nyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRTY3JvbGxlcih7IHVzZVB1Ymxpc2hlciwgdXNlRW1pdHRlclZhbHVlLCB1c2VFbWl0dGVyIH0pO1xuY29uc3QgV2luZG93U2Nyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRXaW5kb3dTY3JvbGxlcih7IHVzZVB1Ymxpc2hlciwgdXNlRW1pdHRlclZhbHVlLCB1c2VFbWl0dGVyIH0pO1xuY29uc3QgVGFibGVWaXJ0dW9zbyA9IFRhYmxlO1xuZXhwb3J0IHtcbiAgR3JvdXBlZFZpcnR1b3NvLFxuICBMb2dMZXZlbCxcbiAgVGFibGVWaXJ0dW9zbyxcbiAgVmlydHVvc28sXG4gIFZpcnR1b3NvR3JpZCxcbiAgVmlydHVvc29HcmlkTW9ja0NvbnRleHQsXG4gIFZpcnR1b3NvTW9ja0NvbnRleHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=